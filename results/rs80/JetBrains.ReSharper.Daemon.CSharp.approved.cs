[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.UnassignedFieldCompilerWarning), "CSHARP", "CS0649")]
[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.UnusedFieldCompilerWarning), "CSHARP", "CS0169")]
[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.UnassignedReadonlyFieldCompilerWarning), "CSHARP", "CS0649")]
[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.UnusedVariableCompilerWarning), "CSHARP", "CS0168")]
[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.NotAccessedVariableWarning), "CSHARP", "CS0219")]
[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.UnusedLabelWarning), "CSHARP", "CS0164")]
[assembly: JetBrains.ReSharper.Daemon.CompilerIdForLanguageAttribute(typeof(JetBrains.ReSharper.Daemon.UsageChecking.EventNeverInvokedWarning), "CSHARP", "CS0067")]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("GCSuppressFinalizeForTypeWithoutDestructor", null, "CodeSmell", "\'GC.SuppressFinalize\' is invoked for type without destructor", "\\n          \'GC.SuppressFinalize\' is invoked for type without destructor.\\n      " +
    "  ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PureAttributeOnVoidMethod", null, "CodeSmell", "\'void\' method is annotated by [Pure]", "\'void\' method is annotated by [Pure]", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("InvocationIsSkipped", null, "CodeInfo", "Method invocation is skipped", "Method invocation is skipped. Compiler will not generate method invocation becaus" +
    "e the method is conditional, or it is partial method without implementation.", JetBrains.ReSharper.Daemon.Severity.INFO, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConditionIsAlwaysTrueOrFalse", null, "CodeRedundancy", "Expression is always \'true\' or always \'false\'", "\\n          Value of a boolean expression is always the same at this point.\\n    " +
    "    ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ExpressionIsAlwaysNull", null, "CodeRedundancy", "Expression is always \'null\'", "\\n          The expression is always evaluated to \'null\' at this point.\\n        " +
    "", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConstantNullCoalescingCondition", null, "CodeRedundancy", "\'??\' condition is known to be null or not null", "\\n          Left operand of \'??\' expression condition is known to be null or not " +
    "null.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantBoolCompare", null, "CodeRedundancy", "Redundant boolean comparison", "Comparison of a boolean value with \'true\' or \'false\' constant.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantThisQualifier", null, "CodeRedundancy", "Redundant \'this.\' qualifier", "\\n          \'this.\' qualifier is redundant and can be safely removed without chan" +
    "ging code semantics.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantBaseQualifier", null, "CodeRedundancy", "Redundant \'base.\' qualifier", "\\n          \'base.\' qualifier is redundant and can be safely removed without chan" +
    "ging code semantics.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantNameQualifier", null, "CodeRedundancy", "Redundant name qualifier", "Redundant use of qualifier for a type name or static member usage.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantCast", null, "CodeRedundancy", "Redundant cast", "Type cast can be safely removed.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantCatchClause", null, "CodeRedundancy", "Redundant catch clause", "\\n          Catch clause with single \'throw\' statement is redundant.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantEmptyFinallyBlock", null, "CodeRedundancy", "Redundant empty finally block", "\\n          Empty \'finally\' block is redundant.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantAssignment", null, "CodeRedundancy", "Assignment is not used", "\\n          Value assigned to a local variable or parameter is not used in any ex" +
    "ecution path.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantToStringCall", null, "CodeRedundancy", "Redundant \'object.ToString()\' call", "\\n          Use of ToString() call in a context where it would be generated by th" +
    "e compiler automatically.\\n          For example, in a concatenation with a stri" +
    "ng or as an argument of a string.Format() call.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantToStringCallForValueType", null, "CodeRedundancy", "Redundant \'object.ToString()\' call for value types", "\\n          Use of ToString() call in a context where it would be generated by th" +
    "e compiler automatically.\\n          For example, in a concatenation with a stri" +
    "ng or as an argument of a string.Format() call.\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantStringFormatCall", null, "CodeRedundancy", "Redundant \'string.Format()\' call", "\\n          Redundant \'string.Format()\' call\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantEnumerableCastCall", null, "CodeRedundancy", "Redundant \'IEnumerable.Cast<T>\' or \'IEnumerable.OfType<T>\' call", "\\n          Redundant \'IEnumerable.Cast<T>\' or \'IEnumerable.OfType<T>\' call\\n    " +
    "    ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantStringToCharArrayCall", null, "CodeRedundancy", "Redundant \'string.ToCharArray()\' call", "\\n          Redundant \'string.ToCharArray()\' call\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantTypeArgumentsOfMethod", null, "CodeRedundancy", "Redundant type arguments of method", "\\n          Specification of method type arguments is redundant because they are " +
    "inferred from argument types.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("UnusedAnonymousMethodSignature", null, "CodeRedundancy", "Anonymous method signature is not necessary", "\\n          Specifying signature in an anonymous method is not necessary because " +
    "none of its parameters are\\n          used in the body.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantDelegateCreation", null, "CodeRedundancy", "Explicit delegate creation expression is redundant", "\\n          Explicit delegate creation expression is redundant\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantAttributeParentheses", null, "CodeRedundancy", "Parentheses are redundant if attribute has no arguments", "\\n          Parentheses are redundant if attribute has no arguments\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ForStatementConditionIsTrue", null, "CodeRedundancy", "\'true\' is redundant as \'for\'-statement condition", "\\n          \'true\' is redundant as \'for\'-statement condition, and thus can safely" +
    " be omitted\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyForStatement", null, "CodeRedundancy", "Empty \'for\' loop is redundant", "\\n          Empty \'for\' loop is redundant\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantUnsafeContext", null, "CodeRedundancy", "Unsafe context declaration is redundant", "\\n          Unsafe context declaration is redundant because it is declared in uns" +
    "afe context, or it doesn\'t contain unsafe constructs\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantEmptyObjectCreationArgumentList", null, "CodeRedundancy", "Redundant empty argument list on object creation expression", "\\n          When object creation uses object or collection initializer, empty arg" +
    "ument list is redundant\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantEmptyObjectOrCollectionInitializer", null, "CodeRedundancy", "Redundant empty object or collection initializer", "\\n          Redundant empty object or collection initializer\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantCollectionInitializerElementBraces", null, "CodeRedundancy", "Redundant braces in collection initializer", "\\n          When collection initializer element has only one expression, the brac" +
    "es are redundant\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantExplicitArrayCreation", null, "CodeRedundancy", "Redundant explicit type in array creation", "\\n          When array type can be inferred from initializer, array creation expr" +
    "ession can be converted to implicitly typed.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantExplicitArraySize", null, "CodeRedundancy", "Redundant explicit size specification in array creation", "\\n          When array initializer has the same number of elements as specified i" +
    "n size expression, explicit size specification is redundant.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantArrayCreationExpression", null, "CodeRedundancy", "Array creation can be replaced with array initializer", "\\n          When initializing explicitly typed local variable or field of array t" +
    "ype, array creation expression can be replaced with array initializer.\\n        " +
    "", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantIfElseBlock", null, "CodeRedundancy", "Redundant \'else\' keyword", "\\n          Redundant \'else\' keyword\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantCaseLabel", null, "CodeRedundancy", "Redundant \'case\' label", "\\n          \'case\' label statement is redundant\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantAnonymousTypePropertyName", null, "CodeRedundancy", "Redundant anonymous type property explicit name", "\\n          Explicit name specification of anonymous type property is redundant. " +
    "It is inferred from initializer expression.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantExplicitNullableCreation", null, "CodeRedundancy", "Redundant explicit nullable type creation", "\\n          Value type is implicitly convertible to it\'s nullable, so explicit nu" +
    "llable type creation is redundant.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantLambdaParameterType", null, "CodeRedundancy", "Redundant lambda parameter explicit type specification", "\\n          Redundant lambda parameter explicit type specification\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantLambdaSignatureParentheses", null, "CodeRedundancy", "Redundant lambda signature parentheses", "\\n          When lambda signature contains single implicitly-typed parameter, sig" +
    "nature parentheses can be omitted\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("DoubleNegationOperator", null, "CodeRedundancy", "Double negation operator", "\\n          Double negation is meaningless\\n          <pre>\\n            bool b =" +
    " !!condition;\\n          </pre>\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantArgumentName", null, "CodeRedundancy", "Redundant explicit argument name specification", "\\n          Redundant explicit argument name specification\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantArgumentNameForLiteralExpression", null, "CodeRedundancy", "Redundant explicit argument name specification for literal expression", "\\n          Redundant explicit argument name specification when argument is liter" +
    "al expression\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantArgumentDefaultValue", null, "CodeRedundancy", "Redundant argument with default value", "\\n          Corresponding parameter is optional and has the same value, so argume" +
    "nt could be ommited\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("HeuristicUnreachableCode", null, "CodeRedundancy", "Heuristically unreachable code", "\\n          Heuristically unreachable code\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantCheckBeforeAssignment", null, "CodeRedundancy", "Redundant condition check before assignments", "\\n          Check for inequality before assignment is redundant\\n          <pre>\\" +
    "n            if (x != value)\\n              x = value;\\n          </pre>\\n      " +
    "  ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantLogicalConditionalExpressionOperand", null, "CodeRedundancy", "Redundant operand in logical conditional expression", "\\n          Redundant operand in logical conditional expression, for example\\n   " +
    "       <pre>\\n            expr || false\\n            expr && true\\n          </p" +
    "re>\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantTernaryExpression", null, "CodeRedundancy", "Redundant conditional ternary expression usage", "\\n          Redundant conditional ternary expression usage\\n          <pre>\\n    " +
    "        condition ? true : false\\n          </pre>\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantEmptyDefaultSwitchBranch", null, "CodeRedundancy", "Redundant empty default switch branch", @"\n          Redundant default switch branch\n          <pre>\n            switch (foo)\n            {\n              case Bar:\n                DoSomething;\n              break;\n              default:\n              break;\n            }\n          </pre>\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantCommaInArrayInitializer", null, "CodeRedundancy", "Redundant comma in array initializer", "\\n          RedundantComma in array initializer\\n          <pre>\\n            int" +
    "[] x = { 0, };\\n          </pre>\\n          ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantUsingDirective", null, "CodeRedundancy", "Redundant using directive", "Using directive is not required by the code and can be safely removed.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantJumpStatement", null, "CodeRedundancy", "Redundant control flow jump statement", "Redundant control flow jump statement", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantComparisonWithNull", null, "CodeRedundancy", "Redundant comparison with \'null\'", "Redundant comparison with \'null\'", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PrivateFieldCanBeConvertedToLocalVariable", null, "CodeRedundancy", "Private field can be converted to local variable", "\\n          Private field is always assigned before being used and can be convert" +
    "ed to local variable.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AssignNullToNotNullAttribute", null, "ConstraintViolation", "Possible \'null\' assignment to entity marked with \'Value cannot be null\' attribute" +
    "", @"\n          An expression which can have 'null' value is assigned to an entity marked with 'Value cannot be null' attribute.\n          In particular, this can happen when passing such value to a method whose parameter is marked with 'Value cannot be null' attribute.\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CannotApplyEqualityOperatorToType", null, "ConstraintViolation", "Compare with \'==\' types marked by \'CannotApplyEqualityOperatorAttribute\'", "\\n          Type is marked by \'CannotApplyEqualityOperatorAttribute\' attribute bu" +
    "t compared with \'==\' or \'!=\' operators\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RequiredBaseTypesIsNotInherited", null, "ConstraintViolation", "Base type is required", "\\n          Concrete base type is required by BaseTypeRequired attribute\\n       " +
    " ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("UnsupportedRequiredBaseType", null, "ConstraintViolation", "BaseTypeRequired attribute supports only classes and interfaces", "\\n          Invalid type specified in BaseTypeRequired attribute usage. Only clas" +
    "ses and interfaces supported\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RequiredBaseTypesDirectConflict", null, "ConstraintViolation", "Type specified in BaseTypeRequired attribure conflicts another type", "\\n          Type specified in BaseTypeRequired attribure conflicts with another t" +
    "ype\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RequiredBaseTypesConflict", null, "ConstraintViolation", "Required base type conflicting another type", "\\n          Type required by some attribute (marked with BaseTypeRequired) confli" +
    "cting type from another attribute\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ContractAnnotationNotParsed", null, "ConstraintViolation", "Problem in contract annotation definition", "\\n          Input string in ContractAnnotation attribute couldn\'t be parsed\\n    " +
    "    ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleNullReferenceException", null, "CodeSmell", "Possible \'System.NullReferenceException\'", @"\n          Dereferencing an expression which can have 'null' value.\n          This warning is detected either when there is a comparison with 'null' earlier in the code or when this value is returned by a member\n          marked with 'Value can be null' attribute.\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleInvalidOperationException", null, "CodeSmell", "Possible \'System.InvalidOperationException\'", "\\n          Possible call to method is invalid for the object\'s current state.\\n " +
    "       ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleInvalidCastException", null, "CodeSmell", "Possible \'System.InvalidCastException\'", "\\n          Possible cast expression of incompatible type\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SimilarAnonymousTypeNearby", null, "CodeSmell", "Similar anonymous type detected nearby", "\\n          Anonymous type which differs only in property order is detected nearb" +
    "y.\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("FunctionNeverReturns", null, "CodeSmell", "Function never returns", "Function does not reach its end or a \'return\' statement by any of possible execut" +
    "ion paths.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("FunctionRecursiveOnAllPaths", null, "CodeSmell", "Function is recursive on all paths", "Function is recursive on all paths.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("LocalVariableHidesMember", null, "CodeSmell", "Local variable hides member", "Local variable has the same name as a field and hides it.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyGeneralCatchClause", null, "CodeSmell", "Empty general catch clause", "A catch clause that catches System.Exception and has an empty body.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ParameterHidesMember", null, "CodeSmell", "Parameter hides member", "Method parameter has the same name as a field and hides it.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ValueParameterNotUsed", null, "CodeSmell", "\'value\' parameter is not used", "\\n          The setter of a property or indexer does not use its \'value\' paramete" +
    "r. Also applies to adders\\n          and removers of events.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("DoNotCallOverridableMethodsInConstructor", null, "CodeSmell", "Virtual member call in constructor", @"\n        When a virtual method is called, the actual type that executes the method \n        is not selected until run time. When a constructor calls a virtual method, \n        it is possible that the constructor for the instance that invokes the method \n        has not executed. See <a href='http://msdn2.microsoft.com/en-us/library/ms182331.aspx'>http://msdn2.microsoft.com/en-us/library/ms182331.aspx</a>.\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleIntendedRethrow", null, "CodeSmell", "Exception rethrow possibly intended", "\\n          A \'throw\' statement inside a catch clause which throws the exception " +
    "caught. In most of cases a \'throw\' statement with no argument is to be used.\\n  " +
    "      ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ReferenceEqualsWithValueType", null, "CodeSmell", "\'Object.ReferenceEquals\' is always false because it is called with value type", "\\n          \'Object.ReferenceEquals\' is always false because it is called with va" +
    "lue type\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CompareNonConstrainedGenericWithNull", null, "CodeSmell", "Possible compare of value type with \'null\'", "\\n          Generic type has no value or class constraint, the condition could be" +
    " always \'false\'\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AccessToModifiedClosure", null, "CodeSmell", "Access to modified closure", "\\n          Access to closure variable from anonymous method when the variable is" +
    " modified externally\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AccessToDisposedClosure", null, "CodeSmell", "Access to disposed closure", "\\n          Access to closure variable from anonymous method when the variable is" +
    " disposed\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleInterfaceMemberAmbiguity", null, "CodeSmell", "Possible ambiguity while accessing member by interface", "\\n          Possible ambiguity while accessing member by interface\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("BitwiseOperatorOnEnumWithoutFlags", null, "CodeSmell", "Bitwise operation on enum which is not marked by [Flags] attribute", "\\n          Bitwise operation on enum which is not marked by [Flags] attribute\\n " +
    "       ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleLossOfFraction", null, "CodeSmell", "Possible loss of fraction", "\\n          Possible loss of fraction when divide integral values and assign resu" +
    "lt to float or decimal\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConstructorInitializerLoop", null, "CodeSmell", "Possible cyclic constructor call", "\\n          Possible cyclic constructor call\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("OptionalParameterHierarchyMismatch", null, "CodeSmell", "Mismatch optional parameter value in overridden method", "\\n          Mismatch optional parameter value in overridden method\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("OptionalParameterRefOut", null, "CodeSmell", "\'ref\' or \'out\' parameter with [Optional] attribute", "\\n          C# doesn\'t support \'ref\' or \'out\' optional parameters\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CompareOfFloatsByEqualityOperator", null, "CodeSmell", "Compare of float numbers with equality operator", "\\n          Compare of float numbers with equality operator\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleAssignmentToReadonlyField", null, "CodeSmell", "Assignment to a property of a readonly field can be useless", "\\n           Assignment to a property of a readonly field can be useless\\n       " +
    " ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("StaticFieldInitializersReferesToFieldBelow", null, "CodeSmell", "Static field initializer refers to static field below or in other part", "\\n          Static field initializer refers to static field below or in other par" +
    "t\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EventUnsubscriptionViaAnonymousDelegate", null, "CodeSmell", "Event unsubscription via anonymous delegate", "\\n          Event unsubscription via anonymous delegate is meaningless\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ForControlVariableIsNeverModified", null, "CodeSmell", "\'for\' loop control variable is never modified", "\\n          \'for\' loop control variable is never modified. Usually this indicates" +
    " mistype in code.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EqualExpressionComparison", null, "CodeSmell", "Similar expressions comparison", "\\n          Compare to similar expression for equality is usually senseless\\n    " +
    "    ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConditionalTernaryEqualBranch", null, "CodeSmell", "\'?:\' expression has identical true and false branches", "\\n          \'?:\' expression has identical true and false branches\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PolymorphicFieldLikeEventInvocation", null, "CodeSmell", "Invocation of polymorphic field-like event", "\\n          Invocation of \'virtual\' or \'override\' field-like event leads to unpre" +
    "dictable result since invocation list is not virtual\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MemberHidesStaticFromOuterClass", null, "CodeSmell", "Member hides static member from outer class", "\\n          Member hides static member from outer class\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PartialMethodParameterNameMismatch", null, "CodeSmell", "Parameter name differs in partial method declaration", "\\n          Parameter name differs in partial method declaration\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("DynamicShiftRightOpIsNotInt", null, "CodeSmell", "Right operand of dynamic shift operation should be convertible to \'int\'", "\\n          Right operand of dynamic shift operation should be convertible to \'in" +
    "t\'\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("NotResolvedInText", null, "CodeSmell", "Cannot resolve symbol in text argument", "\\n          Cannot resolve symbol in text argument\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleMultipleEnumeration", null, "CodeSmell", "Possible multiple enumeration of IEnumerable", "\\n          Possible multiple enumeration of IEnumerable\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ReturnValueOfPureMethodIsNotUsed", null, "CodeSmell", "Return value of pure method is not used", "\\n          Return value of pure method is not used\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("IteratorMethodResultIsIgnored", null, "CodeSmell", "Return value of iterator is not used", "\\n          Return value of iterator is not used\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ImpureMethodCallOnReadonlyValueField", null, "CodeSmell", "Impure method is called for readonly field of value type", "\\n          Impure method is called for readonly field of value type\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("NonReadonlyFieldInGetHashCode", null, "CodeSmell", "Non-readonly field referenced in \'GetHashCode()\'", "\\n          Non-readonly field referenced in \'GetHashCode()\'\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("BaseObjectGetHashCodeCallInGetHashCode", null, "CodeSmell", "Overriden GetHashCode calls base \'Object.GetHashCode()\'", "\\n          Overriden GetHashCode calls base \'Object.GetHashCode()\'\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("BaseObjectEqualsIsObjectEquals", null, "CodeSmell", "Call to \'base.Equals(...)\' is reference equality", "\\n          Call to base \'Equals(...)\' method is resolved to \'Object.Equals\', whi" +
    "ch is reference equality\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("OperatorIsCanBeUsed", null, "CodeSmell", "Operator \'is\'/\'Type Of ... Is ...\' can be used", "\\n          Operator \'is\'/\'Type Of ... Is ...\' can be used instead of comparing o" +
    "bjects GetType() and instance of System.Type object\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("LongLiteralEndingLowerL", null, "CodeSmell", "Long literal ending with \'l\' instead of \'L\'", "\\n          Long literal ending with \'l\' instead of \'L\'\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("StaticFieldInGenericType", null, "CodeSmell", "Static field in generic type", "\\n          Static field in generic type\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ThreadStaticFieldHasInitializer", null, "CodeSmell", "Thread static field has initializer", "\\n          Thread static field has initializer, it is invoked only once on the t" +
    "hread that\'s running when the static constructor executes\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ReadAccessInDoubleCheckLocking", null, "CodeSmell", "Possible incorrect implementation of Double-Check Locking pattern. Read access to" +
    " checked field", "\\n          Possible incorrect implementation of Double-Check Locking pattern. Re" +
    "ad access to checked field\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleMultipleWriteAccessInDoubleCheckLocking", null, "CodeSmell", "Possible incorrect implementation of Double-Check Locking pattern. Possible multi" +
    "ple write access to checked field", "\\n          Possible incorrect implementation of Double-Check Locking pattern. Po" +
    "ssible multiple write access to checked field\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("NonVolatileFieldInDoubleCheckLocking", null, "CodeSmell", "Possible incorrect implementation of Double-Check Locking. Checked field must be " +
    "volatile or assigned from local variable after \'Thread.MemoryBarrier()\' call", "\\n          Possible incorrect implementation of Double-Check Locking. Checked fi" +
    "eld must be volatile or assigned from local variable after \'Thread.MemoryBarrier" +
    "()\' call\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossiblyMistakenUseOfParamsMethod", null, "CodeSmell", "Method with \'params\' is invoked while more specific method is available", "\\n          Invocation is resolved to method with \'params\', but more specific met" +
    "hod is available and arguments partially match it.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EnumerableSumInExplicitUncheckedContext", null, "CodeSmell", "\'Enumerable.Sum\' invocation in explicit unchecked context", "\\n          \'Enumerable.Sum\' invocation in explicit unchecked context\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("BaseMethodCallWithDefaultParameter", null, "CodeSmell", "Call to base member with implicit default parameters", "\\n          Call to base member with implicit default parameters\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CanBeReplacedWithTryCastAndCheckForNull", null, "CodeSmell", "Type check and direct cast can be replaced with try cast and check for null", "\\n          \'if (x is MyObject) { var myObject = (MyObject)x; ... }\' can be repla" +
    "ced with \'var myObject = x as myObject; if (myObject != null) { ... }\'\\n        " +
    "", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CoVariantArrayConversion", null, "CodeSmell", "Co-variant array conversion", "\\n          Co-variant conversion of array could cause run-time exceptions\\n     " +
    "   ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("DelegateSubtraction", null, "CodeSmell", "Delegate subtractions", "\\n          Delegate subtraction has unpredictable result\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MethodOverloadWithOptionalParameter", null, "CodeSmell", "Method with optional or \'params\' parameter is hidden by overload", "\\n          Method with optional or \'params\' parameter is hidden by overload\\n   " +
    "     ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ThreadStaticAtInstanceField", null, "CodeSmell", "[ThreadStatic] doesn\'t work with instance fields", "\\n          [ThreadStatic] does nothing with instance fields\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AnnotationConflictInHierarchy", null, "CodeSmell", "Annotation conflict in hierarchy", "There is base member that has conflicting nullness annotation.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("DefaultValueAttributeForOptionalParameter", null, "CodeSmell", "Possibly misleading \'DefaultValueAttribute\' usage to define optional parameter va" +
    "lue", "Possibly misleading \'DefaultValueAttribute\' usage to define optional parameter va" +
    "lue. \'DefaultParameterValueAttribute\' should be used instead", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ImplicitlyCapturedClosure", null, "CodeSmell", "Implicitly captured closure", "Warns that lambda implicitly captures locals", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PossibleUnintendedReferenceComparison", null, "CodeSmell", "Possible unintended reference comparison", "Possible unintended reference comparison", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ObjectCreationAsStatement", null, "CodeSmell", "Possible unassigned object created by \'new\' expression", "Object created by \'new\' expression is possibly not assigned anywhere", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MultipleOrderBy", null, "CodeSmell", "Multiple sequential \'OrderBy\' invocation", "Multiple sequential \'OrderBy\' invocation is meaningless. Possible \'ThenBy\' means", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ExplicitCallerInfoArgument", null, "CodeSmell", "Explicit argument passed to parameter with caller info attribute", "Compiler generates correct value for parameters marked with [CallerMemberName], [" +
    "CallerFilePath] or [CallerLineNumber] attributes", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AccessToForEachVariableInClosure", null, "CodeSmell", "Access to foreach variable in closure", "\\n          This code can have different behaviour when compiled with different v" +
    "ersions of compiler. See changes for \'foreach\' loop in C# 5.0 and Visual Basic 1" +
    "1\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("TailRecursiveCall", null, "CodeSmell", "Tail recursive call may be replaced with loop", "\\n          Tail recursive calls may be replaced with loop for better performance" +
    " and protection from possible stack overflows.\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("TooWideLocalVariableScope", null, "BestPractice", "Local variable has too wide declaration scope", "\\n          Local variable is declared in a wider scope than the scope of its act" +
    "ual use.\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MoreSpecificForeachVariableTypeAvailable", null, "BestPractice", "Iteration variable can be declared with a more specific type", "\\n          Type of iteration variable declared in \'foreach\' statement is less sp" +
    "ecific than that which can be inferred from the collection type being iterated.\\" +
    "n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PublicConstructorInAbstractClass", null, "BestPractice", "Make constructor in abstract class protected", "\\n          Make constructor in abstract class protected\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ReplaceWithStringIsNullOrEmpty", null, "BestPractice", "Use \'String.IsNullOrEmpty\'", "\\n          Replace direct comparison to null and empty string with \'String.IsNul" +
    "lOrEmpty\' call.\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("TypeParameterCanBeVariant", null, "BestPractice", "Type parameter could be declared as covariant or contravariant", "\\n          Type parameter could be declared as covariant or contravariant\\n     " +
    "   ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("JoinDeclarationAndInitializer", null, "BestPractice", "Join local variable declaration and assignment", "\\n          Join local variable declaration and assignment\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AccessToStaticMemberViaDerivedType", null, "BestPractice", "Access to a static member of a type via a derived type", "\\n          Access to a static member of a type via a derived type\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("BaseMemberHasParams", null, "BestPractice", "Base member has \'params\' parameter, but overrider hasn\'t", "\\n          Base member has \'params\' parameter, but overrider hasn\'t\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("NegativeEqualityExpression", null, "BestPractice", "Simplify negative equality expression", "\\n          Suggest to replace \\n          !(expr1 != expr2) to expr1 == expr2\\n " +
    "         !(expr1 == expr2) to expr1 != expr2\\n          ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("UseIndexedProperty", null, "BestPractice", "Use indexed property", "\\n          Use indexed property in COM import types instead of the accessor usag" +
    "e\\n          ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AnnotationRedundanceInHierarchy", null, "BestPractice", "Annotation duplicate in hierarchy", "There is base member that has the same nullness annotation.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("AnnotationRedundanceAtValueType", null, "BestPractice", "Nullable attribute usage with declaration having value or void type", "Nullable attribute usage with declaration having value or void type doesn\'t affec" +
    "t code analysis.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MultipleNullableAttributesUsage", null, "BestPractice", "Multiple nullable attributes usage", "It is incorrect to use [NotNull] and [CanBeNull] simultaneously.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("TryStatementsCanBeMerged", null, "BestPractice", "try-catch and try-finally statements can be merged", "try-catch and try-finally statements can be merged", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SimplifyConditionalTernaryExpression", null, "BestPractice", "Simplify conditional ternary expression", "\\n          Ternary expression contains \'true\' or \'false\' in result branch, for e" +
    "xample\\n          <pre>\\n            condition ? true : elseBranch\\n            " +
    "condition ? thenBranch : true\\n          </pre>\\n          ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SpecifyACultureInStringConversionExplicitly", null, "BestPractice", "Specify a culture in string conversion explicitly", "Specify a culture in string conversion explicitly", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertIfDoToWhile", null, "BestPractice", "Convert \'if do while\' to \'while", "Simplify statement", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertIfToOrExpression", null, "BestPractice", "Convert \'if\' to \'||\'", "\\n          Suggest to replace \\n            bool result = x > 0;\\n            if" +
    "(y > 0)\\n              result = true;\\n          To\\n            bool result = x" +
    " > 0 || y > 0;\\n          ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SimplifyLinqExpression", null, "BestPractice", "Simplify LINQ expression", "Simplify LINQ expression", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MethodSupportsCancellation", null, "BestPractice", "Method supports cancellation", "Method has overload with CancellationToken", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SpecifyStringComparison", null, "BestPractice", "Specify string comparison explicitly", "Specify string comparison explicitly", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("UnreachableCode", null, "BestPractice", "Unreachable code detected", "Code is unreachable", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyStatement", null, "BestPractice", "Empty statement is redundant", "Empty statement is redundant", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyEmbeddedStatement", null, "BestPractice", "Empty control statement body", "Empty control statement body", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SuggestUseVarKeywordEverywhere", null, "LanguageUsage", "Use \'var\' keyword when possible", "\\n          Convert local variable to implicitly typed if initializer type equals" +
    " to variable type.\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SuggestUseVarKeywordEvident", null, "LanguageUsage", "Use \'var\' keyword when initializer explicitly declares type", "\\n          Convert local variable to implicitly typed if initializer has explici" +
    "t type usage (and it equals to variable type).\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("UseObjectOrCollectionInitializer", null, "LanguageUsage", "Use object or collection initializer when possible", "\\n          Suggest to replace object sequential assignments to newly created obj" +
    "ect fields by object initializer\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("InvokeAsExtensionMethod", null, "LanguageUsage", "Convert static method invocation to extension method call", "\\n          When extension method is invoked as static method, convert invocation" +
    " to extension method syntax\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertToAutoProperty", null, "LanguageUsage", "Convert property to auto-property", "\\n          Use auto-property syntax\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertToAutoPropertyWithPrivateSetter", null, "LanguageUsage", "Convert property to auto-property with private setter", "\\n          Use auto-property syntax\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertNullableToShortForm", null, "LanguageUsage", "Convert \'Nullable<T>\' to \'T?\'", "\\n          Rewrite nullable type in short form\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertIfStatementToNullCoalescingExpression", null, "LanguageUsage", "\'if\' statement can be re-written as \'??\' expression", "\\n          Convert the following code:\\n          <pre>\\n            var x = exp" +
    "r1;\\n            if (x = null) x = expr2;\\n          </pre>\\n          To:\\n    " +
    "      <pre>\\n            var x = expr1 ?? expr2;\\n          </pre>\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertIfStatementToConditionalTernaryExpression", null, "LanguageUsage", "\'if\' statement can be re-written as \'?:\' expression", "\\n          Convert the following code:\\n          <pre>\\n            if (conditi" +
    "on) x = expr1;\\n            else x = expr1;\\n          </pre>\\n          To:\\n  " +
    "        <pre>\\n            x = condition ? expr1 : expr2;\\n          </pre>\\n   " +
    "     ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertIfStatementToReturnStatement", null, "LanguageUsage", "\'if-return\' statement can be re-written as \'return\' statement", "\\n          Convert the following code:\\n          <pre>\\n            if (conditi" +
    "on) return expr1;\\n            return expr2;\\n          </pre>\\n          To:\\n " +
    "         <pre>\\n            return condition ? expr1 : expr2;\\n          </pre>\\" +
    "n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertConditionalTernaryToNullCoalescing", null, "LanguageUsage", "\'?:\' expression can be re-written as \'??\' expression", "\\n          \'?:\' expression can be re-written as \'??\' expression\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("InvertIf", null, "LanguageUsage", "Invert \'if\' statement to reduce nesting", "\\n          Invert \'if\' statement to reduce nesting\\n        ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertIfStatementToSwitchStatement", null, "LanguageUsage", "Convert \'if\' statement to \'switch\' statement", "\\n          Convert series of \'if\' statements to single \'switch\' statement\\n     " +
    "   ", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertToStaticClass", null, "LanguageUsage", "Convert to static class", "\\n          Make class static\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ClassCannotBeInstantiated", null, "LanguageUsage", "Class cannot be instantiated", "\\n          Remove \'sealed\' modifier or make constructor public or internal\\n    " +
    "    ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertToLambdaExpression", null, "LanguageUsage", "Convert to lambda expression", "\\n          Convert to lambda with expression right part\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ConvertClosureToMethodGroup", null, "LanguageUsage", "Convert anonymous method to method group", "\\n          Convert anonymous method or lambda expression to method group\\n      " +
    "  ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("IntroduceOptionalParameters.Local", "Introduce optional parameters", "LanguageUsage", "Private accessibility", "\\n          Introduce optional parameters to overload method\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("IntroduceOptionalParameters.Global", "Introduce optional parameters", "LanguageUsage", "Non-private accessibility", "\\n          Introduce optional parameters to overload method\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, true, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantBaseConstructorCall", null, "DeclarationRedundancy", "Redundant base constructor call", "Explicit call to the base class constructor with no arguments. Is generated by th" +
    "e compiler by default and can be omitted.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyConstructor", null, "DeclarationRedundancy", "Empty constructor", "\\n          Empty public constructor declaration with no parameters is redundant." +
    " The compiler generates the same by default.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyDestructor", null, "DeclarationRedundancy", "Empty destructor", "\\n          Empty finalizer declaration is redundant.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantOverridenMember", null, "DeclarationRedundancy", "Redundant member override", "\\n          The override of a virtual member is redundant because it consists of " +
    "only a call to the base.\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EmptyNamespace", null, "DeclarationRedundancy", "Empty namespace declaration", "Empty namespace declaration is redundant.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("SealedMemberInSealedClass", null, "DeclarationRedundancy", "Sealed member in sealed class", "\'sealed\' modifier for member in a sealed class is redundant.", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantExtendsListEntry", null, "DeclarationRedundancy", "Redundant class or interface specification in base types list", "\\n          Type is either mentioned in the base types list of other part, or it " +
    "is interface and appears as other\'s type base and contains no explicit implement" +
    "ations\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PartialTypeWithSinglePart", null, "DeclarationRedundancy", "Redundant \'partial\' modifier on type declaration", "\\n          Class is declared as \'partial\', but has only single part\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("PartialMethodWithSinglePart", null, "DeclarationRedundancy", "Redundant \'partial\' modifier on method declaration", "\\n          Method is declared as \'partial\', but has only single part\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("EnumUnderlyingTypeIsInt", null, "DeclarationRedundancy", "Underlying type of enum is \'int\'", "\\n          \'int\' is default underlying type of enum, so it is not necessary to s" +
    "pecify it explicitly\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantDefaultFieldInitializer", null, "DeclarationRedundancy", "Redundant field initializer", "\\n          Initializing field with default value is redundant\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantParams", null, "DeclarationRedundancy", "\'params\' modifier is always ignored on overrides", "\\n          \'params\' modifier is always ignored on overrides\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantOverload.Local", "Redundant method overload", "DeclarationRedundancy", "Private accessibility", "\\n          Redundant method overload. Use another method with optional parameter" +
    "s\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("RedundantOverload.Global", "Redundant method overload", "DeclarationRedundancy", "Non-private accessibility", "\\n          Redundant method overload. Use another method with optional parameter" +
    "s\\n        ", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, true, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("MeaninglessDefaultParameterValue", null, "DeclarationRedundancy", "\'DefaultParameterValueAttrbiute\' should be used in conjunction with \'OptionalAttr" +
    "ibute\'", "\\n          \'DefaultParameterValueAttrbiute\' should be used in conjunction with \'" +
    "OptionalAttribute\'\\n        ", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0183", null, "CompilerWarnings", "CS0183:Given expression is always of the provided type", "CS0183:Given expression is always of the provided type", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0184", null, "CompilerWarnings", "CS0184:Given expression is never of the provided type", "CS0184:Given expression is never of the provided type", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0162", null, "CompilerWarnings", "CS0162:Code is unreachable", "CS0162:Code is unreachable", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0628", null, "CompilerWarnings", "CS0628:Declaring new protected member in sealed class is the same as declaring it" +
    " as private", "CS0628:Declaring new protected member in sealed class is the same as declaring it" +
    " as private", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1522", null, "CompilerWarnings", "CS1522:Empty switch block", "CS1522:Empty switch block", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0469", null, "CompilerWarnings", "CS0469:\'goto case\' value is not implicitly convertible to required type", "CS0469:\'goto case\' value is not implicitly convertible to required type", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0108", null, "CompilerWarnings", "CS0108,CS0114:Keyword \'new\' is required", "CS0108,CS0114:Keyword \'new\' is required", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0109", null, "CompilerWarnings", "CS0109:Keyword \'new\' is redundant", "CS0109:Keyword \'new\' is redundant", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0660", null, "CompilerWarnings", "CS0660,CS0661:Operator \'==\' or operator \'!=\' with \'Object.Equals(object o)\' and \'" +
    "Object.GetHashCode()\' not overriden", "CS0660,CS0661:Operator \'==\' or operator \'!=\' with \'Object.Equals(object o)\' and \'" +
    "Object.GetHashCode()\' not overriden", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0642", null, "CompilerWarnings", "CS0642:Possible mistaken empty statement", "CS0642:Possible mistaken empty statement", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1030", null, "CompilerWarnings", "CS1030:\'#warning\' directive", "CS1030:\'#warning\' directive", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1717", null, "CompilerWarnings", "CS1717:Assignment made to same variable", "CS1717:Assignment made to same variable", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0252", null, "CompilerWarnings", "CS0252,CS0253:Possible unintended reference comparison", "CS0252,CS0253:Possible unintended reference comparison", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1573", null, "CompilerWarnings", "CS1573:Parameter has no matching param tag in the XML comment", "CS1573:Parameter has no matching param tag in the XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1712", null, "CompilerWarnings", "CS1712:Type parameter has no matching typeparam tag in the XML comment", "CS1712:Type parameter has no matching typeparam tag in the XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1574", null, "CompilerWarnings", "CS1574:Ambiguous reference in XML comment", "CS1574:Ambiguous reference in XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1580", null, "CompilerWarnings", "CS1580:Incorrect signature in XML comment", "CS1580:Incorrect signature in XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1584", null, "CompilerWarnings", "CS1584:Syntax error in XML comment", "CS1584:Syntax error in XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1710", null, "CompilerWarnings", "CS1710:Duplicate typeparam tag in XML comment", "CS1710:Duplicate typeparam tag in XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1571", null, "CompilerWarnings", "CS1571:Duplicate param tag in XML comment", "CS1571:Duplicate param tag in XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1587", null, "CompilerWarnings", "CS1587:XML comment is not placed on a valid language element", "CS1587:XML comment is not placed on a valid language element", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1592", null, "CompilerWarnings", "CS1592:Badly formed XML in included comments file", "CS1592:Badly formed XML in included comments file", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1590", null, "CompilerWarnings", "CS1590:Invalid XML include element", "CS1590:Invalid XML include element", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1589", null, "CompilerWarnings", "CS1589:Unable to include XML fragment", "CS1589:Unable to include XML fragment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1570", null, "CompilerWarnings", "CS1570:Invalid XML in XML comment", "CS1570:Invalid XML in XML comment", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1723", null, "CompilerWarnings", "CS1723:XML comment has cref attribute that refers to a type parameter", "CS1723:XML comment has cref attribute that refers to a type parameter", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1591", null, "CompilerWarnings", "CS1591:Missing XML comment for publicly visible type or member", "CS1591:Missing XML comment for publicly visible type or member", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0672", null, "CompilerWarnings", "CS0672:Member overrides obsolete member", "CS0672:Member overrides obsolete member", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0665", null, "CompilerWarnings", "CS0665:Assignment in conditional expression", "CS0665:Assignment in conditional expression", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0659", null, "CompilerWarnings", "CS0659:Class overrides Object.Equals(object o) but not Object.GetHashCode()", "CS0659:Class overrides Object.Equals(object o) but not Object.GetHashCode()", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0465", null, "CompilerWarnings", "CS0465:Introducing a \'Finalize\' method can interfere with destructor invocation", "CS0465:Introducing a \'Finalize\' method can interfere with destructor invocation", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0693", null, "CompilerWarnings", "CS0693:Type parameter has the same name as a type parameter from the outer type", "CS0693:Type parameter has the same name as a type parameter from the outer type", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0618", null, "CompilerWarnings", "CS0618:Use of obsolete symbol", "CS0618:Use of obsolete symbol", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0612", null, "CompilerWarnings", "CS0612:Use of obsolete symbol (without message)", "CS0612:Use of obsolete symbol (without message)", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0420", null, "CompilerWarnings", "CS0420:Reference to a volatile field will not be treated as volatile", "CS0420:Reference to a volatile field will not be treated as volatile", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1066", null, "CompilerWarnings", "CS1066:Default value specified for parameter will have no effect because it appli" +
    "es to a member that is used in contexts that do not allow optional arguments", "CS1066:Default value specified for parameter will have no effect because it appli" +
    "es to a member that is used in contexts that do not allow optional arguments", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1911", null, "CompilerWarnings", "CS1911:Access to a member through \'base\' keyword from anonymous method, lambda ex" +
    "pression, query expression or iterator results in unverifiable code", "CS1911:Access to a member through \'base\' keyword from anonymous method, lambda ex" +
    "pression, query expression or iterator results in unverifiable code", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS0197", null, "CompilerWarnings", "CS0197:Taking address of marshal-by-reference class field", "CS0197:Taking address of marshal-by-reference class field", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1957", null, "CompilerWarnings", "CS1957:Multiple override candidates at run-time", "CS1957:Multiple override candidates at run-time", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS1998", null, "CompilerWarnings", "CS1998:Async function without await expression", "CS1998:Async function without await expression", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::CS4014", null, "CompilerWarnings", "CS4014:Async method invocation without await expression", "CS4014:Async method invocation without await expression", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("CSharpWarnings::WME006", null, "CompilerWarnings", "WME006:Namespace should be default namespace of this project", "WME006:Namespace should be default namespace of this project", JetBrains.ReSharper.Daemon.Severity.WARNING, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("LoopCanBeConvertedToQuery", null, "LanguageUsage", "Loop can be converted into LINQ-expression", "A \'foreach\' (\'For Each\' for VB.NET) or \'for\' statement can be converted into a LI" +
    "NQ-expression", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("LoopCanBePartlyConvertedToQuery", null, "LanguageUsage", "Part of loop\'s body can be converted into LINQ-expression", "Part of \'foreach\' (\'For Each\' for VB.NET) statement\'s body can be converted into " +
    "a LINQ-expression", JetBrains.ReSharper.Daemon.Severity.HINT, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterConfigurableSeverityAttribute("ForCanBeConvertedToForeach", null, "LanguageUsage", "For-loop can be converted into foreach-loop", "For-loop can be converted into foreach-loop", JetBrains.ReSharper.Daemon.Severity.SUGGESTION, false, Internal=false)]
[assembly: JetBrains.ReSharper.Daemon.RegisterStaticHighlightingsGroupAttribute("CSharpErrors", "C# Compiler Errors", true)]
[assembly: JetBrains.ReSharper.Daemon.RegisterStaticHighlightingsGroupAttribute("PerformanceHints", "C# performance hints", true)]
[assembly: JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute("ReSharper Captured Identifier", EffectColor="Green", EffectType=JetBrains.TextControl.DocumentMarkup.EffectType.SOLID_UNDERLINE, Layer=2000, VSPriority=40)]
[assembly: JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute("ReSharper Boxing Occurance", EffectColor="Red", EffectType=JetBrains.TextControl.DocumentMarkup.EffectType.SOLID_UNDERLINE, Layer=2000, VSPriority=40)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"JetBrains.ReSharper.FeaturesTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010087f63ba6a789c30e210e7ec987234ad9fe33baf7367993bab1b312d6f72ca296b91ed5c658964ffb9e7570eb184a527c68c6bdba41cfe67d8cfd3f888234206bf39205a3652d3af3445bb6f715fdac532e289fea41229bac37762b67eb16f58fee717d2465fca9ee17f08ed16772a1fc52c1c17022e1f0d9bdd004524a663aca")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]

namespace JetBrains.ReSharper.Daemon.CSharp.Errors
{
    
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract inherited member \'{0}\' is missing {1} accessor implementation")]
    public class AbstractAccessorIsNotImplementedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract inherited member \'{0}\' is missing {1} accessor implementation";
        public AbstractAccessorIsNotImplementedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration inheritorDeclaration, JetBrains.ReSharper.Psi.IAccessor missedAccessor) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration InheritorDeclaration { get; }
        public JetBrains.ReSharper.Psi.IAccessor MissedAccessor { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Accessor in abstract {0} cannot declare a body")]
    public class AbstractAccessorWithBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessor in abstract {0} cannot declare a body";
        public AbstractAccessorWithBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration typeMemberDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration TypeMemberDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot call an abstract base {0} \'{1}\'")]
    public class AbstractBaseMemberCallError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot call an abstract base {0} \'{1}\'";
        public AbstractBaseMemberCallError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.ITypeMember baseMember) { }
        public JetBrains.ReSharper.Psi.ITypeMember BaseMember { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract event cannot have initializer")]
    public class AbstractEventWithInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract event cannot have initializer";
        public AbstractEventWithInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class AbstractInheritedMemberIsNotImplementedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public AbstractInheritedMemberIsNotImplementedError(JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration declaration, JetBrains.ReSharper.Psi.TypeMemberInstance[] notImplementedMembers) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance[] NotImplementedMembers { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract {0} cannot be private")]
    public class AbstractMemberCannotBePrivateError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract {0} cannot be private";
        public AbstractMemberCannotBePrivateError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract {0} cannot be sealed")]
    public class AbstractMemberCannotBeSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract {0} cannot be sealed";
        public AbstractMemberCannotBeSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract {0} cannot be virtual")]
    public class AbstractMemberCannotBeVirtualError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract {0} cannot be virtual";
        public AbstractMemberCannotBeVirtualError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract {0} in non-abstract {1}")]
    public class AbstractMemberInNonabstractClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract {0} in non-abstract {1}";
        public AbstractMemberInNonabstractClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract method cannot declare a body")]
    public class AbstractMethodWithBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract method cannot declare a body";
        public AbstractMethodWithBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract accessor cannot be private")]
    public class AbstractPrivateAccessorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract accessor cannot be private";
        public AbstractPrivateAccessorError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Access modifier is not allowed for static constructor")]
    public class AccessModifierInStaticConstructorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Access modifier is not allowed for static constructor";
        public AccessModifierInStaticConstructorError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The accessibility modifier of the accessor must be more restrictive than the {0} " +
        "\'{1}\'")]
    public class AccessorAccessRightsShouldBeMoreRestrictiveError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The accessibility modifier of the accessor must be more restrictive than the {0} " +
            "\'{1}\'";
        public AccessorAccessRightsShouldBeMoreRestrictiveError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Accessibility modifiers may not be used on accessors in an interface")]
    public class AccessorInInterfaceCannotHaveAccessRightsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessibility modifiers may not be used on accessors in an interface";
        public AccessorInInterfaceCannotHaveAccessRightsError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Interface implementation \'{0}\' is missing accessor \'{1}\' implementation")]
    public class AccessorIsMissingInImplementationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Interface implementation \'{0}\' is missing accessor \'{1}\' implementation";
        public AccessorIsMissingInImplementationError(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration inheritorDeclaration, JetBrains.ReSharper.Psi.IAccessor missedAccessor, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMember) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration InheritorDeclaration { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMember { get; }
        public JetBrains.ReSharper.Psi.IAccessor MissedAccessor { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Accessor declaration is missing")]
    public class AccessorMissingError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessor declaration is missing";
        public AccessorMissingError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot access {0} {1} \'{2}\' here")]
    public class AccessRightsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access {0} {1} \'{2}\' here";
        public AccessRightsError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify accessibility modifiers for both accessors of the {0} \'{1}\'")]
    public class AccessRightsForBothAccessorsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify accessibility modifiers for both accessors of the {0} \'{1}\'";
        public AccessRightsForBothAccessorsError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare access rights for private implementation accessor")]
    public class AccessRightsInPrivateImplementationAccessorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare access rights for private implementation accessor";
        public AccessRightsInPrivateImplementationAccessorError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessor) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration Accessor { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Accessibility modifiers on accessors may only be used if the property or indexer " +
        "has both a get and a set accessor")]
    public class AccessRightsInSingleAccessorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessibility modifiers on accessors may only be used if the property or indexer " +
            "has both a get and a set accessor";
        public AccessRightsInSingleAccessorError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AccessToDisposedClosure", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Access to disposed closure")]
    public class AccessToDisposedClosureWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AccessToDisposedClosure";
        protected const string MESSAGE = "Access to disposed closure";
        public AccessToDisposedClosureWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AccessToForEachVariableInClosure", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Access to foreach variable in closure. May have different behaviour when compiled" +
        " with different versions of compiler")]
    public class AccessToForEachVariableInClosureWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AccessToForEachVariableInClosure";
        protected const string MESSAGE = "Access to foreach variable in closure. May have different behaviour when compiled" +
            " with different versions of compiler";
        public AccessToForEachVariableInClosureWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AccessToModifiedClosure", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Access to modified closure")]
    public class AccessToModifiedClosureWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AccessToModifiedClosure";
        protected const string MESSAGE = "Access to modified closure";
        public AccessToModifiedClosureWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'ref\' or \'out\' parameter \'{0}\' inside an anonymous method body")]
    public class AccessToRefOutParameterFromAnonymousMethodError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'ref\' or \'out\' parameter \'{0}\' inside an anonymous method body";
        public AccessToRefOutParameterFromAnonymousMethodError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IParameter parameter) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IParameter Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AccessToStaticMemberViaDerivedType", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Access to a static member of a type via a derived type")]
    public class AccessToStaticMemberViaDerivedTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AccessToStaticMemberViaDerivedType";
        protected const string MESSAGE = "Access to a static member of a type via a derived type";
        public AccessToStaticMemberViaDerivedTypeWarning(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.Tree.ITreeNode qualifierElement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode QualifierElement { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' adds an accessor not found in interface member \'{1}\'")]
    public class AddedAccessorInPrivateImplementationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' adds an accessor not found in interface member \'{1}\'";
        public AddedAccessorInPrivateImplementationError(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration inheritorDeclaration, JetBrains.ReSharper.Psi.IAccessor accessor, JetBrains.ReSharper.Psi.IProperty superMember) { }
        public JetBrains.ReSharper.Psi.IAccessor Accessor { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration InheritorDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty SuperMember { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot take the address of the given expression")]
    public class AddressOfIncorrectExpressionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot take the address of the given expression";
        public AddressOfIncorrectExpressionError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot take the address of a variable of a managed type \'{0}\'")]
    public class AddressOfManagedTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot take the address of a variable of a managed type \'{0}\'";
        public AddressOfManagedTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression expression, JetBrains.ReSharper.Psi.IType operandType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType OperandType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0197", "CSHARP", CompilerIds=new string[] {
            "CS0197"}, CompilerIdsWithDescription="CS0197:Taking address of marshal-by-reference class field", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Passing \'{0}\' as ref or out or taking its address may cause a runtime exception b" +
        "ecause it is a field of a marshal-by-reference class")]
    public class AddressOfMarshalByRefObjectWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0197";
        protected const string MESSAGE = "Passing \'{0}\' as ref or out or taking its address may cause a runtime exception b" +
            "ecause it is a field of a marshal-by-reference class";
        public AddressOfMarshalByRefObjectWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IField field) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IField Field { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="You can only take the address of an unfixed expression inside of a fixed statemen" +
        "t initializer")]
    public class AddressOfUnfixedExpressionNotInFixedStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "You can only take the address of an unfixed expression inside of a fixed statemen" +
            "t initializer";
        public AddressOfUnfixedExpressionNotInFixedStatementError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AnnotationConflictInHierarchy", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Nullness annotation conflicts with annotation in super type")]
    public class AnnotationConflictInHierarchyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AnnotationConflictInHierarchy";
        protected const string MESSAGE = "Nullness annotation conflicts with annotation in super type";
        public AnnotationConflictInHierarchyWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AnnotationRedundanceAtValueType", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Applying nullness annotation to {0} type is meaningless")]
    public class AnnotationRedundanceAtValueTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AnnotationRedundanceAtValueType";
        protected const string MESSAGE = "Applying nullness annotation to {0} type is meaningless";
        public AnnotationRedundanceAtValueTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration declaration, bool isVoid) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public bool IsVoid { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AnnotationRedundanceInHierarchy", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Base declaration has the same annotation")]
    public class AnnotationRedundanceInHierarchyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AnnotationRedundanceInHierarchy";
        protected const string MESSAGE = "Base declaration has the same annotation";
        public AnnotationRedundanceInHierarchyWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Anonymous method parameter cannot be optional")]
    public class AnonymousMethodParameterDefaultValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Anonymous method parameter cannot be optional";
        public AnonymousMethodParameterDefaultValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodParameterDeclaration declarationNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodParameterDeclaration DeclarationNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Anonymous method parameter cannot be \'params\'")]
    public class AnonymousMethodParameterParamsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Anonymous method parameter cannot be \'params\'";
        public AnonymousMethodParameterParamsError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodParameterDeclaration declarationNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodParameterDeclaration DeclarationNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Anonymous type projection initializer should be simple name or member access expr" +
        "ession")]
    public class AnonymousTypeProjectionInitializerNotMemberAccessError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Anonymous type projection initializer should be simple name or member access expr" +
            "ession";
        public AnonymousTypeProjectionInitializerNotMemberAccessError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static class cannot be used in anonymous type property")]
    public class AnonymousTypePropertyCannotBeStaticClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static class cannot be used in anonymous type property";
        public AnonymousTypePropertyCannotBeStaticClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement variable) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Variable { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot assign \'void\' to anonymous type property")]
    public class AnonymousTypePropertyCannotBeVoidError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot assign \'void\' to anonymous type property";
        public AnonymousTypePropertyCannotBeVoidError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement variable) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Variable { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Arithmetic problem in constant value computation")]
    public class ArithmeticProblemConstantValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Arithmetic problem in constant value computation";
        public ArithmeticProblemConstantValueError(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\': array elements cannot be of static type")]
    public class ArrayElementIsStaticClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\': array elements cannot be of static type";
        public ArrayElementIsStaticClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage usageNode, JetBrains.ReSharper.Psi.IType scalarType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ScalarType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage UsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Array element type cannot be \'{0}\'")]
    public class ArrayElementTypeIsForbiddenError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Array element type cannot be \'{0}\'";
        public ArrayElementTypeIsForbiddenError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage, JetBrains.ReSharper.Psi.IType elementType) { }
        public JetBrains.ReSharper.Psi.IType ElementType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Array initializer is expected")]
    public class ArrayInitializerExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Array initializer is expected";
        public ArrayInitializerExpectedError(JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Array initializer length doesn\'t match the given size")]
    public class ArrayInitializerSizeMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Array initializer length doesn\'t match the given size";
        public ArrayInitializerSizeMismatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type parameter \'{0}\' cannot be used with the \'as\' operator because it does no" +
        "t have a class type constraint nor a \'class\' constraint")]
    public class AsOperatorWithUnconstrainedTypeParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type parameter \'{0}\' cannot be used with the \'as\' operator because it does no" +
            "t have a class type constraint nor a \'class\' constraint";
        public AsOperatorWithUnconstrainedTypeParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The as operator must be used with a reference or nullable type (\'{0}\' is a non-nu" +
        "llable value type)")]
    public class AsOperatorWithValueTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The as operator must be used with a reference or nullable type (\'{0}\' is a non-nu" +
            "llable value type)";
        public AsOperatorWithValueTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IDeclaredType valueType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType ValueType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0665", "CSHARP", CompilerIds=new string[] {
            "CS0665"}, CompilerIdsWithDescription="CS0665:Assignment in conditional expression", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Assignment in conditional expression; did you mean to use == instead of = ?")]
    public class AssignmentInConditionalExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0665";
        protected const string MESSAGE = "Assignment in conditional expression; did you mean to use == instead of = ?";
        public AssignmentInConditionalExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAssignment", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Value assigned is not used in any execution path")]
    public class AssignmentNotUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAssignment";
        protected const string MESSAGE = "Value assigned is not used in any execution path";
        public AssignmentNotUsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1717", "CSHARP", AttributeId="ReSharper Dead Code", CompilerIds=new string[] {
            "CS1717"}, CompilerIdsWithDescription="CS1717:Assignment made to same variable", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Assignment made to same variable; did you mean to assign something else?")]
    public class AssignmentToSameVariableWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1717";
        protected const string MESSAGE = "Assignment made to same variable; did you mean to assign something else?";
        public AssignmentToSameVariableWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("AssignNullToNotNullAttribute", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible \'null\' assignment to entity marked with \'NotNull\' attribute")]
    public class AssignNullToNotNullAttributeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "AssignNullToNotNullAttribute";
        protected const string MESSAGE = "Possible \'null\' assignment to entity marked with \'NotNull\' attribute";
        public AssignNullToNotNullAttributeWarning(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot convert null to type parameter \'{0}\' because it could be a value type. Con" +
        "sider using \'default(T)\' instead.")]
    public class AssignNullToTypeParameterWithoutClassConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot convert null to type parameter \'{0}\' because it could be a value type. Con" +
            "sider using \'default(T)\' instead.";
        public AssignNullToTypeParameterWithoutClassConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot assign to \'{0}\' because it is a \'method group\'")]
    public class AssignToMethodGroupError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot assign to \'{0}\' because it is a \'method group\'";
        public AssignToMethodGroupError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot assign void to a range variable")]
    public class AssignVoidToRangeVariableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot assign void to a range variable";
        public AssignVoidToRangeVariableError(JetBrains.ReSharper.Psi.CSharp.Tree.IQueryParameterPlatform platform) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IQueryParameterPlatform Platform { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS4014", "CSHARP", CompilerIds=new string[] {
            "CS4014"}, CompilerIdsWithDescription="CS4014:Async method invocation without await expression", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Because this call is not awaited, execution of the current method continues befor" +
        "e the call is completed. Consider applying the \'await\' operator to the result of" +
        " the call.")]
    public class AsyncMethodInvocationWithoutAwaitWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS4014";
        protected const string MESSAGE = "Because this call is not awaited, execution of the current method continues befor" +
            "e the call is completed. Consider applying the \'await\' operator to the result of" +
            " the call.";
        public AsyncMethodInvocationWithoutAwaitWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocation) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression Invocation { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1998", "CSHARP", AttributeId="ReSharper Dead Code", CompilerIds=new string[] {
            "CS1998"}, CompilerIdsWithDescription="CS1998:Async function without await expression", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="This async method lacks \'await\' operators and will run synchronously. Consider us" +
        "ing the \'await\' operator to await non-blocking API calls, or \'await TaskEx.Run(." +
        "..)\' to do CPU-bound work on a background thread")]
    public class AsyncMethodWithoutAwait2Warning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1998";
        protected const string MESSAGE = "This async method lacks \'await\' operators and will run synchronously. Consider us" +
            "ing the \'await\' operator to await non-blocking API calls, or \'await TaskEx.Run(." +
            "..)\' to do CPU-bound work on a background thread";
        public AsyncMethodWithoutAwait2Warning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1998", "CSHARP", CompilerIds=new string[] {
            "CS1998"}, CompilerIdsWithDescription="CS1998:Async function without await expression", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="This async method lacks \'await\' operators and will run synchronously. Consider us" +
        "ing the \'await\' operator to await non-blocking API calls, or \'await TaskEx.Run(." +
        "..)\' to do CPU-bound work on a background thread")]
    public class AsyncMethodWithoutAwaitWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1998";
        protected const string MESSAGE = "This async method lacks \'await\' operators and will run synchronously. Consider us" +
            "ing the \'await\' operator to await non-blocking API calls, or \'await TaskEx.Run(." +
            "..)\' to do CPU-bound work on a background thread";
        public AsyncMethodWithoutAwaitWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The async modifier can only be used in methods that have a statement body")]
    public class AsyncMethodWithoutBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The async modifier can only be used in methods that have a statement body";
        public AsyncMethodWithoutBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The modifier \'async\' is not valid for this item")]
    public class AsyncModifierIsNotValidOnThisItemError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The modifier \'async\' is not valid for this item";
        public AsyncModifierIsNotValidOnThisItemError(JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList modifiersList, JetBrains.ReSharper.Psi.Tree.ITokenNode modifier) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Modifier { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList ModifiersList { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="At least one parameter should be \'{0}\'")]
    public class AtLeastOneParameterOfSignOperatorMustBeContainingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "At least one parameter should be \'{0}\'";
        public AtLeastOneParameterOfSignOperatorMustBeContainingTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement containingType) { }
        public JetBrains.ReSharper.Psi.ITypeElement ContainingType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Attribute argument cannot use type parameters")]
    public class AttributeArgumentCannotUseTypeParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Attribute argument cannot use type parameters";
        public AttributeArgumentCannotUseTypeParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="An attribute argument must be a constant expression, typeof expression or array c" +
        "reation expression of an attribute parameter type")]
    public class AttributeArgumentNotConstantError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "An attribute argument must be a constant expression, typeof expression or array c" +
            "reation expression of an attribute parameter type";
        public AttributeArgumentNotConstantError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A generic type cannot derive from \'System.Attribute\' because it is an attribute c" +
        "lass")]
    public class AttributeCannotHaveTypeParametersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A generic type cannot derive from \'System.Attribute\' because it is an attribute c" +
            "lass";
        public AttributeCannotHaveTypeParametersError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration typeDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration TypeDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' is not an attribute")]
    public class AttributeNameExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' is not an attribute";
        public AttributeNameExpectedError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'await\' operator can only be used in a method or lambda marked with the \'asyn" +
        "c\' modifier")]
    public class AwaitExpressionNotUnderAsyncMethodError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'await\' operator can only be used in a method or lambda marked with the \'asyn" +
            "c\' modifier";
        public AwaitExpressionNotUnderAsyncMethodError(JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression awaitExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression AwaitExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'await\' operator cannot occur inside a catch or finally block of a try-statem" +
        "ent, inside the block of a lock-statement, or in an unsafe context")]
    public class AwaitExpressionUnderInvalidConstructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'await\' operator cannot occur inside a catch or finally block of a try-statem" +
            "ent, inside the block of a lock-statement, or in an unsafe context";
        public AwaitExpressionUnderInvalidConstructError(JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression awaitExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression AwaitExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'await\' operator cannot currently be used in query expressions")]
    public class AwaitExpressionUnderLinqError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'await\' operator cannot currently be used in query expressions";
        public AwaitExpressionUnderLinqError(JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression awaitExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression AwaitExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString=" \'await\' cannot be used as an identifier within an async method or lambda express" +
        "ion")]
    public class AwaitIdentifierInAsyncMethodError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = " \'await\' cannot be used as an identifier within an async method or lambda express" +
            "ion";
        public AwaitIdentifierInAsyncMethodError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Bad compile constant value")]
    public class BadConstantValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Bad compile constant value";
        public BadConstantValueError(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1592", "CSHARP", CompilerIds=new string[] {
            "CS1592"}, CompilerIdsWithDescription="CS1592:Badly formed XML in included comments file", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Badly formed XML in included comments file")]
    public class BadlyFormedXMLInIncludedCommentsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1592";
        protected const string MESSAGE = "Badly formed XML in included comments file";
        public BadlyFormedXMLInIncludedCommentsWarning(JetBrains.ReSharper.Psi.Xml.Tree.IXmlTreeNode xmlTag) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.Xml.Tree.IXmlTreeNode XmlTag { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("BaseMemberHasParams", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Base {0} \'{1}\' last parameter has \'params\' modifier")]
    public class BaseMemberHasParamsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "BaseMemberHasParams";
        protected const string MESSAGE = "Base {0} \'{1}\' last parameter has \'params\' modifier";
        public BaseMemberHasParamsWarning(JetBrains.ReSharper.Psi.IOverridableMember baseMember, JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.IOverridableMember BaseMember { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("BaseMethodCallWithDefaultParameter", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Call to base member with implicit default parameters")]
    public class BaseMethodCallWithDefaultParameterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "BaseMethodCallWithDefaultParameter";
        protected const string MESSAGE = "Call to base member with implicit default parameters";
        public BaseMethodCallWithDefaultParameterWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("BaseObjectEqualsIsObjectEquals", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Call to \'base.Equals(...)\' is reference equality")]
    public class BaseObjectEqualsIsObjectEqualsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "BaseObjectEqualsIsObjectEquals";
        protected const string MESSAGE = "Call to \'base.Equals(...)\' is reference equality";
        public BaseObjectEqualsIsObjectEqualsWarning(JetBrains.ReSharper.Psi.Tree.IExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.IExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("BaseObjectGetHashCodeCallInGetHashCode", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Overriden GetHashCode calls base \'Object.GetHashCode()\'")]
    public class BaseObjectGetHashCodeCallInGetHashCodeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "BaseObjectGetHashCodeCallInGetHashCode";
        protected const string MESSAGE = "Overriden GetHashCode calls base \'Object.GetHashCode()\'";
        public BaseObjectGetHashCodeCallInGetHashCodeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression ReferenceExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("BitwiseOperatorOnEnumWithoutFlags", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Bitwise operation on enum which is not marked by [Flags] attribute")]
    public class BitwiseOperatorOnEnumWithoutFlagsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "BitwiseOperatorOnEnumWithoutFlags";
        protected const string MESSAGE = "Bitwise operation on enum which is not marked by [Flags] attribute";
        public BitwiseOperatorOnEnumWithoutFlagsWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorExpression expression, JetBrains.ReSharper.Psi.IEnum operandType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IEnum OperandType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify both a constraint class and the \'class\' or \'struct\' constraint")]
    public class BothRefValueAndClassConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify both a constraint class and the \'class\' or \'struct\' constraint";
        public BothRefValueAndClassConstraintError(JetBrains.ReSharper.Psi.Tree.ITreeNode constrintElement) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode ConstrintElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify both reference and value constraint")]
    public class BothValueAndReferenceTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify both reference and value constraint";
        public BothValueAndReferenceTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.INFO, "PerformanceHints", AttributeId="ReSharper Boxing Occurance", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.NONE, ShowToolTipInStatusBar=false)]
    public class BoxingOccuranceHighlighting : JetBrains.ReSharper.Daemon.IHighlighting
    {
        public const string HIGHLIGHTING_ID = "ReSharper Boxing Occurance";
        public BoxingOccuranceHighlighting([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.Tree.ITreeNode element, [JetBrains.Annotations.NotNullAttribute()] string description) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Break statement is missing")]
    public class BreakStatementMissing1Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Break statement is missing";
        public BreakStatementMissing1Error(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement switchLabel) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement SwitchLabel { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Break statement is missing")]
    public class BreakStatementMissing2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Break statement is missing";
        public BreakStatementMissing2Error(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement switchStatement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement SwitchStatement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CanBeReplacedWithTryCastAndCheckForNull", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Type check and direct cast can be replaced with try cast and check for null")]
    public class CanBeReplacedWithTryCastAndCheckForNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CanBeReplacedWithTryCastAndCheckForNull";
        protected const string MESSAGE = "Type check and direct cast can be replaced with try cast and check for null";
        public CanBeReplacedWithTryCastAndCheckForNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression isExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression IsExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot access explicit implementation of \'{0}.{1}\'")]
    public class CannotAccessExplicitImplementationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access explicit implementation of \'{0}.{1}\'";
        public CannotAccessExplicitImplementationError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IExplicitImplementation explicitImplementation) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IExplicitImplementation ExplicitImplementation { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Cannot apply operator \'{0}\' to operands of type \'{1}\' and \'{2}\'")]
    public class CannotApplyBinaryOperatorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot apply operator \'{0}\' to operands of type \'{1}\' and \'{2}\'";
        public CannotApplyBinaryOperatorError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType leftType, JetBrains.ReSharper.Psi.IExpressionType rightType, JetBrains.ReSharper.Psi.Tree.ITreeNode sign) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IExpressionType LeftType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType RightType { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Sign { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Cannot apply operator \'{0}\' to operands of type \'{1}\' and \'{2}\', {3}candidates ar" +
        "e: {4}")]
    public class CannotApplyBinaryOperatorMultipleCandidatesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot apply operator \'{0}\' to operands of type \'{1}\' and \'{2}\', {3}candidates ar" +
            "e: {4}";
        public CannotApplyBinaryOperatorMultipleCandidatesError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType leftType, JetBrains.ReSharper.Psi.IExpressionType rightType, JetBrains.ReSharper.Psi.Tree.ITreeNode sign, string candidates) { }
        public string Candidates { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IExpressionType LeftType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType RightType { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Sign { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CannotApplyEqualityOperatorToType", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Cannot apply equality operator to type marked by \'CannotApplyEqualityOperatorAttr" +
        "ibute\' attribute")]
    public class CannotApplyEqualityOperatorToTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CannotApplyEqualityOperatorToType";
        protected const string MESSAGE = "Cannot apply equality operator to type marked by \'CannotApplyEqualityOperatorAttr" +
            "ibute\' attribute";
        public CannotApplyEqualityOperatorToTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Cannot apply operator \'{0}\' to operand of type \'{1}\'")]
    public class CannotApplyUnaryOperatorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot apply operator \'{0}\' to operand of type \'{1}\'";
        public CannotApplyUnaryOperatorError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression unaryExpression, JetBrains.ReSharper.Psi.IExpressionType operandType, string sign) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType OperandType { get; }
        public string Sign { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression UnaryExpression { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Cannot apply operator \'{0}\' to operand of type \'{1}\', {2}candidates are: {3}")]
    public class CannotApplyUnaryOperatorMultipleCandidatesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot apply operator \'{0}\' to operand of type \'{1}\', {2}candidates are: {3}";
        public CannotApplyUnaryOperatorMultipleCandidatesError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression unaryExpression, JetBrains.ReSharper.Psi.IExpressionType operandType, string sign, string candidates) { }
        public string Candidates { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType OperandType { get; }
        public string Sign { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression UnaryExpression { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot change return type when overriding {0} \'{1}\'")]
    public class CannotChangeReturnTypeInOverrideError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot change return type when overriding {0} \'{1}\'";
        public CannotChangeReturnTypeInOverrideError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IOverridableMember overridenMember, JetBrains.ReSharper.Psi.IType returnType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember OverridenMember { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot construct \'void\' type")]
    public class CannotConstructVoidError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot construct \'void\' type";
        public CannotConstructVoidError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot create an instance of the abstract class \'{0}\'")]
    public class CannotCreateInstanceOfAbstractClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot create an instance of the abstract class \'{0}\'";
        public CannotCreateInstanceOfAbstractClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression, JetBrains.ReSharper.Psi.IClass typeElement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression ObjectCreationExpression { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IClass TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot create an instance of the interface \'{0}\'")]
    public class CannotCreateInstanceOfInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot create an instance of the interface \'{0}\'";
        public CannotCreateInstanceOfInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName ReferenceName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot provide arguments when creating an instance of a type parameter \'{0}\'")]
    public class CannotCreateInstanceOfTypeParameterWithArgumentsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot provide arguments when creating an instance of a type parameter \'{0}\'";
        public CannotCreateInstanceOfTypeParameterWithArgumentsError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression ObjectCreationExpression { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot create an instance of the type parameter \'{0}\' because it does not have th" +
        "e new() constraint")]
    public class CannotCreateInstanceOfTypeParameterWithoutNewConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot create an instance of the type parameter \'{0}\' because it does not have th" +
            "e new() constraint";
        public CannotCreateInstanceOfTypeParameterWithoutNewConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression ObjectCreationExpression { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The {0} \'{1}\' has no constructors defined")]
    public class CannotCreateInstanceOfTypeWithoutConstructorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The {0} \'{1}\' has no constructors defined";
        public CannotCreateInstanceOfTypeWithoutConstructorError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression, JetBrains.ReSharper.Psi.IDeclaredElement typeElement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression ObjectCreationExpression { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="There exist both implicit conversions from \'{0}\' and \'{1}\' and from \'{1}\' to \'{0}" +
        "\'")]
    public class CannotDetermineTernaryExpressionType2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "There exist both implicit conversions from \'{0}\' and \'{1}\' and from \'{1}\' to \'{0}" +
            "\'";
        public CannotDetermineTernaryExpressionType2Error(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression expression, JetBrains.ReSharper.Psi.IExpressionType thenType, JetBrains.ReSharper.Psi.IExpressionType elseType) { }
        public JetBrains.ReSharper.Psi.IExpressionType ElseType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ThenType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="There is no implicit conversion between \'{0}\' and \'{1}\'")]
    public class CannotDetermineTernaryExpressionTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "There is no implicit conversion between \'{0}\' and \'{1}\'";
        public CannotDetermineTernaryExpressionTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression expression, JetBrains.ReSharper.Psi.IExpressionType thenType, JetBrains.ReSharper.Psi.IExpressionType elseType) { }
        public JetBrains.ReSharper.Psi.IExpressionType ElseType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ThenType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Abstract event cannot have add or remove accessors")]
    public class CannotHaveEventAccessorsInAbstractEventError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Abstract event cannot have add or remove accessors";
        public CannotHaveEventAccessorsInAbstractEventError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Event in interface cannot have add or remove accessors")]
    public class CannotHaveEventAccessorsInInterfacesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Event in interface cannot have add or remove accessors";
        public CannotHaveEventAccessorsInInterfacesError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Event in interface cannot have initializer")]
    public class CannotHaveEventInitializersInInterfacesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Event in interface cannot have initializer";
        public CannotHaveEventInitializersInInterfacesError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot implement a dynamic interface \'{0}\'")]
    public class CannotImplementDynamicInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot implement a dynamic interface \'{0}\'";
        public CannotImplementDynamicInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.IDeclaredType superType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType SuperType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0469", "CSHARP", CompilerIds=new string[] {
            "CS0469"}, CompilerIdsWithDescription="CS0469:\'goto case\' value is not implicitly convertible to required type", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The \'goto case\' value is not implicitly convertible to type \'{0}\'")]
    public class CannotImplicitlyConvertGotoCaseValueToGoverningTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0469";
        protected const string MESSAGE = "The \'goto case\' value is not implicitly convertible to type \'{0}\'";
        public CannotImplicitlyConvertGotoCaseValueToGoverningTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IType governingType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IType GoverningType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class CannotImplicitlyConvertTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public CannotImplicitlyConvertTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType IExpressionType, JetBrains.ReSharper.Psi.IType targetType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IExpressionType IExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="No best type found for implicitly-typed array")]
    public class CannotInferImplicitlyTypedArrayTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "No best type found for implicitly-typed array";
        public CannotInferImplicitlyTypedArrayTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression arrayCreationExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression ArrayCreationExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot inherit from sealed {0} \'{1}\'")]
    public class CannotInheritFromSealedTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot inherit from sealed {0} \'{1}\'";
        public CannotInheritFromSealedTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot derive from special class {0}")]
    public class CannotInheritFromSpecialTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot derive from special class {0}";
        public CannotInheritFromSpecialTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot instantiate \'dynamic\' object")]
    public class CannotInstantiateDynamicTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot instantiate \'dynamic\' object";
        public CannotInstantiateDynamicTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\': cannot override because \'{1}\' does not have an overridable {2} accessor")]
    public class CannotOverrideUnexistingAccessorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\': cannot override because \'{1}\' does not have an overridable {2} accessor";
        public CannotOverrideUnexistingAccessorError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration extraAccessor, JetBrains.ReSharper.Psi.IOverridableMember overridenMember) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration ExtraAccessor { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember OverridenMember { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'new()\' constraint cannot be used with the \'struct\' constraint")]
    public class CannotSpecifyConstructorConstraintForValueTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'new()\' constraint cannot be used with the \'struct\' constraint";
        public CannotSpecifyConstructorConstraintForValueTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A new expression requires (), [], or {} after type")]
    public class CannotUseConstructorWithoutBracketsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A new expression requires (), [], or {} after type";
        public CannotUseConstructorWithoutBracketsError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression node, JetBrains.ReSharper.Psi.IDeclaredElement constructor) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Constructor { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify the DefaultMember attribute on type containing an indexer")]
    public class CannotUseDefaultMemberAttributeOnTypeWithIndexerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify the DefaultMember attribute on type containing an indexer";
        public CannotUseDefaultMemberAttributeOnTypeWithIndexerError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot create an array initializer when size is not constant")]
    public class CannotUseInitializerIfDimensionIsNonConstantError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot create an array initializer when size is not constant";
        public CannotUseInitializerIfDimensionIsNonConstantError(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Use of {0} \'{1}\' without ()")]
    public class CannotUseInvocableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Use of {0} \'{1}\' without ()";
        public CannotUseInvocableError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, bool useElementType) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public bool UseElementType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'{0}\' in member initializer")]
    public class CannotUseThisBaseInInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'{0}\' in member initializer";
        public CannotUseThisBaseInInitializerError(JetBrains.ReSharper.Psi.Tree.ITreeNode expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'{0}\' in static member")]
    public class CannotUseThisBaseInStaticContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'{0}\' in static member";
        public CannotUseThisBaseInStaticContextError(JetBrains.ReSharper.Psi.Tree.ITreeNode expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Anonymous methods inside structs cannot access instance members of \'this\'. Consid" +
        "er copying \'this\' to a local variable outside the anonymous method and using the" +
        " local instead.")]
    public class CannotUseThisInAnonymousMethodInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Anonymous methods inside structs cannot access instance members of \'this\'. Consid" +
            "er copying \'this\' to a local variable outside the anonymous method and using the" +
            " local instead.";
        public CannotUseThisInAnonymousMethodInStructError(JetBrains.ReSharper.Psi.Tree.IExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.IExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="The {0} \'{1}\' cannot be used with type arguments")]
    public class CannotUseTypeArgumentWithElementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The {0} \'{1}\' cannot be used with type arguments";
        public CannotUseTypeArgumentWithElementError(JetBrains.ReSharper.Psi.IDeclaredElement element, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList TypeArgumentList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.INFO, "PerformanceHints", AttributeId="ReSharper Captured Identifier", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.NONE, ShowToolTipInStatusBar=false)]
    public class CapturedIdentifierHighlighting : JetBrains.ReSharper.Daemon.IHighlighting
    {
        public const string HIGHLIGHTING_ID = "ReSharper Captured Identifier";
        public CapturedIdentifierHighlighting([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Case label is missing")]
    public class CaseLabelIsMissingError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Case label is missing";
        public CaseLabelIsMissingError(JetBrains.ReSharper.Psi.CSharp.Tree.IBlock switchBlock) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBlock SwitchBlock { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A constant value is expected")]
    public class CaseLabelNotConstantError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A constant value is expected";
        public CaseLabelNotConstantError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Case label can be used in switch statement only")]
    public class CaseLabelOutsideSwitchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Case label can be used in switch statement only";
        public CaseLabelOutsideSwitchError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Catch type should extend \'System.Exception\'")]
    public class CatchDoesNotExtendExceptionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Catch type should extend \'System.Exception\'";
        public CatchDoesNotExtendExceptionError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage usageNode) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage UsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Circular constraint dependency involving \'{0}\' and \'{1}\'")]
    public class CircularDependencyInTypeParameterConstrantError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Circular constraint dependency involving \'{0}\' and \'{1}\'";
        public CircularDependencyInTypeParameterConstrantError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.ITypeParameter origin, JetBrains.ReSharper.Psi.ITypeParameter parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter Origin { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter Parameter { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Circular {0} dependency involving \'{1}\' and \'{2}\'")]
    public class CircularTypeDependencyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Circular {0} dependency involving \'{1}\' and \'{2}\'";
        public CircularTypeDependencyError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement superClass) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeElement SuperClass { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ClassCannotBeInstantiated", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Class cannot be instantiated")]
    public class ClassCannotBeInstantiatedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ClassCannotBeInstantiated";
        protected const string MESSAGE = "Class cannot be instantiated";
        public ClassCannotBeInstantiatedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Class \'{0}\' cannot be both abstract and sealed")]
    public class ClassIsAbstractAndSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Class \'{0}\' cannot be both abstract and sealed";
        public ClassIsAbstractAndSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration classDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration ClassDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'class\' or \'struct\' constraint must come before any other constraints")]
    public class ClassOrStructConstraintMustBeFirstError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'class\' or \'struct\' constraint must come before any other constraints";
        public ClassOrStructConstraintMustBeFirstError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="The class type constraint \'{0}\' must come before any other constraints")]
    public class ClassTypeConstraintMustBeFirstError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The class type constraint \'{0}\' must come before any other constraints";
        public ClassTypeConstraintMustBeFirstError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' has the class-type constraint so \'{1}\' cannot be used as a c" +
        "onstraint for \'{2}\'")]
    public class ClassTypeParameterInValueTypeParameterConstrantListError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' has the class-type constraint so \'{1}\' cannot be used as a c" +
            "onstraint for \'{2}\'";
        public ClassTypeParameterInValueTypeParameterConstrantListError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.ITypeParameter origin, JetBrains.ReSharper.Psi.ITypeParameter parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter Origin { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter Parameter { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot initialize type \'{0}\' with a collection initializer because it does not im" +
        "plement \'System.Collections.IEnumerable\'")]
    public class CollectionInitializerAppliedToNonCollectionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot initialize type \'{0}\' with a collection initializer because it does not im" +
            "plement \'System.Collections.IEnumerable\'";
        public CollectionInitializerAppliedToNonCollectionError(JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionInitializer initializer, JetBrains.ReSharper.Psi.IType createdType) { }
        public JetBrains.ReSharper.Psi.IType CreatedType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Collection initializer element cannot be assignment expression")]
    public class CollectionInitializerElementIsAssignmentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Collection initializer element cannot be assignment expression";
        public CollectionInitializerElementIsAssignmentError(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Collection initializer element cannot be empty")]
    public class CollectionInitializerElementIsEmptyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Collection initializer element cannot be empty";
        public CollectionInitializerElementIsEmptyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionElementInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionElementInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CompareNonConstrainedGenericWithNull", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible compare of value type with \'null\'")]
    public class CompareNonConstrainedGenericWithNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CompareNonConstrainedGenericWithNull";
        protected const string MESSAGE = "Possible compare of value type with \'null\'";
        public CompareNonConstrainedGenericWithNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression expression, string side, JetBrains.ReSharper.Psi.IType valueType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string Side { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType ValueType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CompareOfFloatsByEqualityOperator", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Comparison of floating point numbers with equality operator. {0}")]
    public class CompareOfFloatsByEqualityOperatorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CompareOfFloatsByEqualityOperator";
        protected const string MESSAGE = "Comparison of floating point numbers with equality operator. {0}";
        public CompareOfFloatsByEqualityOperatorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression expression, JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.CompareOfFloatsByEqualityOperatorAnalyzer.IssueType issueType, JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.CompareOfFloatsByEqualityOperatorAnalyzer.SuspiciousConstant constant) { }
        public JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.CompareOfFloatsByEqualityOperatorAnalyzer.SuspiciousConstant Constant { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression Expression { get; }
        public JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.CompareOfFloatsByEqualityOperatorAnalyzer.IssueType IssueType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="In order to be applicable as a short circuit operator a user-defined logical oper" +
        "ator (\'{0}\') must have the same return type as the type of its 2 parameters")]
    public class ConditionalLogicOperatorTypesMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "In order to be applicable as a short circuit operator a user-defined logical oper" +
            "ator (\'{0}\') must have the same return type as the type of its 2 parameters";
        public ConditionalLogicOperatorTypesMismatchError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.ISignOperator signOperator, JetBrains.ReSharper.Psi.Resolve.ISubstitution substitution) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public JetBrains.ReSharper.Psi.ISignOperator SignOperator { get; }
        public JetBrains.ReSharper.Psi.Resolve.ISubstitution Substitution { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The operator \'{0}\' requires a matching operator \'true\'/\'false\' to also be defined" +
        "")]
    public class ConditionalLogicTrueFalseOperatorMissingError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The operator \'{0}\' requires a matching operator \'true\'/\'false\' to also be defined" +
            "";
        public ConditionalLogicTrueFalseOperatorMissingError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.ISignOperator signOperator, JetBrains.ReSharper.Psi.Resolve.ISubstitution substitution) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public JetBrains.ReSharper.Psi.ISignOperator SignOperator { get; }
        public JetBrains.ReSharper.Psi.Resolve.ISubstitution Substitution { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConditionalTernaryEqualBranch", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'?:\' expression has identical true and false branches")]
    public class ConditionalTernaryEqualBranchWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConditionalTernaryEqualBranch";
        protected const string MESSAGE = "\'?:\' expression has identical true and false branches";
        public ConditionalTernaryEqualBranchWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConditionIsAlwaysTrueOrFalse", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, OverloadResolvePriority=10, ToolTipFormatString="Expression is always {0}")]
    public class ConditionIsAlwaysTrueOrFalseWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConditionIsAlwaysTrueOrFalse";
        protected const string MESSAGE = "Expression is always {0}";
        public ConditionIsAlwaysTrueOrFalseWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.ControlFlow.CSharp.ConstantExpressionValue expressionConstantValue) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.ControlFlow.CSharp.ConstantExpressionValue ExpressionConstantValue { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' inherits conflicting constraints \'class\' and \'{1}\'")]
    public class ConflictInheritedClassTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' inherits conflicting constraints \'class\' and \'{1}\'";
        public ConflictInheritedClassTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration, JetBrains.ReSharper.Psi.ITypeParameter typeParameter, JetBrains.ReSharper.Psi.IType conflictingType) { }
        public JetBrains.ReSharper.Psi.IType ConflictingType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' inherits conflicting constraints \'{1}\' and \'{2}\'")]
    public class ConflictInheritedTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' inherits conflicting constraints \'{1}\' and \'{2}\'";
        public ConflictInheritedTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration, JetBrains.ReSharper.Psi.ITypeParameter typeParameter, JetBrains.ReSharper.Psi.IType type1, JetBrains.ReSharper.Psi.IType type2) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType Type1 { get; }
        public JetBrains.ReSharper.Psi.IType Type2 { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' inherits conflicting constraints \'value\' and \'{1}\'")]
    public class ConflictInheritedValueTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' inherits conflicting constraints \'value\' and \'{1}\'";
        public ConflictInheritedValueTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration, JetBrains.ReSharper.Psi.ITypeParameter typeParameter, JetBrains.ReSharper.Psi.IType conflictingType) { }
        public JetBrains.ReSharper.Psi.IType ConflictingType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' inherits conflicting constraints \'{1}\' and \'{2}\'")]
    public class ConflictSuperClassesInTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' inherits conflicting constraints \'{1}\' and \'{2}\'";
        public ConflictSuperClassesInTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterReference referenceNode, JetBrains.ReSharper.Psi.ITypeParameter typeParameter, JetBrains.ReSharper.Psi.IDeclaredType declaredType1, JetBrains.ReSharper.Psi.IDeclaredType declaredType2) { }
        public JetBrains.ReSharper.Psi.IDeclaredType DeclaredType1 { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType DeclaredType2 { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterReference ReferenceNode { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Constant cannot be used as an assignment target")]
    public class ConstantAssignmentTargetError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constant cannot be used as an assignment target";
        public ConstantAssignmentTargetError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destination, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Destination { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Constant initializer must be compile-time constant")]
    public class ConstantInitializerIsNotConstantError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constant initializer must be compile-time constant";
        public ConstantInitializerIsNotConstantError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Constant initializer is missing")]
    public class ConstantInitializerMissedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constant initializer is missing";
        public ConstantInitializerMissedError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter is not allowed for constant type")]
    public class ConstantIsTypeParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter is not allowed for constant type";
        public ConstantIsTypeParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The constant \'{0}\' cannot be marked static")]
    public class ConstantMarkedAsStaticError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The constant \'{0}\' cannot be marked static";
        public ConstantMarkedAsStaticError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration declaration, JetBrains.ReSharper.Psi.Tree.ITokenNode tokenNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode TokenNode { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Constraint cannot be a dynamic type \'{0}\'")]
    public class ConstraintCannotBeDynamicTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constraint cannot be a dynamic type \'{0}\'";
        public ConstraintCannotBeDynamicTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage, JetBrains.ReSharper.Psi.IDeclaredType superType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType SuperType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The new() constraint must be the last constraint specified")]
    public class ConstructorConstraintShouldBeLastError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The new() constraint must be the last constraint specified";
        public ConstructorConstraintShouldBeLastError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Interface cannot contain constructor")]
    public class ConstructorInInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Interface cannot contain constructor";
        public ConstructorInInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cyclic constructor call")]
    public class ConstructorInitializerLoopError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cyclic constructor call";
        public ConstructorInitializerLoopError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer constructorInitializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer ConstructorInitializer { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConstructorInitializerLoop", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible cyclic constructor call")]
    public class ConstructorInitializerLoopWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConstructorInitializerLoop";
        protected const string MESSAGE = "Possible cyclic constructor call";
        public ConstructorInitializerLoopWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer constructorInitializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer ConstructorInitializer { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Base class \'{0}\' doesn\'t contain parameterless constructor")]
    public class ConstructorInitializerMissingError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Base class \'{0}\' doesn\'t contain parameterless constructor";
        public ConstructorInitializerMissingError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration, JetBrains.ReSharper.Psi.IClass baseClass) { }
        public JetBrains.ReSharper.Psi.IClass BaseClass { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Constructor must have body")]
    public class ConstructorMustHaveBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constructor must have body";
        public ConstructorMustHaveBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method must have a return type")]
    public class ConstructorNameNotMatchingClassNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method must have a return type";
        public ConstructorNameNotMatchingClassNameError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ContractAnnotationNotParsed", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class ContractAnnotationNotParsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ContractAnnotationNotParsed";
        protected const string MESSAGE = "{0}";
        public ContractAnnotationNotParsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, string errorInfo) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorInfo { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conversion from base class")]
    public class ConversionFromBaseClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conversion from base class";
        public ConversionFromBaseClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conversion from derived class")]
    public class ConversionFromDerivedClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conversion from derived class";
        public ConversionFromDerivedClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="User-defined conversion from interface")]
    public class ConversionFromInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "User-defined conversion from interface";
        public ConversionFromInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="User-defined conversion from System.Object")]
    public class ConversionFromObjectError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "User-defined conversion from System.Object";
        public ConversionFromObjectError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conversion operator must have exactly 1 parameter")]
    public class ConversionMustHave1ParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conversion operator must have exactly 1 parameter";
        public ConversionMustHave1ParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conversion to base class")]
    public class ConversionToBaseClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conversion to base class";
        public ConversionToBaseClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conversion to derived class")]
    public class ConversionToDerivedClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conversion to derived class";
        public ConversionToDerivedClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="User-defined conversion to interface")]
    public class ConversionToInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "User-defined conversion to interface";
        public ConversionToInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="User-defined conversion to System.Object")]
    public class ConversionToObjectError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "User-defined conversion to System.Object";
        public ConversionToObjectError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conversion operator with same parameter and return types")]
    public class ConversionToSameTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conversion operator with same parameter and return types";
        public ConversionToSameTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertClosureToMethodGroup", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to method group")]
    public class ConvertClosureToMethodGroupWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertClosureToMethodGroup";
        protected const string MESSAGE = "Convert to method group";
        public ConvertClosureToMethodGroupWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression closureExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression methodGroupExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ClosureExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression MethodGroupExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertConditionalTernaryToNullCoalescing", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'?:\' expression can be re-written as \'??\' expression")]
    public class ConvertConditionalTernaryToNullCoalescingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertConditionalTernaryToNullCoalescing";
        protected const string MESSAGE = "\'?:\' expression can be re-written as \'??\' expression";
        public ConvertConditionalTernaryToNullCoalescingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfDoToWhile", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'while\' loop")]
    public class ConvertIfDoToWhileWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfDoToWhile";
        protected const string MESSAGE = "Convert to \'while\' loop";
        public ConvertIfDoToWhileWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToConditionalTernaryExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'?:\' expression")]
    public class ConvertIfStatementToConditionalTernaryExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToConditionalTernaryExpression";
        protected const string MESSAGE = "Convert to \'?:\' expression";
        public ConvertIfStatementToConditionalTernaryExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression DestExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToConditionalTernaryExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to method call with \'?:\' expression inside")]
    public class ConvertIfStatementToMethodCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToConditionalTernaryExpression";
        protected const string MESSAGE = "Convert to method call with \'?:\' expression inside";
        public ConvertIfStatementToMethodCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destExpression, int parameterIndex, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression DestExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterIndex { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToConditionalTernaryExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to method call with \'?:\' expression inside")]
    public class ConvertIfStatementToMethodCallWithAssignmentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToConditionalTernaryExpression";
        protected const string MESSAGE = "Convert to method call with \'?:\' expression inside";
        public ConvertIfStatementToMethodCallWithAssignmentWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression lValueExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destExpression, int parameterIndex, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression DestExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LValueExpression { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterIndex { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToNullCoalescingExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'??\' expression")]
    public class ConvertIfStatementToNullCoalescingExpression1Warning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToNullCoalescingExpression";
        protected const string MESSAGE = "Convert to \'??\' expression";
        public ConvertIfStatementToNullCoalescingExpression1Warning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression leftOperand, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rightOperand) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LeftOperand { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RightOperand { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToNullCoalescingExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'??\' expression")]
    public class ConvertIfStatementToNullCoalescingExpression2Warning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToNullCoalescingExpression";
        protected const string MESSAGE = "Convert to \'??\' expression";
        public ConvertIfStatementToNullCoalescingExpression2Warning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destination, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression leftOperand, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rightOperand) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Destination { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LeftOperand { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RightOperand { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToNullCoalescingExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'??\' expression")]
    public class ConvertIfStatementToNullCoalescingExpression3Warning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToNullCoalescingExpression";
        protected const string MESSAGE = "Convert to \'??\' expression";
        public ConvertIfStatementToNullCoalescingExpression3Warning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression leftOperand, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rightOperand) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LeftOperand { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RightOperand { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToNullCoalescingExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to method call with \'??\' expression inside")]
    public class ConvertIfStatementToNullCoalescingInMethodCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToNullCoalescingExpression";
        protected const string MESSAGE = "Convert to method call with \'??\' expression inside";
        public ConvertIfStatementToNullCoalescingInMethodCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destExpression, int parameterIndex, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression DestExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterIndex { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToNullCoalescingExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to method call with \'??\' expression inside")]
    public class ConvertIfStatementToNullCoalescingInMethodCallWithAssignmentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToNullCoalescingExpression";
        protected const string MESSAGE = "Convert to method call with \'??\' expression inside";
        public ConvertIfStatementToNullCoalescingInMethodCallWithAssignmentWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression lValueExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destExpression, int parameterIndex, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression DestExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LValueExpression { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterIndex { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToReturnStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'return\' statement")]
    public class ConvertIfStatementToReturnConditionalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToReturnStatement";
        protected const string MESSAGE = "Convert to \'return\' statement";
        public ConvertIfStatementToReturnConditionalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] replacedStatements, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] ReplacedStatements { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToReturnStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'return\' statement")]
    public class ConvertIfStatementToReturnMethodCallWithConditionalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToReturnStatement";
        protected const string MESSAGE = "Convert to \'return\' statement";
        public ConvertIfStatementToReturnMethodCallWithConditionalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] replacedStatements, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, int parameterIndex, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression thenExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression elseExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ElseExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterIndex { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] ReplacedStatements { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ThenExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToReturnStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'return\' statement")]
    public class ConvertIfStatementToReturnMethodCallWithNullCoalescingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToReturnStatement";
        protected const string MESSAGE = "Convert to \'return\' statement";
        public ConvertIfStatementToReturnMethodCallWithNullCoalescingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] replacedStatements, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, int parameterIndex, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression leftOperand, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rightOperand) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LeftOperand { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterIndex { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] ReplacedStatements { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RightOperand { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToReturnStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'return\' statement")]
    public class ConvertIfStatementToReturnNullCoalescingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToReturnStatement";
        protected const string MESSAGE = "Convert to \'return\' statement";
        public ConvertIfStatementToReturnNullCoalescingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] replacedStatements, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression leftOperand, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rightOperand) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LeftOperand { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement[] ReplacedStatements { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RightOperand { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfStatementToSwitchStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert \'if\' statement to \'switch\' statement")]
    public class ConvertIfStatementToSwitchStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfStatementToSwitchStatement";
        protected const string MESSAGE = "Convert \'if\' statement to \'switch\' statement";
        public ConvertIfStatementToSwitchStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertIfToOrExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'||\' expression")]
    public class ConvertIfToOrExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertIfToOrExpression";
        protected const string MESSAGE = "Convert to \'||\' expression";
        public ConvertIfToOrExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expr1, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expr2) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expr1 { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expr2 { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertNullableToShortForm", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Rewrite as \'{0}\'")]
    public class ConvertNullableToShortFormWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertNullableToShortForm";
        protected const string MESSAGE = "Rewrite as \'{0}\'";
        public ConvertNullableToShortFormWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName, JetBrains.ReSharper.Psi.IDeclaredType nullableType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType NullableType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName ReferenceName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertToAutoProperty", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to auto-property")]
    public class ConvertToAutoPropertyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertToAutoProperty";
        protected const string MESSAGE = "Convert to auto-property";
        public ConvertToAutoPropertyWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration propertyDeclaration, JetBrains.ReSharper.Psi.IField backingField) { }
        public JetBrains.ReSharper.Psi.IField BackingField { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration PropertyDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertToAutoPropertyWithPrivateSetter", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to auto-property")]
    public class ConvertToAutoPropertyWithPrivateSetterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertToAutoPropertyWithPrivateSetter";
        protected const string MESSAGE = "Convert to auto-property";
        public ConvertToAutoPropertyWithPrivateSetterWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration propertyDeclaration, JetBrains.ReSharper.Psi.IField backingField) { }
        public JetBrains.ReSharper.Psi.IField BackingField { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration PropertyDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertToLambdaExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use lambda expression")]
    public class ConvertToLambdaExpression2Warning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertToLambdaExpression";
        protected const string MESSAGE = "Use lambda expression";
        public ConvertToLambdaExpression2Warning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression closureExpression, JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement statement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression ClosureExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertToLambdaExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use lambda expression")]
    public class ConvertToLambdaExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertToLambdaExpression";
        protected const string MESSAGE = "Use lambda expression";
        public ConvertToLambdaExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConvertToStaticClass", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert to \'static\' class")]
    public class ConvertToStaticClassWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConvertToStaticClass";
        protected const string MESSAGE = "Convert to \'static\' class";
        public ConvertToStaticClassWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CoVariantArrayConversion", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Co-variant array conversion from {0} to {1} can cause run-time exception on write" +
        " operation")]
    public class CoVariantArrayConversionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CoVariantArrayConversion";
        protected const string MESSAGE = "Co-variant array conversion from {0} to {1} can cause run-time exception on write" +
            " operation";
        public CoVariantArrayConversionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IType expressionType, JetBrains.ReSharper.Psi.IType targetType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IType ExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1723", "CSHARP", CompilerIds=new string[] {
            "CS1723"}, CompilerIdsWithDescription="CS1723:XML comment has cref attribute that refers to a type parameter", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="XML comment has cref attribute that refers to a type parameter")]
    public class CrefToTypeParameterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1723";
        protected const string MESSAGE = "XML comment has cref attribute that refers to a type parameter";
        public CrefToTypeParameterWarning(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="C# 3.0 language feature")]
    public class CSharp30LanguageFeatureError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "C# 3.0 language feature";
        public CSharp30LanguageFeatureError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="C# 4.0 language feature")]
    public class CSharp40LanguageFeatureError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "C# 4.0 language feature";
        public CSharp40LanguageFeatureError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="C# 5.0 language feature")]
    public class CSharp50LanguageFeatureError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "C# 5.0 language feature";
        public CSharp50LanguageFeatureError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    public abstract class CSharpHighlightingBase : JetBrains.ReSharper.Daemon.IHighlighting
    {
        public abstract bool IsValid();
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cycle in constant value computation")]
    public class CycleConstantValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cycle in constant value computation";
        public CycleConstantValueError(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' of type \'{2}\' causes a cycle in the struct layout")]
    public class CycleInStructLayoutError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' of type \'{2}\' causes a cycle in the struct layout";
        public CycleInStructLayoutError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassMemberDeclaration declaration, JetBrains.ReSharper.Psi.IType type) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType Type { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be partial")]
    public class DeclarationCannotBePartialError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be partial";
        public DeclarationCannotBePartialError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify default parameter value in conjunction with DefaultParameterValueA" +
        "ttribute or OptionalAttribute")]
    public class DefaultParameterValueIncompatibleWithOptionalAttributeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify default parameter value in conjunction with DefaultParameterValueA" +
            "ttribute or OptionalAttribute";
        public DefaultParameterValueIncompatibleWithOptionalAttributeError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("DefaultValueAttributeForOptionalParameter", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possibly misleading \'DefaultValueAttribute\' usage to define optional parameter va" +
        "lue. \'DefaultParameterValueAttribute\' should be used instead")]
    public class DefaultValueAttributeForOptionalParameterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "DefaultValueAttributeForOptionalParameter";
        protected const string MESSAGE = "Possibly misleading \'DefaultValueAttribute\' usage to define optional parameter va" +
            "lue. \'DefaultParameterValueAttribute\' should be used instead";
        public DefaultValueAttributeForOptionalParameterWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Delegate constructor is invoked with {0} argument(s)")]
    public class DelegateConstructorIncorrectArgumentNumberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Delegate constructor is invoked with {0} argument(s)";
        public DelegateConstructorIncorrectArgumentNumberError(JetBrains.ReSharper.Psi.Resolve.IReference reference, int argumentNumber) { }
        public int ArgumentNumber { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("DelegateSubtraction", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Delegate subtraction has unpredictable result")]
    public class DelegateSubtractionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "DelegateSubtraction";
        protected const string MESSAGE = "Delegate subtraction has unpredictable result";
        public DelegateSubtractionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Destructor must have body")]
    public class DestructorMustHaveBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Destructor must have body";
        public DestructorMustHaveBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration destructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration DestructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Only class types can contain destructors")]
    public class DestructorOfNotClassTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Only class types can contain destructors";
        public DestructorOfNotClassTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Base class of \'{0}\' differs from declared in other parts")]
    public class DifferentPartBaseClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Base class of \'{0}\' differs from declared in other parts";
        public DifferentPartBaseClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage baseClassUsage) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage BaseClassUsage { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parts of partial {0} \'{1}\' have different accessibility")]
    public class DifferentPartsAccessibilityError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parts of partial {0} \'{1}\' have different accessibility";
        public DifferentPartsAccessibilityError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter name differs from declared in other parts")]
    public class DifferentPartTypeParameterNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter name differs from declared in other parts";
        public DifferentPartTypeParameterNameError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter variance differs from declared in other parts")]
    public class DifferentPartTypeParameterVarianceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter variance differs from declared in other parts";
        public DifferentPartTypeParameterVarianceError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1587", "CSHARP", CompilerIds=new string[] {
            "CS1587"}, CompilerIdsWithDescription="CS1587:XML comment is not placed on a valid language element", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="XML comment is not placed on a valid language element")]
    public class DocCommentPlacedOnInvalidElementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1587";
        protected const string MESSAGE = "XML comment is not placed on a valid language element";
        public DocCommentPlacedOnInvalidElementWarning(JetBrains.ReSharper.Psi.Tree.ITreeNode start, JetBrains.ReSharper.Psi.Tree.ITreeNode end) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode End { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Start { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1570", "CSHARP", CompilerIds=new string[] {
            "CS1570"}, CompilerIdsWithDescription="CS1570:Invalid XML in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class DocCommentXmlSyntaxWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IDelegatingHighlighting, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1570";
        protected const string MESSAGE = "{0}";
        public DocCommentXmlSyntaxWarning(JetBrains.ReSharper.Daemon.IHighlighting baseHighlighting, JetBrains.DocumentModel.DocumentRange documentRange) { }
        public JetBrains.ReSharper.Daemon.IHighlighting BaseHighlighting { get; }
        public JetBrains.ReSharper.Daemon.IHighlighting DelegatesTo { get; }
        public JetBrains.DocumentModel.DocumentRange DocumentRange { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("DoNotCallOverridableMethodsInConstructor", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Virtual member call in constructor")]
    public class DoNotCallOverridableMethodsInConstructorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "DoNotCallOverridableMethodsInConstructor";
        protected const string MESSAGE = "Virtual member call in constructor";
        public DoNotCallOverridableMethodsInConstructorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IOverridableMember member) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("DoubleNegationOperator", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Double negation is meaningless")]
    public class DoubleNegationOperatorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "DoubleNegationOperator";
        protected const string MESSAGE = "Double negation is meaningless";
        public DoubleNegationOperatorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression expression, JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression operandExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression OperandExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate anonymous type property name \'{0}\'")]
    public class DuplicateAnonymousTypePropertyNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate anonymous type property name \'{0}\'";
        public DuplicateAnonymousTypePropertyNameError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate \'{0}\' attribute")]
    public class DuplicateAttributeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate \'{0}\' attribute";
        public DuplicateAttributeError(JetBrains.ReSharper.Psi.IClass attributeClass, JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public JetBrains.ReSharper.Psi.IClass AttributeClass { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate case label value {0}")]
    public class DuplicateCaseLabelError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate case label value {0}";
        public DuplicateCaseLabelError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label, JetBrains.ReSharper.Psi.ConstantValue value) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ConstantValue Value { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Warning", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate case label value {0}")]
    public class DuplicateCaseLabelWarningError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate case label value {0}";
        public DuplicateCaseLabelWarningError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label, JetBrains.ReSharper.Psi.ConstantValue value) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ConstantValue Value { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate constructor constraint")]
    public class DuplicateContructorTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate constructor constraint";
        public DuplicateContructorTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate default case label")]
    public class DuplicateDefaultCaseLabelError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate default case label";
        public DuplicateDefaultCaseLabelError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Warning", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate default case label")]
    public class DuplicateDefaultCaseLabelWarningError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate default case label";
        public DuplicateDefaultCaseLabelWarningError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate definition \'{0}\'")]
    public class DuplicateGlobalNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate definition \'{0}\'";
        public DuplicateGlobalNameError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement[] duplicates) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement[] Duplicates { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate initialization of member \'{0}\'")]
    public class DuplicateInitializationOfMemberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate initialization of member \'{0}\'";
        public DuplicateInitializationOfMemberError(JetBrains.ReSharper.Psi.CSharp.Tree.IMemberInitializer initializer, string memberName) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMemberInitializer Initializer { get; }
        public string MemberName { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' is already listed in interface list")]
    public class DuplicateInterfaceInExtendsListError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' is already listed in interface list";
        public DuplicateInterfaceInExtendsListError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IDeclaredType declaredType) { }
        public JetBrains.ReSharper.Psi.IDeclaredType DeclaredType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A {0} named \'{1}\' cannot be declared in this scope because it would give a differ" +
        "ent meaning to \'{1}\', which is already used in a parent or current scope to deno" +
        "te something else")]
    public class DuplicateLocalVariableNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A {0} named \'{1}\' cannot be declared in this scope because it would give a differ" +
            "ent meaning to \'{1}\', which is already used in a parent or current scope to deno" +
            "te something else";
        public DuplicateLocalVariableNameError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement variable, JetBrains.ReSharper.Psi.IDeclaredElement previousVariable) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement PreviousVariable { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Variable { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Warning", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Conflicting variable \'{0}\' is defined below")]
    public class DuplicateLocalVariableNameWarningError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Conflicting variable \'{0}\' is defined below";
        public DuplicateLocalVariableNameWarningError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement variable, JetBrains.ReSharper.Psi.IDeclaredElement nextVariable) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement NextVariable { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Variable { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate \'{0}\' modifier")]
    public class DuplicateModifiersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate \'{0}\' modifier";
        public DuplicateModifiersError(JetBrains.ReSharper.Psi.Tree.ITreeNode modifier1, JetBrains.ReSharper.Psi.Tree.ITreeNode modifier2) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Modifier1 { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Modifier2 { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate parameter \'{0}\'")]
    public class DuplicateParameterNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate parameter \'{0}\'";
        public DuplicateParameterNameError(JetBrains.ReSharper.Psi.Tree.IParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1571", "CSHARP", CompilerIds=new string[] {
            "CS1571"}, CompilerIdsWithDescription="CS1571:Duplicate param tag in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="XML comment on \'{0}\' has a duplicate param tag for \'{1}\'")]
    public class DuplicateParameterXmlDocWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1571";
        protected const string MESSAGE = "XML comment on \'{0}\' has a duplicate param tag for \'{1}\'";
        public DuplicateParameterXmlDocWarning(JetBrains.ReSharper.Psi.IParametersOwner owner, JetBrains.ReSharper.Psi.Xml.Tree.IXmlAttribute nameAttribute) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Xml.Tree.IXmlAttribute NameAttribute { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IParametersOwner Owner { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate reference constraint")]
    public class DuplicateReferenceTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate reference constraint";
        public DuplicateReferenceTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate definition \'{0}\'. Possibly missing keyword \'partial\'")]
    public class DuplicateSameTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate definition \'{0}\'. Possibly missing keyword \'partial\'";
        public DuplicateSameTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate type parameter constraint")]
    public class DuplicateTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate type parameter constraint";
        public DuplicateTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterReference node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterReference Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate type parameter name")]
    public class DuplicateTypeParameterNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate type parameter name";
        public DuplicateTypeParameterNameError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration typeParameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration TypeParameterDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1710", "CSHARP", CompilerIds=new string[] {
            "CS1710"}, CompilerIdsWithDescription="CS1710:Duplicate typeparam tag in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="XML comment on \'{0}\' has a duplicate typeparam tag for \'{1}\'")]
    public class DuplicateTypeParameterXmlDocWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1710";
        protected const string MESSAGE = "XML comment on \'{0}\' has a duplicate typeparam tag for \'{1}\'";
        public DuplicateTypeParameterXmlDocWarning(JetBrains.ReSharper.Psi.ITypeParametersOwner owner, JetBrains.ReSharper.Psi.Xml.Tree.IXmlAttribute nameAttribute) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Xml.Tree.IXmlAttribute NameAttribute { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeParametersOwner Owner { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The using alias \'{0}\' appeared previously in this namespace")]
    public class DuplicateUsingAliasError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The using alias \'{0}\' appeared previously in this namespace";
        public DuplicateUsingAliasError(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective aliasDirective) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective AliasDirective { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Duplicate value constraint")]
    public class DuplicateValueTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Duplicate value constraint";
        public DuplicateValueTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IValueConstraint constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IValueConstraint Constraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Underlined Error Highlighting", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="The constructor call needs to be dynamically dispatched, but cannot be because it" +
        " is part of a constructor initializer. Consider casting the dynamic arguments.")]
    public class DynamicBindingInConstructorInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The constructor call needs to be dynamically dispatched, but cannot be because it" +
            " is part of a constructor initializer. Consider casting the dynamic arguments.";
        public DynamicBindingInConstructorInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="An anonymous function or method group cannot be used as a constituent value of a " +
        "dynamically bound operation")]
    public class DynamicDispatchWithLambdaError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "An anonymous function or method group cannot be used as a constituent value of a " +
            "dynamically bound operation";
        public DynamicDispatchWithLambdaError(JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo invocation, JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo argument) { }
        public JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo Argument { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo Invocation { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("DynamicShiftRightOpIsNotInt", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Right operand of dynamic shift operation should be convertible to \'int\'")]
    public class DynamicShiftRightOpIsNotIntWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "DynamicShiftRightOpIsNotInt";
        protected const string MESSAGE = "Right operand of dynamic shift operation should be convertible to \'int\'";
        public DynamicShiftRightOpIsNotIntWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyConstructor", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty constructor is redundant. The compiler generates the same by default.")]
    public class EmptyConstructorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyConstructor";
        protected const string MESSAGE = "Empty constructor is redundant. The compiler generates the same by default.";
        public EmptyConstructorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyDestructor", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty destructor is redundant.")]
    public class EmptyDestructorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyDestructor";
        protected const string MESSAGE = "Empty destructor is redundant.";
        public EmptyDestructorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration destructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration DestructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyEmbeddedStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Empty control statement body")]
    public class EmptyEmbeddedStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyEmbeddedStatement";
        protected const string MESSAGE = "Empty control statement body";
        public EmptyEmbeddedStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyForStatement", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty \'for\' loop is redundant")]
    public class EmptyForStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyForStatement";
        protected const string MESSAGE = "Empty \'for\' loop is redundant";
        public EmptyForStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyGeneralCatchClause", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Empty general catch clause suppresses any errors")]
    public class EmptyGeneralCatchClauseWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyGeneralCatchClause";
        protected const string MESSAGE = "Empty general catch clause suppresses any errors";
        public EmptyGeneralCatchClauseWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause clause) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause Clause { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyNamespace", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty namespace declaration is redundant")]
    public class EmptyNamespaceWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyNamespace";
        protected const string MESSAGE = "Empty namespace declaration is redundant";
        public EmptyNamespaceWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration namespaceDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration NamespaceDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyStatement", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty statement is redundant")]
    public class EmptyStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyStatement";
        protected const string MESSAGE = "Empty statement is redundant";
        public EmptyStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EmptyConstructor", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty static constructor is redundant")]
    public class EmptyStaticConstructorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EmptyConstructor";
        protected const string MESSAGE = "Empty static constructor is redundant";
        public EmptyStaticConstructorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1522", "CSHARP", AttributeId="ReSharper Dead Code", CompilerIds=new string[] {
            "CS1522"}, CompilerIdsWithDescription="CS1522:Empty switch block", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty switch block")]
    public class EmptySwitchBlockWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1522";
        protected const string MESSAGE = "Empty switch block";
        public EmptySwitchBlockWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IBlock switchBlock) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBlock SwitchBlock { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Empty type parameter list")]
    public class EmptyTypeParameterListError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Empty type parameter list";
        public EmptyTypeParameterListError(JetBrains.ReSharper.Psi.Tree.ITreeNode typeParameterList) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode TypeParameterList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Enums cannot have type parameters")]
    public class EnumCannotHaveTypeParametersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Enums cannot have type parameters";
        public EnumCannotHaveTypeParametersError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration typeDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration TypeDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EnumerableSumInExplicitUncheckedContext", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'Enumerable.Sum\' invocation in explicit unchecked context")]
    public class EnumerableSumInExplicitUncheckedContextWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EnumerableSumInExplicitUncheckedContext";
        protected const string MESSAGE = "\'Enumerable.Sum\' invocation in explicit unchecked context";
        public EnumerableSumInExplicitUncheckedContextWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type byte, sbyte, short, ushort, int, uint, long, or ulong expected")]
    public class EnumUnderlyingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type byte, sbyte, short, ushort, int, uint, long, or ulong expected";
        public EnumUnderlyingTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage declaredTypeUsageNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage DeclaredTypeUsageNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EnumUnderlyingTypeIsInt", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'int\' is default enum governing type")]
    public class EnumUnderlyingTypeIsIntWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EnumUnderlyingTypeIsInt";
        protected const string MESSAGE = "\'int\' is default enum governing type";
        public EnumUnderlyingTypeIsIntWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage declaredTypeUsageNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage DeclaredTypeUsageNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The enumerator value is too large to fit in its type")]
    public class EnumValueTooBigError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The enumerator value is too large to fit in its type";
        public EnumValueTooBigError(JetBrains.ReSharper.Psi.CSharp.Tree.IEnumMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEnumMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0660", "CSHARP", CompilerIds=new string[] {
            "CS0660",
            "CS0661"}, CompilerIdsWithDescription="CS0660,CS0661:Operator \'==\' or operator \'!=\' with \'Object.Equals(object o)\' and \'" +
        "Object.GetHashCode()\' not overriden", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'{0}\' defines operator \'==\' or operator \'!=\' but does not override \'Object.Equals" +
        "(object o)\' and \'Object.GetHashCode()\'")]
    public class EqOperatorRequiresEqualsAndHashCodeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0660";
        protected const string MESSAGE = "\'{0}\' defines operator \'==\' or operator \'!=\' but does not override \'Object.Equals" +
            "(object o)\' and \'Object.GetHashCode()\'";
        public EqOperatorRequiresEqualsAndHashCodeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration typeDeclaration, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration TypeDeclaration { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EqualExpressionComparison", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, OverloadResolvePriority=10, ToolTipFormatString="Similar expressions comparison")]
    public class EqualExpressionComparisonWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EqualExpressionComparison";
        protected const string MESSAGE = "Similar expressions comparison";
        public EqualExpressionComparisonWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, bool expressionConstantValue) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public bool ExpressionConstantValue { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class ErrorPPDirectiveError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public ErrorPPDirectiveError(JetBrains.ReSharper.Psi.CSharp.Tree.IErrorDirective directiveNode, string errorMessage) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IErrorDirective DirectiveNode { get; }
        public string ErrorMessage { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Event accessor cannot have modifier")]
    public class EventAccessorCannotHaveModifiersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Event accessor cannot have modifier";
        public EventAccessorCannotHaveModifiersError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration, JetBrains.ReSharper.Psi.Tree.ITokenNode token) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Token { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Event must be of a delegate type")]
    public class EventMustBeOfDelegateTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Event must be of a delegate type";
        public EventMustBeOfDelegateTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Event property must have both add and remove accessors")]
    public class EventPropertyMustDeclareAdderAndRemoverError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Event property must have both add and remove accessors";
        public EventPropertyMustDeclareAdderAndRemoverError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("EventUnsubscriptionViaAnonymousDelegate", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Event unsubscription via anonymous delegate")]
    public class EventUnsubscriptionViaAnonymousDelegateWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "EventUnsubscriptionViaAnonymousDelegate";
        protected const string MESSAGE = "Event unsubscription via anonymous delegate";
        public EventUnsubscriptionViaAnonymousDelegateWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Expected catch or finally")]
    public class ExpectedCatchOrFinallyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Expected catch or finally";
        public ExpectedCatchOrFinallyError(JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ExplicitCallerInfoArgument", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Explicit argument passed to parameter with caller info attribute")]
    public class ExplicitCallerInfoArgumentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ExplicitCallerInfoArgument";
        protected const string MESSAGE = "Explicit argument passed to parameter with caller info attribute";
        public ExplicitCallerInfoArgumentWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="An explicit interface implementation of an event must use property syntax")]
    public class ExplicitEventImplementationMustUsePropertySyntaxError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "An explicit interface implementation of an event must use property syntax";
        public ExplicitEventImplementationMustUsePropertySyntaxError(JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' is already implemented")]
    public class ExplicitImplementationAlreadyImplementedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' is already implemented";
        public ExplicitImplementationAlreadyImplementedError(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredType qualifierInterface) { }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType QualifierInterface { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Explicit interface declaration can only be declared in a class or struct")]
    public class ExplicitImplementationInInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Explicit interface declaration can only be declared in a class or struct";
        public ExplicitImplementationInInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceQualificationOwner declaration, JetBrains.ReSharper.Psi.IDeclaredElement declaredElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceQualificationOwner Declaration { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' in explicit interface declaration is not a member of interface \'{1}\'")]
    public class ExplicitImplementationIsNotInterfaceMemberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' in explicit interface declaration is not a member of interface \'{1}\'";
        public ExplicitImplementationIsNotInterfaceMemberError(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredType qualifierInterface) { }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType QualifierInterface { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Constraints for explicit interface implementation method are inherited from the b" +
        "ase method, so they cannot be specified directly")]
    public class ExplicitImplementedMethodCannotHasTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constraints for explicit interface implementation method are inherited from the b" +
            "ase method, so they cannot be specified directly";
        public ExplicitImplementedMethodCannotHasTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause Constraint { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' does not implement interface \'{2}\'")]
    public class ExplicitQualifierIsNotInInterfaceListError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' does not implement interface \'{2}\'";
        public ExplicitQualifierIsNotInInterfaceListError(JetBrains.ReSharper.Psi.CSharp.Tree.IOwnerQualification qualifierNode, JetBrains.ReSharper.Psi.IDeclaredType qualifierInterface, JetBrains.ReSharper.Psi.ITypeElement classElement) { }
        public JetBrains.ReSharper.Psi.ITypeElement ClassElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType QualifierInterface { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOwnerQualification QualifierNode { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' in explicit interface declaration is not an interface")]
    public class ExplicitQualifierIsNotInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' in explicit interface declaration is not an interface";
        public ExplicitQualifierIsNotInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IOwnerQualification qualifier) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOwnerQualification Qualifier { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ExpressionIsAlwaysNull", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, OverloadResolvePriority=10, ToolTipFormatString="Expression is always null")]
    public class ExpressionIsAlwaysNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ExpressionIsAlwaysNull";
        protected const string MESSAGE = "Expression is always null";
        public ExpressionIsAlwaysNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="An expression tree cannot contain an assignment operator")]
    public class ExpressionTreeWithAssignmentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "An expression tree cannot contain an assignment operator";
        public ExpressionTreeWithAssignmentError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression lambdaExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression assignment) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Assignment { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression LambdaExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A lambda expression with a statement body cannot be converted to an expression tr" +
        "ee")]
    public class ExpressionTreeWithBodyBlockError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A lambda expression with a statement body cannot be converted to an expression tr" +
            "ee";
        public ExpressionTreeWithBodyBlockError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression lambdaExpression, JetBrains.ReSharper.Psi.CSharp.Tree.IBlock body) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBlock Body { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression LambdaExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="An expression tree cannot contain a call or invocation that uses optional argumen" +
        "ts")]
    public class ExpressionTreeWithOptionalArgumentsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "An expression tree cannot contain a call or invocation that uses optional argumen" +
            "ts";
        public ExpressionTreeWithOptionalArgumentsError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression lambdaExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgumentsOwner invocationDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgumentsOwner InvocationDeclaration { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression LambdaExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="An expression tree lambda cannot contain an \'out\' or \'ref\' parameter")]
    public class ExpressionTreeWithRefOutParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "An expression tree lambda cannot contain an \'out\' or \'ref\' parameter";
        public ExpressionTreeWithRefOutParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression lambdaExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression LambdaExpression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static class \'{0}\' cannot have extends list")]
    public class ExtendsListInStaticClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static class \'{0}\' cannot have extends list";
        public ExtendsListInStaticClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IExtendsList extendsList, JetBrains.ReSharper.Psi.IClass element) { }
        public JetBrains.ReSharper.Psi.IClass Element { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IExtendsList ExtendsList { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Extension method defined on value type cannot be used to create delegate")]
    public class ExtensionMethodGroupOnValueTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Extension method defined on value type cannot be used to create delegate";
        public ExtensionMethodGroupOnValueTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Extension method can only be declared in non-generic, non-nested static class")]
    public class ExtensionMethodInWrongClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Extension method can only be declared in non-generic, non-nested static class";
        public ExtensionMethodInWrongClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A parameter array cannot be used with \'this\' modifier on an extension method")]
    public class ExtensionMethodParameterCannotBeParamsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A parameter array cannot be used with \'this\' modifier on an extension method";
        public ExtensionMethodParameterCannotBeParamsError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter modifier \'this\' should be on the first parameter")]
    public class ExtensionMethodParameterShouldBeFirstError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter modifier \'this\' should be on the first parameter";
        public ExtensionMethodParameterShouldBeFirstError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The first parameter of an extension method cannot be of type \'dynamic\'")]
    public class ExtensionMethodThisParameterCannotBeDynamicError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The first parameter of an extension method cannot be of type \'dynamic\'";
        public ExtensionMethodThisParameterCannotBeDynamicError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The first parameter of an extension method cannot be of pointer type")]
    public class ExtensionMethodThisParameterCannotBePointerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The first parameter of an extension method cannot be of pointer type";
        public ExtensionMethodThisParameterCannotBePointerError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The first parameter of an extension method cannot be declared as \'ref\' or \'out\'")]
    public class ExtensionMethodThisParameterCannotBeRefOutError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The first parameter of an extension method cannot be declared as \'ref\' or \'out\'";
        public ExtensionMethodThisParameterCannotBeRefOutError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify a default value for the \'this\' parameter")]
    public class ExtensionMethodThisParameterCannotHaveDefaultValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify a default value for the \'this\' parameter";
        public ExtensionMethodThisParameterCannotHaveDefaultValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'this\' modifier on first parameter of method declaration without a ref" +
        "erence to System.Core.dll. Add a reference to System.Core.dll or remove \'this\' m" +
        "odifier from the method declaration")]
    public class ExtensionMethodThisParameterWithoutSystemCoreError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'this\' modifier on first parameter of method declaration without a ref" +
            "erence to System.Core.dll. Add a reference to System.Core.dll or remove \'this\' m" +
            "odifier from the method declaration";
        public ExtensionMethodThisParameterWithoutSystemCoreError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Accessor in extern {0} cannot declare a body")]
    public class ExternAccessorWithBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessor in extern {0} cannot declare a body";
        public ExternAccessorWithBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration typeMemberDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration TypeMemberDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be extern and declare a body")]
    public class ExternFunctionWithBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be extern and declare a body";
        public ExternFunctionWithBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Field or property expected")]
    public class FieldOrPropertyInMemberInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Field or property expected";
        public FieldOrPropertyInMemberInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="First parameter of shift operator should be \'{0}\'")]
    public class FirstParameterOfShiftOperatorMustBeContainingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "First parameter of shift operator should be \'{0}\'";
        public FirstParameterOfShiftOperatorMustBeContainingTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration, JetBrains.ReSharper.Psi.Tree.IParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.ITypeElement containingType) { }
        public JetBrains.ReSharper.Psi.ITypeElement ContainingType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.IParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Fixed size array declaration must provide array size")]
    public class FixedSizeArrayDeclarationMustProvideSizeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Fixed size array declaration must provide array size";
        public FixedSizeArrayDeclarationMustProvideSizeError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Fixed-size buffer may be declared in struct only")]
    public class FixedSizeBufferNotInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Fixed-size buffer may be declared in struct only";
        public FixedSizeBufferNotInStructError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Fixed-size field cannot be declared readonly")]
    public class FixedSizeFiledCannotBeReadonlyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Fixed-size field cannot be declared readonly";
        public FixedSizeFiledCannotBeReadonlyError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type of a local declared in a fixed statement must be a pointer type")]
    public class FixedVariableShouldHavePointerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type of a local declared in a fixed statement must be a pointer type";
        public FixedVariableShouldHavePointerTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} type cannot be \'{1}\'")]
    public class ForbiddenMemberTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} type cannot be \'{1}\'";
        public ForbiddenMemberTypeError(JetBrains.ReSharper.Psi.Tree.ITreeNode typeUsage, JetBrains.ReSharper.Psi.IType memberType, JetBrains.ReSharper.Psi.IDeclaredElement variable) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IType MemberType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode TypeUsage { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Variable { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'{0}\' as a type argument")]
    public class ForbiddenTypeInTypeArgumentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'{0}\' as a type argument";
        public ForbiddenTypeInTypeArgumentError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange argumentRange) { }
        public JetBrains.DocumentModel.DocumentRange ArgumentRange { get; }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ForCanBeConvertedToForeach", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="For-loop can be converted into foreach-loop")]
    public class ForCanBeConvertedToForeachWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ForCanBeConvertedToForeach";
        protected const string MESSAGE = "For-loop can be converted into foreach-loop";
        public ForCanBeConvertedToForeachWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement loop) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement Loop { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("LoopCanBeConvertedToQuery", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Loop can be converted into LINQ-expression")]
    public class ForCanBeConvertedToQueryWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "LoopCanBeConvertedToQuery";
        protected const string MESSAGE = "Loop can be converted into LINQ-expression";
        public ForCanBeConvertedToQueryWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement loop) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement Loop { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ForControlVariableIsNeverModified", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'for\' loop control variable is never modified")]
    public class ForControlVariableIsNeverModifiedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ForControlVariableIsNeverModified";
        protected const string MESSAGE = "\'for\' loop control variable is never modified";
        public ForControlVariableIsNeverModifiedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("LoopCanBeConvertedToQuery", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Loop can be converted into LINQ-expression")]
    public class ForeachCanBeConvertedToQueryWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "LoopCanBeConvertedToQuery";
        protected const string MESSAGE = "Loop can be converted into LINQ-expression";
        public ForeachCanBeConvertedToQueryWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IForeachStatement loop) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForeachStatement Loop { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("LoopCanBePartlyConvertedToQuery", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Part of loop\'s body can be converted into LINQ-expression")]
    public class ForeachCanBePartlyConvertedToQueryWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "LoopCanBePartlyConvertedToQuery";
        protected const string MESSAGE = "Part of loop\'s body can be converted into LINQ-expression";
        public ForeachCanBePartlyConvertedToQueryWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IForeachStatement loop) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForeachStatement Loop { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ForStatementConditionIsTrue", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'true\' is redundant as \'for\'-statement condition")]
    public class ForStatementConditionIsTrueWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ForStatementConditionIsTrue";
        protected const string MESSAGE = "\'true\' is redundant as \'for\'-statement condition";
        public ForStatementConditionIsTrueWarning(JetBrains.ReSharper.Psi.Tree.IExpression condition) { }
        public JetBrains.ReSharper.Psi.Tree.IExpression Condition { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("FunctionNeverReturns", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Function never returns")]
    public class FunctionNeverReturnsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "FunctionNeverReturns";
        protected const string MESSAGE = "Function never returns";
        public FunctionNeverReturnsWarning(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IBlock body) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBlock Body { get; }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("FunctionRecursiveOnAllPaths", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Function is recursive on all paths")]
    public class FunctionRecursiveOnAllPathsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "FunctionRecursiveOnAllPaths";
        protected const string MESSAGE = "Function is recursive on all paths";
        public FunctionRecursiveOnAllPathsWarning(JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("GCSuppressFinalizeForTypeWithoutDestructor", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'GC.SuppressFinalize\' is invoked for type without destructor")]
    public class GCSuppressFinalizeForTypeWithoutDestructorWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "GCSuppressFinalizeForTypeWithoutDestructor";
        protected const string MESSAGE = "\'GC.SuppressFinalize\' is invoked for type without destructor";
        public GCSuppressFinalizeForTypeWithoutDestructorWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("HeuristicUnreachableCode", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Code is heuristically unreachable")]
    public class HeuristicUnreachableCodeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "HeuristicUnreachableCode";
        protected const string MESSAGE = "Code is heuristically unreachable";
        public HeuristicUnreachableCodeWarning(JetBrains.ReSharper.Psi.ITreeRange treeRange) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITreeRange TreeRange { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="\'{0}\' hides inherited abstract {1} \'{2}\'")]
    public class HiddenAbstractMemberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' hides inherited abstract {1} \'{2}\'";
        public HiddenAbstractMemberError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IOverridableMember member, JetBrains.ReSharper.Psi.IOverridableMember hiddenMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember HiddenMember { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The constraints for type parameter \'{0}\' of method \'{1}\' must match the constrain" +
        "ts for type parameter \'{2}\' of interface method \'{3}\'. Consider using an explici" +
        "t interface implementation instead.")]
    public class ImplicitImplementedMethodTypeParameterConstraintMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The constraints for type parameter \'{0}\' of method \'{1}\' must match the constrain" +
            "ts for type parameter \'{2}\' of interface method \'{3}\'. Consider using an explici" +
            "t interface implementation instead.";
        public ImplicitImplementedMethodTypeParameterConstraintMismatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration typeParameterDeclaration, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMethod, JetBrains.ReSharper.Psi.ITypeParameter interfaceTypeParameter, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMember) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMember { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMethod { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter InterfaceTypeParameter { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration TypeParameterDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ImplicitlyCapturedClosure", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Implicitly captured closure: {0}")]
    public class ImplicitlyCapturedClosureWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ImplicitlyCapturedClosure";
        protected const string MESSAGE = "Implicitly captured closure: {0}";
        public ImplicitlyCapturedClosureWarning(JetBrains.ReSharper.Psi.Tree.ITreeNode lambda, System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.IDeclaredElement> implicitClosure) { }
        public string ErrorStripeToolTip { get; }
        public System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.IDeclaredElement> ImplicitClosure { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Lambda { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implicitly typed array cannot have size expression")]
    public class ImplicitlyTypedArrayCannotHaveSizeExpressionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implicitly typed array cannot have size expression";
        public ImplicitlyTypedArrayCannotHaveSizeExpressionError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression sizeExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression SizeExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implicitly typed array should have initializer")]
    public class ImplicitlyTypedArrayShouldHaveInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implicitly typed array should have initializer";
        public ImplicitlyTypedArrayShouldHaveInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression arrayCreationExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression ArrayCreationExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implicitly-typed local variables cannot have multiple declarators")]
    public class ImplicitlyTypeVariableCannotHaveMultipleDeclaratorsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implicitly-typed local variables cannot have multiple declarators";
        public ImplicitlyTypeVariableCannotHaveMultipleDeclaratorsError(JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleLocalVariableDeclaration multipleDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleLocalVariableDeclaration MultipleDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implicitly-typed local variable initializer must be an expression")]
    public class ImplicitlyTypeVariableShouldHaveExpressionInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implicitly-typed local variable initializer must be an expression";
        public ImplicitlyTypeVariableShouldHaveExpressionInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implicitly-typed local variable must be initialized")]
    public class ImplicitlyTypeVariableShouldHaveInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implicitly-typed local variable must be initialized";
        public ImplicitlyTypeVariableShouldHaveInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ImpureMethodCallOnReadonlyValueField", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Impure method is called for readonly field of value type")]
    public class ImpureMethodCallOnReadonlyValueFieldWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ImpureMethodCallOnReadonlyValueField";
        protected const string MESSAGE = "Impure method is called for readonly field of value type";
        public ImpureMethodCallOnReadonlyValueFieldWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.Resolve.IReference invocationReference) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference InvocationReference { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The {0} \'{1}\' cannot be used in this context because the {2} accessor is inaccess" +
        "ible")]
    public class InaccessibleAccessorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The {0} \'{1}\' cannot be used in this context because the {2} accessor is inaccess" +
            "ible";
        public InaccessibleAccessorError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IProperty property, JetBrains.ReSharper.Psi.AccessorKind kind) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.AccessorKind Kind { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty Property { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Default constructor of base class \'{0}\' is not accessible")]
    public class InaccessibleDefaultConstructorInBaseClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Default constructor of base class \'{0}\' is not accessible";
        public InaccessibleDefaultConstructorInBaseClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration classDeclaration, JetBrains.ReSharper.Psi.IClass baseClass) { }
        public JetBrains.ReSharper.Psi.IClass BaseClass { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration ClassDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Modifier \'{0}\' cannot be combined with \'{1}\'")]
    public class IncompatibleAccessRightsModifierError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Modifier \'{0}\' cannot be combined with \'{1}\'";
        public IncompatibleAccessRightsModifierError(JetBrains.ReSharper.Psi.Tree.ITreeNode modifier1, JetBrains.ReSharper.Psi.Tree.ITreeNode modifier2) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Modifier1 { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Modifier2 { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent lambda parameter usage; parameter types must be all explicit or all " +
        "implicit")]
    public class InconsistenLambdaParameterUsageError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent lambda parameter usage; parameter types must be all explicit or all " +
            "implicit";
        public InconsistenLambdaParameterUsageError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaSignature signature) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaSignature Signature { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent accessibility: base {0} \'{1}\' is less accessible than {2} \'{3}\'")]
    public class InconsistentAccessibilityInDerivationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent accessibility: base {0} \'{1}\' is less accessible than {2} \'{3}\'";
        public InconsistentAccessibilityInDerivationError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration derivedTypeDeclaration, JetBrains.ReSharper.Psi.ITypeElement derivedTypeElement, JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage baseTypeUsageNode, JetBrains.ReSharper.Psi.ITypeElement baseTypeElement) { }
        public JetBrains.ReSharper.Psi.ITypeElement BaseTypeElement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage BaseTypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration DerivedTypeDeclaration { get; }
        public JetBrains.ReSharper.Psi.ITypeElement DerivedTypeElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent accessibility: {0} type \'{1}\' is less accessible than {2} \'{3}\'")]
    public class InconsistentAccessibilityInMemberTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent accessibility: {0} type \'{1}\' is less accessible than {2} \'{3}\'";
        public InconsistentAccessibilityInMemberTypeError(JetBrains.ReSharper.Psi.Tree.ITreeNode typeUsageNode, JetBrains.ReSharper.Psi.IType usedType, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode TypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.IType UsedType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent accessibility: parameter type \'{0}\' is less accessible than {1} \'{2}" +
        "\'")]
    public class InconsistentAccessibilityInParameterTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent accessibility: parameter type \'{0}\' is less accessible than {1} \'{2}" +
            "\'";
        public InconsistentAccessibilityInParameterTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IType usedType, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.IType UsedType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent accessibility: return type \'{0}\' is less accessible than {1} \'{2}\'")]
    public class InconsistentAccessibilityInReturnTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent accessibility: return type \'{0}\' is less accessible than {1} \'{2}\'";
        public InconsistentAccessibilityInReturnTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IType usedType, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.IType UsedType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent accessibility: type argument \'{0}\' is less accessible than {1} \'{2}\'" +
        "")]
    public class InconsistentAccessibilityInTypeArgumentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent accessibility: type argument \'{0}\' is less accessible than {1} \'{2}\'" +
            "";
        public InconsistentAccessibilityInTypeArgumentError(JetBrains.ReSharper.Psi.Tree.ITreeNode typeUsageNode, JetBrains.ReSharper.Psi.IType usedType, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode TypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.IType UsedType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Inconsistent accessibility: constraint type \'{0}\' is less accessible than {1} \'{2" +
        "}\'")]
    public class InconsistentAccessibilityInTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Inconsistent accessibility: constraint type \'{0}\' is less accessible than {1} \'{2" +
            "}\'";
        public InconsistentAccessibilityInTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IType usedType, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public JetBrains.ReSharper.Psi.IType UsedType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Incompatible anonymous function signature")]
    public class IncorrectAnonymousMethodSignatureError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Incompatible anonymous function signature";
        public IncorrectAnonymousMethodSignatureError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression expression, JetBrains.ReSharper.Psi.IType targetType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Argument is \'{0}\' while parameter is declared as \'{1}\'")]
    public class IncorrectArgumentKindError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Argument is \'{0}\' while parameter is declared as \'{1}\'";
        public IncorrectArgumentKindError(JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo argument, JetBrains.ReSharper.Psi.ParameterKind parameterKind) { }
        public JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ParameterKind ParameterKind { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' has {2} parameter(s) but is invoked with {3} argument(s)")]
    public class IncorrectArgumentNumberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' has {2} parameter(s) but is invoked with {3} argument(s)";
        public IncorrectArgumentNumberError(JetBrains.ReSharper.Psi.Resolve.IReference reference, int parameterNumber, int argumentNumber) { }
        public int ArgumentNumber { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterNumber { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot resolve {0} \'{1}\', candidates are:{2}")]
    public class IncorrectArgumentsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot resolve {0} \'{1}\', candidates are:{2}";
        public IncorrectArgumentsError(JetBrains.ReSharper.Psi.Resolve.IReference reference, string string1, JetBrains.ReSharper.Psi.IDeclaredElement candidate, bool useElementType) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string String1 { get; }
        public string ToolTip { get; }
        public bool UseElementType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectArgumentTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectArgumentTypeError(JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo argument, JetBrains.ReSharper.Psi.IExpressionType argumentType, JetBrains.ReSharper.Psi.IType parameterType, JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo Argument { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ArgumentType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ParameterType { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectArrayElementTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectArrayElementTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression initializerExpression, JetBrains.ReSharper.Psi.IType targetType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression InitializerExpression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="This expression cannot be used as an assignment target")]
    public class IncorrectAssignmentTargetError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "This expression cannot be used as an assignment target";
        public IncorrectAssignmentTargetError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destination) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Destination { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectAssignmentTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectAssignmentTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression, JetBrains.ReSharper.Psi.IExpressionType sourceType, JetBrains.ReSharper.Psi.IType targetType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType SourceType { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="One of the parameters of a binary operator must be of the containing type")]
    public class IncorrectBinaryOperatorParametersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "One of the parameters of a binary operator must be of the containing type";
        public IncorrectBinaryOperatorParametersError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectCompoundAssignmentTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectCompoundAssignmentTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression, JetBrains.ReSharper.Psi.IType sourceType, JetBrains.ReSharper.Psi.IType targetType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType SourceType { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Name of destructor must match the name of the class")]
    public class IncorrectDestructorNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Name of destructor must match the name of the class";
        public IncorrectDestructorNameError(JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'add\' or \'remove\' expected")]
    public class IncorrectEventAccessorNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'add\' or \'remove\' expected";
        public IncorrectEventAccessorNameError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectExtensionMethodArgumentType2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectExtensionMethodArgumentType2Error(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType argumentType, JetBrains.ReSharper.Psi.IType parameterType) { }
        public JetBrains.ReSharper.Psi.IExpressionType ArgumentType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ParameterType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectExtensionMethodArgumentTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectExtensionMethodArgumentTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType argumentType, JetBrains.ReSharper.Psi.IType parameterType) { }
        public JetBrains.ReSharper.Psi.IExpressionType ArgumentType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ParameterType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectForeachVariableTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectForeachVariableTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IForeachVariableDeclaration iteratorDeclaration, JetBrains.ReSharper.Psi.IType iteratorType, JetBrains.ReSharper.Psi.IType elementType) { }
        public JetBrains.ReSharper.Psi.IType ElementType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForeachVariableDeclaration IteratorDeclaration { get; }
        public JetBrains.ReSharper.Psi.IType IteratorType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The return type for ++ or -- operator must be the containing type")]
    public class IncorrectIncrementDecrementOperatorTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The return type for ++ or -- operator must be the containing type";
        public IncorrectIncrementDecrementOperatorTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectInitializerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectInitializerTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.DocumentModel.DocumentRange declarationRange, JetBrains.ReSharper.Psi.IExpressionType sourceType, JetBrains.ReSharper.Psi.IType targetType) { }
        public JetBrains.DocumentModel.DocumentRange DeclarationRange { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType SourceType { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="The body of \'{0}\' cannot be an iterator block because \'{1}\' is not an iterator in" +
        "terface type")]
    public class IncorrectIteratorReturnTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The body of \'{0}\' cannot be an iterator block because \'{1}\' is not an iterator in" +
            "terface type";
        public IncorrectIteratorReturnTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration declaration, JetBrains.ReSharper.Psi.IType returnType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectLambdaBodyExpressionTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectLambdaBodyExpressionTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression bodyExpression, JetBrains.ReSharper.Psi.IExpressionType valueType, JetBrains.ReSharper.Psi.IType returnType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression BodyExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ValueType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'get\' or \'set\' expected")]
    public class IncorrectPropertyAccessorNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'get\' or \'set\' expected";
        public IncorrectPropertyAccessorNameError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectReturnTypeAsyncError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectReturnTypeAsyncError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatement, JetBrains.ReSharper.Psi.IExpressionType valueType, JetBrains.ReSharper.Psi.IType returnType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement ReturnStatement { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ValueType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectReturnTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectReturnTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatement, JetBrains.ReSharper.Psi.IExpressionType valueType, JetBrains.ReSharper.Psi.IType returnType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement ReturnStatement { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ValueType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Expected a method with \'{0} {1}{2}\' signature")]
    public class IncorrectSignatureInDelegateCreationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Expected a method with \'{0} {1}{2}\' signature";
        public IncorrectSignatureInDelegateCreationError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDelegate createdDelegate, JetBrains.ReSharper.Psi.Resolve.ISubstitution delegateSubstitution) { }
        public JetBrains.ReSharper.Psi.IDelegate CreatedDelegate { get; }
        public JetBrains.ReSharper.Psi.Resolve.ISubstitution DelegateSubstitution { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1580", "CSHARP", AttributeId="ReSharper Error Highlighting", CompilerIds=new string[] {
            "CS1580"}, CompilerIdsWithDescription="CS1580:Incorrect signature in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Incorrect signature of \'{0}\'")]
    public class IncorrectSignatureInDocCommentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1580";
        protected const string MESSAGE = "Incorrect signature of \'{0}\'";
        public IncorrectSignatureInDocCommentWarning(JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot define operator \'{0}\' with {1} parameters")]
    public class IncorrectSignOperatorParameterNumberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot define operator \'{0}\' with {1} parameters";
        public IncorrectSignOperatorParameterNumberError(string name, int number, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public string Name { get; }
        public int NavigationOffsetPatch { get; }
        public int Number { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectStackAllockInitializerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectStackAllockInitializerTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeStackAllocInitializer initializer, JetBrains.DocumentModel.DocumentRange declarationRange, JetBrains.ReSharper.Psi.IExpressionType sourceType, JetBrains.ReSharper.Psi.IType targetType) { }
        public JetBrains.DocumentModel.DocumentRange DeclarationRange { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeStackAllocInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType SourceType { get; }
        public JetBrains.ReSharper.Psi.IType TargetType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The return type of operator True or False must be bool")]
    public class IncorrectTrueOrFalseOperatorTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The return type of operator True or False must be bool";
        public IncorrectTrueOrFalseOperatorTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The parameter of a unary operator must be of the containing type")]
    public class IncorrectUnaryOperatorParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The parameter of a unary operator must be of the containing type";
        public IncorrectUnaryOperatorParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class IncorrectYieldReturnTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public IncorrectYieldReturnTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement yieldStatement, JetBrains.ReSharper.Psi.IExpressionType valueType, JetBrains.ReSharper.Psi.IType yieldType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ValueType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement YieldStatement { get; }
        public JetBrains.ReSharper.Psi.IType YieldType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Indexed property \'{0}\' has non-optional arguments which must be provided")]
    public class IndexedPropertyWithoutArgumentsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Indexed property \'{0}\' has non-optional arguments which must be provided";
        public IndexedPropertyWithoutArgumentsError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Indexer cannot be declared \'static\'")]
    public class IndexerCannotBeStaticError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Indexer cannot be declared \'static\'";
        public IndexerCannotBeStaticError(JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Indexer has {0} parameter(s) but is invoked with {1} argument(s)")]
    public class IndexerIncorrectArgumentNumberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Indexer has {0} parameter(s) but is invoked with {1} argument(s)";
        public IndexerIncorrectArgumentNumberError(JetBrains.ReSharper.Psi.Resolve.IReference reference, int parameterNumber, int argumentNumber) { }
        public int ArgumentNumber { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public int ParameterNumber { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Indexers must have at least one parameter")]
    public class IndexerMustHaveParametersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Indexers must have at least one parameter";
        public IndexerMustHaveParametersError(JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot apply indexing to an expression of type \'{0}\'")]
    public class IndexerNotResolvedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot apply indexing to an expression of type \'{0}\'";
        public IndexerNotResolvedError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IExpressionType ExpressionType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Can only use array initializer expressions to assign to array types. Try using a " +
        "new expression instead.")]
    public class InitializeNonArrayVariableByArrayError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Can only use array initializer expressions to assign to array types. Try using a " +
            "new expression instead.";
        public InitializeNonArrayVariableByArrayError(JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer initializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Initializer is not allowed for static constructor")]
    public class InitializerInStaticConstructorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Initializer is not allowed for static constructor";
        public InitializerInStaticConstructorError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer constructorInitializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer ConstructorInitializer { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot convert null to type parameter \'{0}\' because it could be a value type. Con" +
        "sider using \'default(T)\' instead.")]
    public class InitializeTypeParameterWithoutClassConstraintWithNullError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot convert null to type parameter \'{0}\' because it could be a value type. Con" +
            "sider using \'default(T)\' instead.";
        public InitializeTypeParameterWithoutClassConstraintWithNullError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.DocumentModel.DocumentRange declarationRange, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public JetBrains.DocumentModel.DocumentRange DeclarationRange { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Value of integral type expected")]
    public class IntegralTypeValueExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Value of integral type expected";
        public IntegralTypeValueExpectedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Accessor in interface {0} cannot declare a body")]
    public class InterfaceAccessorWithBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessor in interface {0} cannot declare a body";
        public InterfaceAccessorWithBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration typeMemberDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration TypeMemberDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Interface cannot contain {0}")]
    public class InterfaceCannotContainNonOverridableMemberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Interface cannot contain {0}";
        public InterfaceCannotContainNonOverridableMemberError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement declaredElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\': interface name expected")]
    public class InterfaceInExtendsListExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\': interface name expected";
        public InterfaceInExtendsListExpectedError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.IDeclaredElement declaredElement) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class InterfaceMembersNotImplementedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public InterfaceMembersNotImplementedError(JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration declaration, JetBrains.ReSharper.Psi.TypeMemberInstance[] members) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance[] Members { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Interface method cannot declare a body")]
    public class InterfaceMethodWithBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Interface method cannot declare a body";
        public InterfaceMethodWithBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' cannot implement both \'{2}\' and \'{3}\' because they may unify for some t" +
        "ype parameter substitutions")]
    public class InterfaceUnificationConflictError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' cannot implement both \'{2}\' and \'{3}\' because they may unify for some t" +
            "ype parameter substitutions";
        public InterfaceUnificationConflictError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredType interface1, JetBrains.ReSharper.Psi.IDeclaredType interface2) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType Interface1 { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType Interface2 { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("IntroduceOptionalParameters.Global", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Introduce optional parameter(s) for {0} \'{1}\'")]
    public class IntroduceOptionalParametersGlobalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.IntroduceOptionalParametersWarningBase
    {
        public const string HIGHLIGHTING_ID = "IntroduceOptionalParameters.Global";
        public IntroduceOptionalParametersGlobalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IParametersOwner overloadMember, JetBrains.Util.Pair<, >[] parameters) { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("IntroduceOptionalParameters.Local", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Introduce optional parameter(s) for {0} \'{1}\'")]
    public class IntroduceOptionalParametersLocalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.IntroduceOptionalParametersWarningBase
    {
        public const string HIGHLIGHTING_ID = "IntroduceOptionalParameters.Local";
        public IntroduceOptionalParametersLocalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IParametersOwner overloadMember, JetBrains.Util.Pair<, >[] parameters) { }
    }
    public abstract class IntroduceOptionalParametersWarningBase : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Introduce optional parameter(s) for {0} \'{1}\'";
        public IntroduceOptionalParametersWarningBase(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IParametersOwner overloadMember, JetBrains.Util.Pair<, >[] parameters) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IParametersOwner OverloadMember { get; }
        public JetBrains.Util.Pair<, >[] Parameters { get; }
        public string ToolTip { get; }
        public static JetBrains.ReSharper.Daemon.CSharp.Errors.IntroduceOptionalParametersWarningBase Create(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IParametersOwner overloadMember, JetBrains.Util.Pair<, >[] parameters, bool isGlobal) { }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The modifier \'{0}\' is not valid for accessor")]
    public class InvalidAccessorModifierError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The modifier \'{0}\' is not valid for accessor";
        public InvalidAccessorModifierError(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration, JetBrains.ReSharper.Psi.Tree.ITokenNode token, string tokenText) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Token { get; }
        public string TokenText { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Array initializers can only be used in a variable or field initializer. Try using" +
        " a new expression instead")]
    public class InvalidArrayInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Array initializers can only be used in a variable or field initializer. Try using" +
            " a new expression instead";
        public InvalidArrayInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot convert type \'{0}\' to \'{1}\' via a built-in conversion")]
    public class InvalidAsCastError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot convert type \'{0}\' to \'{1}\' via a built-in conversion";
        public InvalidAsCastError(JetBrains.ReSharper.Psi.CSharp.Tree.IAsExpression node, JetBrains.ReSharper.Psi.IExpressionType expressionType, JetBrains.ReSharper.Psi.IType castType) { }
        public JetBrains.ReSharper.Psi.IType CastType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAsExpression Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Attribute \'{0}\' is not valid on this declaration type. It is valid on \'{1}\' decla" +
        "rations only.")]
    public class InvalidAttributeUsageError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Attribute \'{0}\' is not valid on this declaration type. It is valid on \'{1}\' decla" +
            "rations only.";
        public InvalidAttributeUsageError(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, JetBrains.ReSharper.Psi.ITypeElement attributeClass, string validTargets) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public JetBrains.ReSharper.Psi.ITypeElement AttributeClass { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public string ValidTargets { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Attribute \'{0}\' is not valid at this point")]
    public class InvalidAttributeUsageTargetError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Attribute \'{0}\' is not valid at this point";
        public InvalidAttributeUsageTargetError(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, JetBrains.ReSharper.Psi.ITypeElement attributeClass, string target) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public JetBrains.ReSharper.Psi.ITypeElement AttributeClass { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string Target { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'base\' expression in this context")]
    public class InvalidBaseExpressionUsageError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'base\' expression in this context";
        public InvalidBaseExpressionUsageError(JetBrains.ReSharper.Psi.CSharp.Tree.IBaseExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBaseExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class InvalidCaseLabelTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public InvalidCaseLabelTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label, JetBrains.ReSharper.Psi.IType conditionType) { }
        public JetBrains.ReSharper.Psi.IType ConditionType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot cast expression of type \'{0}\' to type \'{1}\'")]
    public class InvalidCastError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot cast expression of type \'{0}\' to type \'{1}\'";
        public InvalidCastError(JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression node, JetBrains.ReSharper.Psi.IExpressionType expressionType, JetBrains.ReSharper.Psi.IType castType) { }
        public JetBrains.ReSharper.Psi.IType CastType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use \'System.Array\', \'System.Delegate\', \'System.Enum\', \'System.ValueType\', " +
        "\'object\' as type parameter constraint")]
    public class InvalidClassInTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use \'System.Array\', \'System.Delegate\', \'System.Enum\', \'System.ValueType\', " +
            "\'object\' as type parameter constraint";
        public InvalidClassInTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Attribute \'System.Diagnostics.ConditionalAttribute\' is only valid on methods or a" +
        "ttribute classes")]
    public class InvalidConditionalAttributeUsageError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Attribute \'System.Diagnostics.ConditionalAttribute\' is only valid on methods or a" +
            "ttribute classes";
        public InvalidConditionalAttributeUsageError(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type \'{0}\' cannot be declared const")]
    public class InvalidConstantTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type \'{0}\' cannot be declared const";
        public InvalidConstantTypeError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IType constantType) { }
        public JetBrains.ReSharper.Psi.IType ConstantType { get; }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="The event \'{0}\' can only appear on the left hand side of += or -=")]
    public class InvalidCustomEventUsageError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The event \'{0}\' can only appear on the left hand side of += or -=";
        public InvalidCustomEventUsageError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IEvent referencedEvent) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IEvent ReferencedEvent { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Invalid embedded statement")]
    public class InvalidEmbeddedStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Invalid embedded statement";
        public InvalidEmbeddedStatementError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Only assignment, call, increment, decrement, and new object expressions can be us" +
        "ed as a statement")]
    public class InvalidExpressionStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Only assignment, call, increment, decrement, and new object expressions can be us" +
            "ed as a statement";
        public InvalidExpressionStatementError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Fixed-size buffer element type should be one of sbyte, byte, short, ushort, int, " +
        "uint, long, ulong, char, float, double, or bool")]
    public class InvalidFixedSizeBufferElementTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Fixed-size buffer element type should be one of sbyte, byte, short, ushort, int, " +
            "uint, long, ulong, char, float, double, or bool";
        public InvalidFixedSizeBufferElementTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot assign \'{0}\' to an implicitly-typed local variable")]
    public class InvalidInitializerImplicitlyTypeVariableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot assign \'{0}\' to an implicitly-typed local variable";
        public InvalidInitializerImplicitlyTypeVariableError(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration, JetBrains.ReSharper.Psi.IExpressionType initializerType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType InitializerType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The modifier \'{0}\' is not valid for interface member declaration. Only \'new\' is v" +
        "alid.")]
    public class InvalidInterfaceMemberModifierError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The modifier \'{0}\' is not valid for interface member declaration. Only \'new\' is v" +
            "alid.";
        public InvalidInterfaceMemberModifierError(JetBrains.ReSharper.Psi.Tree.ITokenNode modifier) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Modifier { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Only methods, operators and accessors could contain \'yield\' statement")]
    public class InvalidIteratorDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Only methods, operators and accessors could contain \'yield\' statement";
        public InvalidIteratorDeclarationError(JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The modifier \'{0}\' is not valid for explicit interface implementation.")]
    public class InvalidModifierInExplicitDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The modifier \'{0}\' is not valid for explicit interface implementation.";
        public InvalidModifierInExplicitDeclarationError(JetBrains.ReSharper.Psi.Tree.ITokenNode modifier) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Modifier { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Invalid modifier \'{0}\' in operator declaration")]
    public class InvalidModifierInOperatorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Invalid modifier \'{0}\' in operator declaration";
        public InvalidModifierInOperatorError(JetBrains.ReSharper.Psi.Tree.ITokenNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Modifier \'{0}\' is not valid for {1} \'{2}\'")]
    public class InvalidModifierOnTypeDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Modifier \'{0}\' is not valid for {1} \'{2}\'";
        public InvalidModifierOnTypeDeclarationError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration, JetBrains.ReSharper.Psi.Tree.ITokenNode modifier) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Modifier { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Invalid namespace alias")]
    public class InvalidNamespaceAlias2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Invalid namespace alias";
        public InvalidNamespaceAlias2Error(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Invalid namespace alias")]
    public class InvalidNamespaceAliasError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Invalid namespace alias";
        public InvalidNamespaceAliasError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName alias) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName Alias { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Only non-nullable value type could be underlying of \'System.Nullable\'")]
    public class InvalidNullableUnderlyingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Only non-nullable value type could be underlying of \'System.Nullable\'";
        public InvalidNullableUnderlyingTypeError(JetBrains.ReSharper.Psi.IType underlyingType, JetBrains.ReSharper.Psi.Tree.ITreeNode rangeNode) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode RangeNode { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType UnderlyingType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Left operand of the \'??\' operator should be of reference or nullable type")]
    public class InvalidNullCoalescingLeftOperandError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Left operand of the \'??\' operator should be of reference or nullable type";
        public InvalidNullCoalescingLeftOperandError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression leftOperand) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression LeftOperand { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Operator \'??\' cannot be applied to operands of type \'{0}\' and \'{1}\'")]
    public class InvalidNullCoalescingOperandsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Operator \'??\' cannot be applied to operands of type \'{0}\' and \'{1}\'";
        public InvalidNullCoalescingOperandsError(JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression expression, JetBrains.ReSharper.Psi.IExpressionType leftType, JetBrains.ReSharper.Psi.IExpressionType rightType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IExpressionType LeftType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType RightType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A partial method cannot have access modifiers or the virtual, abstract, override," +
        " new, sealed, or extern modifiers")]
    public class InvalidPartialMethodModifierError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A partial method cannot have access modifiers or the virtual, abstract, override," +
            " new, sealed, or extern modifiers";
        public InvalidPartialMethodModifierError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration, JetBrains.ReSharper.Psi.Tree.ITokenNode tokenNode) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode TokenNode { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Invalid preprocessor directive node")]
    public class InvalidPPDirectiveError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Invalid preprocessor directive node";
        public InvalidPPDirectiveError(JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorErrorDirective directiveNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorErrorDirective DirectiveNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Operator \'.\' cannot be applied to operand of type \'{0}\'")]
    public class InvalidReferenceExpressionQualifierError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Operator \'.\' cannot be applied to operand of type \'{0}\'";
        public InvalidReferenceExpressionQualifierError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IExpressionType qualifierType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType QualifierType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="The event \'{0}\' can only appear on the left hand side of += or -= (except when us" +
        "ed from within the {1} \'{2}\')")]
    public class InvalidStandardEventUsageError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The event \'{0}\' can only appear on the left hand side of += or -= (except when us" +
            "ed from within the {1} \'{2}\')";
        public InvalidStandardEventUsageError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IEvent referencedEvent) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IEvent ReferencedEvent { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot assign \'{0}\' to anonymous type property")]
    public class InvalidTypeInAnonymousTypePropertyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot assign \'{0}\' to anonymous type property";
        public InvalidTypeInAnonymousTypePropertyError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType propertyType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IExpressionType PropertyType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Operation is invalid on void pointer")]
    public class InvalidVoidPointerOperationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Operation is invalid on void pointer";
        public InvalidVoidPointerOperationError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1590", "CSHARP", CompilerIds=new string[] {
            "CS1590"}, CompilerIdsWithDescription="CS1590:Invalid XML include element", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Invalid XML include element: {0}")]
    public class InvalidXMLIncludeElementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1590";
        protected const string MESSAGE = "Invalid XML include element: {0}";
        public InvalidXMLIncludeElementWarning(JetBrains.ReSharper.Psi.Xml.Tree.IXmlTreeNode xmlTag, string reason) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string Reason { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.Xml.Tree.IXmlTreeNode XmlTag { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("InvertIf", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Invert \'if\' statement to reduce nesting")]
    public class InvertIfWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "InvertIf";
        protected const string MESSAGE = "Invert \'if\' statement to reduce nesting";
        public InvertIfWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("InvocationIsSkipped", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Method invocation is skipped. Compiler will not generate method invocation becaus" +
        "e the method is conditional, or it is partial method without implementation")]
    public class InvocationIsSkippedInfo : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "InvocationIsSkipped";
        protected const string MESSAGE = "Method invocation is skipped. Compiler will not generate method invocation becaus" +
            "e the method is conditional, or it is partial method without implementation";
        public InvocationIsSkippedInfo(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("InvokeAsExtensionMethod", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Invoke as extension method")]
    public class InvokeAsExtensionMethodWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "InvokeAsExtensionMethod";
        protected const string MESSAGE = "Invoke as extension method";
        public InvokeAsExtensionMethodWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.Resolve.IReference methodReference) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference MethodReference { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The first operand of an \'is\' or \'as\' operator cannot be a lambda expression or an" +
        "onymous method")]
    public class IsAsInvalidOnAnonymousAndLambdaExpressionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The first operand of an \'is\' or \'as\' operator cannot be a lambda expression or an" +
            "onymous method";
        public IsAsInvalidOnAnonymousAndLambdaExpressionError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Neither \'is\' nor \'as\' are valid on pointer types")]
    public class IsAsInvalidOnPointerType2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Neither \'is\' nor \'as\' are valid on pointer types";
        public IsAsInvalidOnPointerType2Error(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Neither \'is\' nor \'as\' are valid on pointer types")]
    public class IsAsInvalidOnPointerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Neither \'is\' nor \'as\' are valid on pointer types";
        public IsAsInvalidOnPointerTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Neither \'is\' nor \'as\' are valid on void type")]
    public class IsAsInvalidOnVoidTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Neither \'is\' nor \'as\' are valid on void type";
        public IsAsInvalidOnVoidTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0184", "CSHARP", CompilerIds=new string[] {
            "CS0184"}, CompilerIdsWithDescription="CS0184:Given expression is never of the provided type", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The given expression is never of the provided type")]
    public class IsExpressionAlwaysFalseWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0184";
        protected const string MESSAGE = "The given expression is never of the provided type";
        public IsExpressionAlwaysFalseWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0183", "CSHARP", CompilerIds=new string[] {
            "CS0183"}, CompilerIdsWithDescription="CS0183:Given expression is always of the provided type", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The given expression is always of the provided type.{0}")]
    public class IsExpressionAlwaysTrueWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0183";
        protected const string MESSAGE = "The given expression is always of the provided type.{0}";
        public IsExpressionAlwaysTrueWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression expression, bool suggestComapreWithNull) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public bool SuggestComapreWithNull { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("IteratorMethodResultIsIgnored", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Return value of iterator is not used")]
    public class IteratorMethodResultIsIgnoredWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "IteratorMethodResultIsIgnored";
        protected const string MESSAGE = "Return value of iterator is not used";
        public IteratorMethodResultIsIgnoredWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.Resolve.IReference invocationReference) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference InvocationReference { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("JoinDeclarationAndInitializer", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Join declaration and assignment")]
    public class JoinDeclarationAndInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "JoinDeclarationAndInitializer";
        protected const string MESSAGE = "Join declaration and assignment";
        public JoinDeclarationAndInitializerWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression initialization) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Initialization { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot jump out of the finally block")]
    public class JumpFromFinallyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot jump out of the finally block";
        public JumpFromFinallyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement jumpStatement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement JumpStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter \'{0}\' must be declared as \'{1}\'")]
    public class LambdaParameterKindMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter \'{0}\' must be declared as \'{1}\'";
        public LambdaParameterKindMismatchError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration declaration, JetBrains.ReSharper.Psi.IParameter delegateParameter) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IParameter DelegateParameter { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Lambda expression parameter cannot be \'params\'")]
    public class LambdaParameterParamsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Lambda expression parameter cannot be \'params\'";
        public LambdaParameterParamsError(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration declarationNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration DeclarationNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("LocalVariableHidesMember", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Local variable \'{0}\' hides {1} \'{2}\'")]
    public class LocalVariableHidesMemberWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "LocalVariableHidesMember";
        protected const string MESSAGE = "Local variable \'{0}\' hides {1} \'{2}\'";
        public LocalVariableHidesMemberWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration variableDeclaration, JetBrains.ReSharper.Psi.ITypeMember hiddenMember) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember HiddenMember { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration VariableDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("LongLiteralEndingLowerL", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Long literal ending with \'l\' instead of \'L\'")]
    public class LongLiteralEndingLowerLWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "LongLiteralEndingLowerL";
        protected const string MESSAGE = "Long literal ending with \'l\' instead of \'L\'";
        public LongLiteralEndingLowerLWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpLiteralExpression literalExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpLiteralExpression LiteralExpression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The operator \'{0}\' requires a matching operator \'{1}\' to also be defined")]
    public class MatchingOperatorRequiredError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The operator \'{0}\' requires a matching operator \'{1}\' to also be defined";
        public MatchingOperatorRequiredError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration, JetBrains.ReSharper.Psi.IFunction operatorElement, string missedOperatorName) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public string MissedOperatorName { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IFunction OperatorElement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAssignment", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Destination has the same value before assignment")]
    public class MeaninglessAssignmentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAssignment";
        protected const string MESSAGE = "Destination has the same value before assignment";
        public MeaninglessAssignmentWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MeaninglessDefaultParameterValue", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'DefaultParameterValueAttrbiute\' should be used in conjunction with \'OptionalAttr" +
        "ibute\'")]
    public class MeaninglessDefaultParameterValueWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MeaninglessDefaultParameterValue";
        protected const string MESSAGE = "\'DefaultParameterValueAttrbiute\' should be used in conjunction with \'OptionalAttr" +
            "ibute\'";
        public MeaninglessDefaultParameterValueWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1066", "CSHARP", CompilerIds=new string[] {
            "CS1066"}, CompilerIdsWithDescription="CS1066:Default value specified for parameter will have no effect because it appli" +
        "es to a member that is used in contexts that do not allow optional arguments", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The default value specified for parameter \'{0}\' will have no effect because it ap" +
        "plies to a member that is used in contexts that do not allow optional arguments")]
    public class MeaninglessOptionalParameterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1066";
        protected const string MESSAGE = "The default value specified for parameter \'{0}\' will have no effect because it ap" +
            "plies to a member that is used in contexts that do not allow optional arguments";
        public MeaninglessOptionalParameterWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MemberHidesStaticFromOuterClass", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0} \'{1}\' hides {2} from outer class")]
    public class MemberHidesStaticFromOuterClassWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MemberHidesStaticFromOuterClass";
        protected const string MESSAGE = "{0} \'{1}\' hides {2} from outer class";
        public MemberHidesStaticFromOuterClassWarning(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member, JetBrains.ReSharper.Psi.ITypeMember hiddenMember) { }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember HiddenMember { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Member names cannot be the same as their enclosing type")]
    public class MemberNameEqualTypeNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Member names cannot be the same as their enclosing type";
        public MemberNameEqualTypeNameError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method cannot be declared in enum")]
    public class MethodDeclarationInEnumError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method cannot be declared in enum";
        public MethodDeclarationInEnumError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot choose method from method group. Did you intend to invoke the method?")]
    public class MethodGroupInvalidContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot choose method from method group. Did you intend to invoke the method?";
        public MethodGroupInvalidContextError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MethodOverloadWithOptionalParameter", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Method with {0} parameter is hidden by overload")]
    public class MethodOverloadWithOptionalParameterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MethodOverloadWithOptionalParameter";
        protected const string MESSAGE = "Method with {0} parameter is hidden by overload";
        public MethodOverloadWithOptionalParameterWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MethodSupportsCancellation", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Method has overload with cancellation support")]
    public class MethodSupportsCancellationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MethodSupportsCancellation";
        protected const string MESSAGE = "Method has overload with cancellation support";
        public MethodSupportsCancellationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression invocation, JetBrains.ReSharper.Psi.IParameter cancellationParameter, System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeOwner> cancellationTokens) { }
        public JetBrains.ReSharper.Psi.IParameter CancellationParameter { get; }
        public System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeOwner> CancellationTokens { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Invocation { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter constraints differs from declared in other parts")]
    public class MismatchPartsTypeParameterConstraintsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter constraints differs from declared in other parts";
        public MismatchPartsTypeParameterConstraintsError(System.Collections.Generic.IList<JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause> constraints) { }
        public System.Collections.Generic.IList<JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause> Constraints { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Return statement is missing")]
    public class MissedReturnStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Return statement is missing";
        public MissedReturnStatementError(JetBrains.ReSharper.Psi.CSharp.Tree.IBlock block) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBlock Block { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Invalid initializer member declarator: missing name")]
    public class MissingNameInObjectMemberInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Invalid initializer member declarator: missing name";
        public MissingNameInObjectMemberInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.IMemberInitializer memberInitializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMemberInitializer MemberInitializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\';\' is missing")]
    public class MissingSemicolonAfterLabelError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\';\' is missing";
        public MissingSemicolonAfterLabelError(JetBrains.ReSharper.Psi.CSharp.Tree.ILabelStatement label) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type argument is missing")]
    public class MissingTypeArgumentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type argument is missing";
        public MissingTypeArgumentError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList TypeArgumentList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0642", "CSHARP", AttributeId="ReSharper Dead Code", CompilerIds=new string[] {
            "CS0642"}, CompilerIdsWithDescription="CS0642:Possible mistaken empty statement", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Possible mistaken empty statement")]
    public class MistakenEmptyStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0642";
        protected const string MESSAGE = "Possible mistaken empty statement";
        public MistakenEmptyStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAssignment", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Value assigned is not used in any execution path")]
    public class ModifiedValueNotUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAssignment";
        protected const string MESSAGE = "Value assigned is not used in any execution path";
        public ModifiedValueNotUsedWarning(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Cannot modify the expression because it is not a variable")]
    public class ModifyNoninstanceStructFieldError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot modify the expression because it is not a variable";
        public ModifyNoninstanceStructFieldError(JetBrains.ReSharper.Psi.Tree.IExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.IExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MoreSpecificForeachVariableTypeAvailable", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Variable can be declared with more specific type \'{0}\'")]
    public class MoreSpecificForeachVariableTypeAvailableWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MoreSpecificForeachVariableTypeAvailable";
        protected const string MESSAGE = "Variable can be declared with more specific type \'{0}\'";
        public MoreSpecificForeachVariableTypeAvailableWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IForeachVariableDeclaration iteratorDeclaration, JetBrains.ReSharper.Psi.IType iteratorType, JetBrains.ReSharper.Psi.IType elementType) { }
        public JetBrains.ReSharper.Psi.IType ElementType { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IForeachVariableDeclaration IteratorDeclaration { get; }
        public JetBrains.ReSharper.Psi.IType IteratorType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot access {0} \'{1}\' here due its protection level")]
    public class MultipleAccessRights2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access {0} \'{1}\' here due its protection level";
        public MultipleAccessRights2Error(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, bool useElementType) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public bool UseElementType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot access {0} {1} \'{2}\' here")]
    public class MultipleAccessRightsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access {0} {1} \'{2}\' here";
        public MultipleAccessRightsError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, bool useElementType) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public bool UseElementType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1574", "CSHARP", CompilerIds=new string[] {
            "CS1574"}, CompilerIdsWithDescription="CS1574:Ambiguous reference in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Ambiguous reference \'{0}\'")]
    public class MultipleCandidatesInDocCommentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1574";
        protected const string MESSAGE = "Ambiguous reference \'{0}\'";
        public MultipleCandidatesInDocCommentWarning(JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Multiple expressions are not allowed in \'using\' statement")]
    public class MultipleExpressionsInUsingStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Multiple expressions are not allowed in \'using\' statement";
        public MultipleExpressionsInUsingStatementError(JetBrains.ReSharper.Psi.Tree.ITokenNode comma) { }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Comma { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Program \'{0}\' has more than one entry point defined")]
    public class MultipleMainMethodsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Program \'{0}\' has more than one entry point defined";
        public MultipleMainMethodsError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, string programName) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ProgramName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot access non-static {0} \'{1}\' in static context")]
    public class MultipleNonStaticElementInStaticContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access non-static {0} \'{1}\' in static context";
        public MultipleNonStaticElementInStaticContextError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, bool useElementType) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public bool UseElementType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MultipleNullableAttributesUsage", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Multiple nullness attribute usage")]
    public class MultipleNullableAttributesUsageWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MultipleNullableAttributesUsage";
        protected const string MESSAGE = "Multiple nullness attribute usage";
        public MultipleNullableAttributesUsageWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("MultipleOrderBy", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Multiple sequential \'OrderBy\' invocation is meaningless. Possible \'ThenBy\' means")]
    public class MultipleOrderByWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "MultipleOrderBy";
        protected const string MESSAGE = "Multiple sequential \'OrderBy\' invocation is meaningless. Possible \'ThenBy\' means";
        public MultipleOrderByWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression methodReference) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression Expression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression MethodReference { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="The inherited members \'{0}\' and \'{1}\' have the same signature in {2} \'{3}\', so th" +
        "ey cannot be overridden")]
    public class MultipleOverridenMembersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The inherited members \'{0}\' and \'{1}\' have the same signature in {2} \'{3}\', so th" +
            "ey cannot be overridden";
        public MultipleOverridenMembersError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement typeElement, JetBrains.ReSharper.Psi.IOverridableMember member1, JetBrains.ReSharper.Psi.IOverridableMember member2) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember Member1 { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember Member2 { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1957", "CSHARP", CompilerIds=new string[] {
            "CS1957"}, CompilerIdsWithDescription="CS1957:Multiple override candidates at run-time", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0} overrides \'{1}\'. There are multiple override candidates at run-time. It is im" +
        "plementation dependent which method will be called.")]
    public class MultipleOverridenMembersWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1957";
        protected const string MESSAGE = "{0} overrides \'{1}\'. There are multiple override candidates at run-time. It is im" +
            "plementation dependent which method will be called.";
        public MultipleOverridenMembersWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IOverridableMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Ambiguous {0}:{1}{2}match")]
    public class MultipleResolveCandidatesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Ambiguous {0}:{1}{2}match";
        public MultipleResolveCandidatesError(JetBrains.DocumentModel.DocumentRange textRange, string string1, string string2, JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string String1 { get; }
        public string String2 { get; }
        public JetBrains.DocumentModel.DocumentRange TextRange { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot access static {0} \'{1}\' in non-static context")]
    public class MultipleStaticElementInNonStaticContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access static {0} \'{1}\' in non-static context";
        public MultipleStaticElementInNonStaticContextError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, bool useElementType) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public bool UseElementType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Named arguments cannot precede positional")]
    public class NamedArgumentBeforePositionalError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Named arguments cannot precede positional";
        public NamedArgumentBeforePositionalError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Argument name is not allowed in delegate creation")]
    public class NamedArgumentInDelegateCreationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Argument name is not allowed in delegate creation";
        public NamedArgumentInDelegateCreationError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Arguments mismatch")]
    public class NamedArgumentListDoesnotMatchParametersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Arguments mismatch";
        public NamedArgumentListDoesnotMatchParametersError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Collection initializer element cannot be named")]
    public class NamedCollectionInitializerElementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Collection initializer element cannot be named";
        public NamedCollectionInitializerElementError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Namespace name expected")]
    public class NamespaceNameExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Namespace name expected";
        public NamespaceNameExpectedError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName ReferenceName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot create an array with a negative size")]
    public class NegativeArrayCreationParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot create an array with a negative size";
        public NegativeArrayCreationParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("NegativeEqualityExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Simplify negative equality expression")]
    public class NegativeEqualityExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "NegativeEqualityExpression";
        protected const string MESSAGE = "Simplify negative equality expression";
        public NegativeEqualityExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression unaryExpression, JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression equalityExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression EqualityExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression UnaryExpression { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use a negative size with stackalloc")]
    public class NegativeStackAllocSizeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use a negative size with stackalloc";
        public NegativeStackAllocSizeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression dimExpr) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression DimExpr { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Nested object initializer cannot be applied to properties with a value type, or t" +
        "o read-only fields with a value type")]
    public class NestedObjectInitializerAppliedToValueTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Nested object initializer cannot be applied to properties with a value type, or t" +
            "o read-only fields with a value type";
        public NestedObjectInitializerAppliedToValueTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0108", "CSHARP", CompilerIds=new string[] {
            "CS0108",
            "CS0114"}, CompilerIdsWithDescription="CS0108,CS0114:Keyword \'new\' is required", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The keyword \'new\' is required on \'{0}\' because it hides {1} \'{2}\'")]
    public class NewModifierIsRequiredWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0108";
        protected const string MESSAGE = "The keyword \'new\' is required on \'{0}\' because it hides {1} \'{2}\'";
        public NewModifierIsRequiredWarning(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember hiddenMember) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember HiddenMember { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0628", "CSHARP", CompilerIds=new string[] {
            "CS0628"}, CompilerIdsWithDescription="CS0628:Declaring new protected member in sealed class is the same as declaring it" +
        " as private", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Declaring new protected {0} \'{1}\' in sealed {2} is the same as declaring it as pr" +
        "ivate")]
    public class NewProtectedMemberInSealedClassWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0628";
        protected const string MESSAGE = "Declaring new protected {0} \'{1}\' in sealed {2} is the same as declaring it as pr" +
            "ivate";
        public NewProtectedMemberInSealedClassWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember typeMember, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare new protected {0} \'{1}\' in struct \'{2}")]
    public class NewProtectedMemberInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare new protected {0} \'{1}\' in struct \'{2}";
        public NewProtectedMemberInStructError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember typeMember, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Base class \'{0}\' doesn\'t contain parameterless constructor")]
    public class NoDefaultConstructorInBaseClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Base class \'{0}\' doesn\'t contain parameterless constructor";
        public NoDefaultConstructorInBaseClassError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration classDeclaration, JetBrains.ReSharper.Psi.IClass baseClass) { }
        public JetBrains.ReSharper.Psi.IClass BaseClass { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration ClassDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Either parameter or return type must be \'{0}\'")]
    public class NoEnclosingTypeInConversionOperatorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Either parameter or return type must be \'{0}\'";
        public NoEnclosingTypeInConversionOperatorError(JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="You must provide an initializer in a \'fixed\' statement declaration")]
    public class NoInitializerInUsingFixedDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "You must provide an initializer in a \'fixed\' statement declaration";
        public NoInitializerInUsingFixedDeclarationError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="You must provide an initializer in a \'using\' statement declaration")]
    public class NoInitializerInUsingVariableDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "You must provide an initializer in a \'using\' statement declaration";
        public NoInitializerInUsingVariableDeclarationError(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Accessor must declare a body because \'{0}\' is not marked as abstract or extern. A" +
        "utomatically implemented properties must define both \'get\' and \'set\' accessors.")]
    public class NonabstractAccessorWithoutBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Accessor must declare a body because \'{0}\' is not marked as abstract or extern. A" +
            "utomatically implemented properties must define both \'get\' and \'set\' accessors.";
        public NonabstractAccessorWithoutBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration typeMemberDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration TypeMemberDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Non-abstract and non-extern method must declare a body")]
    public class NonabstractMethodWithoutBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Non-abstract and non-extern method must declare a body";
        public NonabstractMethodWithoutBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot implicitly convert type \'{0}\' to \'System.IDisposable\'")]
    public class NonDisposableTypeInUsingStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot implicitly convert type \'{0}\' to \'System.IDisposable\'";
        public NonDisposableTypeInUsingStatementError(JetBrains.ReSharper.Psi.Tree.ITreeNode node, JetBrains.ReSharper.Psi.IExpressionType type) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType Type { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Non-extern operator must declare a body")]
    public class NonexternOperatorWithoutBodyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Non-extern operator must declare a body";
        public NonexternOperatorWithoutBodyError(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Bad array declarator: To declare a managed array the rank specifier precedes the " +
        "variable\'s identifier. To declare a fixed size buffer field, use the fixed keywo" +
        "rd before the field type")]
    public class NonFixedSizeArrayMustNotSizeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Bad array declarator: To declare a managed array the rank specifier precedes the " +
            "variable\'s identifier. To declare a fixed size buffer field, use the fixed keywo" +
            "rd before the field type";
        public NonFixedSizeArrayMustNotSizeError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Array creation expression parameter type should be \'int\', \'uint\', \'long\' or \'ulon" +
        "g\'")]
    public class NonIntegerArrayCreationParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Array creation expression parameter type should be \'int\', \'uint\', \'long\' or \'ulon" +
            "g\'";
        public NonIntegerArrayCreationParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be sealed because it is not an override")]
    public class NonOnverrideMemberCannotBeSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be sealed because it is not an override";
        public NonOnverrideMemberCannotBeSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be abstract")]
    public class NonPolymorphicMemberCannotBeAbstractError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be abstract";
        public NonPolymorphicMemberCannotBeAbstractError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be override")]
    public class NonPolymorphicMemberCannotBeOverrideError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be override";
        public NonPolymorphicMemberCannotBeOverrideError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be sealed")]
    public class NonPolymorphicMemberCannotBeSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be sealed";
        public NonPolymorphicMemberCannotBeSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be virtual")]
    public class NonPolymorphicMemberCannotBeVirtualError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be virtual";
        public NonPolymorphicMemberCannotBeVirtualError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("NonReadonlyFieldInGetHashCode", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Non-readonly field referenced in \'GetHashCode()\'")]
    public class NonReadonlyFieldInGetHashCodeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "NonReadonlyFieldInGetHashCode";
        protected const string MESSAGE = "Non-readonly field referenced in \'GetHashCode()\'";
        public NonReadonlyFieldInGetHashCodeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression, JetBrains.ReSharper.Psi.IField field) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IField Field { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression ReferenceExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' is not a reference type as required by the lock statement")]
    public class NonReferenceTypeInLockStatementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' is not a reference type as required by the lock statement";
        public NonReferenceTypeInLockStatementError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IExpressionType type) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType Type { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot access non-static {0} \'{1}\' in static context")]
    public class NonStaticElementInStaticContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access non-static {0} \'{1}\' in static context";
        public NonStaticElementInStaticContextError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static class \'{0}\' cannot have non-static {1} \'{2}\'")]
    public class NonstaticMemberInStaticClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static class \'{0}\' cannot have non-static {1} \'{2}\'";
        public NonstaticMemberInStaticClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration memberDeclaration, JetBrains.ReSharper.Psi.IClass element) { }
        public JetBrains.ReSharper.Psi.IClass Element { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration MemberDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleMultipleWriteAccessInDoubleCheckLocking", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible incorrect implementation of Double-Check Locking. Checked field must be " +
        "volatile or assigned from local variable after \'Thread.MemoryBarrier()\' call")]
    public class NonVolatileFieldInDoubleCheckLockingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleMultipleWriteAccessInDoubleCheckLocking";
        protected const string MESSAGE = "Possible incorrect implementation of Double-Check Locking. Checked field must be " +
            "volatile or assigned from local variable after \'Thread.MemoryBarrier()\' call";
        public NonVolatileFieldInDoubleCheckLockingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression ReferenceExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="There is no suitable {0} for override")]
    public class NoSuitableMemberForOverrideError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "There is no suitable {0} for override";
        public NoSuitableMemberForOverrideError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class NotAssignedVariablesUponExitError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public NotAssignedVariablesUponExitError(JetBrains.ReSharper.Psi.IDeclaredElement[] variables, JetBrains.ReSharper.Psi.Tree.ITreeNode exitElement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode ExitElement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement[] Variables { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' cannot implement {2} from interface \'{3}\'. Return type should be \'{4}\'." +
        "")]
    public class NotImplementAnotherReturnTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' cannot implement {2} from interface \'{3}\'. Return type should be \'{4}\'." +
            "";
        public NotImplementAnotherReturnTypeError(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredType iface, JetBrains.ReSharper.Psi.IType returnType, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMember) { }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType Iface { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMember { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Non-public {0} \'{1}\' cannot implement {0} from interface {2}")]
    public class NotImplementNotPublicError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Non-public {0} \'{1}\' cannot implement {0} from interface {2}";
        public NotImplementNotPublicError(JetBrains.ReSharper.Psi.ITypeMember declaredElement, JetBrains.ReSharper.Psi.IInterface iface, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.ITypeMember DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IInterface Iface { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMember { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' should not have a params parameter since \'{1}\' does not")]
    public class NotImplementParamsDiffersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' should not have a params parameter since \'{1}\' does not";
        public NotImplementParamsDiffersError(JetBrains.ReSharper.Psi.IParametersOwner inheritor, JetBrains.ReSharper.Psi.IParametersOwner superMember, JetBrains.ReSharper.Psi.IParameter parameter) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IParametersOwner Inheritor { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IParameter Parameter { get; }
        public JetBrains.ReSharper.Psi.IParametersOwner SuperMember { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static {0} \'{1}\' cannot implement {0} from interface {2}")]
    public class NotImplementStaticError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static {0} \'{1}\' cannot implement {0} from interface {2}";
        public NotImplementStaticError(JetBrains.ReSharper.Psi.ITypeMember declaredElement, JetBrains.ReSharper.Psi.IInterface iface, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.ITypeMember DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IInterface Iface { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMember { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Local variable \'{0}\' might not be initialized before accessing")]
    public class NotInitializedLocalVariableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Local variable \'{0}\' might not be initialized before accessing";
        public NotInitializedLocalVariableError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Out parameter \'{0}\' might not be initialized before accessing")]
    public class NotInitializedOutParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Out parameter \'{0}\' might not be initialized before accessing";
        public NotInitializedOutParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Struct field \'{0}\' might not be initialized before accessing")]
    public class NotInitializedStructFieldError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Struct field \'{0}\' might not be initialized before accessing";
        public NotInitializedStructFieldError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'this\' object cannot be used before all of its fields are assigned to")]
    public class NotInitializedThisInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'this\' object cannot be used before all of its fields are assigned to";
        public NotInitializedThisInStructError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The left-hand side of an assignment must be a variable, property or indexer")]
    public class NotLValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The left-hand side of an assignment must be a variable, property or indexer";
        public NotLValueError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method name is expected")]
    public class NotMethodAsDelegateCreationParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method name is expected";
        public NotMethodAsDelegateCreationParameterError(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A property without getter or inaccessible getter cannot be read")]
    public class NotReadablePropertyInMemberInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A property without getter or inaccessible getter cannot be read";
        public NotReadablePropertyInMemberInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IProperty property) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty Property { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Underlined Error Highlighting", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot resolve symbol \'{0}\'")]
    public class NotResolvedCollectionInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot resolve symbol \'{0}\'";
        public NotResolvedCollectionInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionElementInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionElementInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Underlined Error Highlighting", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot resolve \'{0}\' constructor call")]
    public class NotResolvedConstructorInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot resolve \'{0}\' constructor call";
        public NotResolvedConstructorInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", AttributeId="ReSharper Error Highlighting", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot resolve symbol \'{0}\'")]
    public class NotResolvedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot resolve symbol \'{0}\'";
        public NotResolvedError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1584", "CSHARP", AttributeId="ReSharper Error Highlighting", CompilerIds=new string[] {
            "CS1584",
            "CS1711",
            "CS1572",
            "CS1581",
            "CS1580"}, CompilerIdsWithDescription="CS1584,CS1711,CS1572,CS1581,CS1580:Cannot resolve reference in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.UNRESOLVED_ERROR, ToolTipFormatString="Cannot resolve symbol \'{0}\'")]
    public class NotResolvedInDocCommentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1584";
        protected const string MESSAGE = "Cannot resolve symbol \'{0}\'";
        public NotResolvedInDocCommentWarning(JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("NotResolvedInText", "CSHARP", AttributeId="ReSharper Error Highlighting", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Cannot resolve symbol \'{0}\'")]
    public class NotResolvedInTextWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "NotResolvedInText";
        protected const string MESSAGE = "Cannot resolve symbol \'{0}\'";
        public NotResolvedInTextWarning(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Only class or interface could be specified as constraint")]
    public class NotTypeOrInterfaceInTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Only class or interface could be specified as constraint";
        public NotTypeOrInterfaceInTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Public non-static read-write property or public non-static field which is not rea" +
        "donly or const expected")]
    public class NotVariableAsAttributeParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Public non-static read-write property or public non-static field which is not rea" +
            "donly or const expected";
        public NotVariableAsAttributeParameterError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A property without setter or inaccessible setter cannot be assigned to")]
    public class NotWritablePropertyInMemberInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A property without setter or inaccessible setter cannot be assigned to";
        public NotWritablePropertyInMemberInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IProperty property) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty Property { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' does not have type parameters")]
    public class NoTypeParametersInCandidateError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' does not have type parameters";
        public NoTypeParametersInCandidateError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList TypeArgumentList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Null as delegate creation parameter")]
    public class NullAsDelegateCreationParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Null as delegate creation parameter";
        public NullAsDelegateCreationParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConstantNullCoalescingCondition", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'??\' left operand is never null")]
    public class NullCoalescingConditionIsAlwaysNotNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConstantNullCoalescingCondition";
        protected const string MESSAGE = "\'??\' left operand is never null";
        public NullCoalescingConditionIsAlwaysNotNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConstantNullCoalescingCondition", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'??\' left operand is always null")]
    public class NullCoalescingConditionIsAlwaysNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConstantNullCoalescingCondition";
        protected const string MESSAGE = "\'??\' left operand is always null";
        public NullCoalescingConditionIsAlwaysNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ConstantNullCoalescingCondition", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'??\' right operand is always null")]
    public class NullCoalescingRightOperandIsAlwaysNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ConstantNullCoalescingCondition";
        protected const string MESSAGE = "\'??\' right operand is always null";
        public NullCoalescingRightOperandIsAlwaysNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Use of \'null\' is not valid in this context")]
    public class NullConstantInForeachError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Use of \'null\' is not valid in this context";
        public NullConstantInForeachError(JetBrains.ReSharper.Psi.Tree.IExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.IExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ObjectCreationAsStatement", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible unassigned object created by \'new\' expression")]
    public class ObjectCreationAsStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ObjectCreationAsStatement";
        protected const string MESSAGE = "Possible unassigned object created by \'new\' expression";
        public ObjectCreationAsStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Object and collection initializer expressions cannot be applied to a delegate cre" +
        "ation expression")]
    public class ObjectOrCollectionInitializerInDelegateCreationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Object and collection initializer expressions cannot be applied to a delegate cre" +
            "ation expression";
        public ObjectOrCollectionInitializerInDelegateCreationError(JetBrains.ReSharper.Psi.CSharp.Tree.ICreationExpressionInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICreationExpressionInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class ObsoleteElementError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public ObsoleteElementError(JetBrains.ReSharper.Psi.Resolve.IReference reference, string obsoleteMessage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ObsoleteMessage { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0618", "CSHARP", CompilerIds=new string[] {
            "CS0618"}, CompilerIdsWithDescription="CS0618:Use of obsolete symbol", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class ObsoleteElementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0618";
        protected const string MESSAGE = "{0}";
        public ObsoleteElementWarning(JetBrains.ReSharper.Psi.Resolve.IReference reference, string obsoleteMessage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ObsoleteMessage { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0612", "CSHARP", CompilerIds=new string[] {
            "CS0612"}, CompilerIdsWithDescription="CS0612:Use of obsolete symbol (without message)", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class ObsoleteElementWithoutMessageWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0612";
        protected const string MESSAGE = "{0}";
        public ObsoleteElementWithoutMessageWarning(JetBrains.ReSharper.Psi.Resolve.IReference reference, string obsoleteMessage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ObsoleteMessage { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Open type in using alias directive")]
    public class OpenTypeInUsingAliasError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Open type in using alias directive";
        public OpenTypeInUsingAliasError(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName ReferenceName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("OperatorIsCanBeUsed", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Operator \'is\' can be used")]
    public class OperatorIsCanBeUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "OperatorIsCanBeUsed";
        protected const string MESSAGE = "Operator \'is\' can be used";
        public OperatorIsCanBeUsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.IDeclaredType matchedType, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression matchedQualifier) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression MatchedQualifier { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType MatchedType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="User-defined operator must be declared static and public")]
    public class OperatorMustBePublicStaticError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "User-defined operator must be declared static and public";
        public OperatorMustBePublicStaticError(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Optional parameters must appear after all required parameters")]
    public class OptionalParameterBeforeRequiredError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Optional parameters must appear after all required parameters";
        public OptionalParameterBeforeRequiredError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("OptionalParameterHierarchyMismatch", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Optional parameter default value differs from parameter {0} in base {1} \'{2}\'")]
    public class OptionalParameterHierarchyMismatch_MismatchWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "OptionalParameterHierarchyMismatch";
        protected const string MESSAGE = "Optional parameter default value differs from parameter {0} in base {1} \'{2}\'";
        public OptionalParameterHierarchyMismatch_MismatchWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.IParameter baseParameter, JetBrains.ReSharper.Psi.IParametersOwner baseMember) { }
        public JetBrains.ReSharper.Psi.IParametersOwner BaseMember { get; }
        public JetBrains.ReSharper.Psi.IParameter BaseParameter { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("OptionalParameterHierarchyMismatch", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Parameter {0} in base {1} \'{2}\' has default value")]
    public class OptionalParameterHierarchyMismatch_MissingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "OptionalParameterHierarchyMismatch";
        protected const string MESSAGE = "Parameter {0} in base {1} \'{2}\' has default value";
        public OptionalParameterHierarchyMismatch_MissingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.IParameter baseParameter, JetBrains.ReSharper.Psi.IParametersOwner baseMember) { }
        public JetBrains.ReSharper.Psi.IParametersOwner BaseMember { get; }
        public JetBrains.ReSharper.Psi.IParameter BaseParameter { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A value of type \'{0}\' cannot be used as a default parameter because there are no " +
        "standard conversions to type \'{1}\'")]
    public class OptionalParameterIncompatibleTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A value of type \'{0}\' cannot be used as a default parameter because there are no " +
            "standard conversions to type \'{1}\'";
        public OptionalParameterIncompatibleTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.IType parameterType, JetBrains.ReSharper.Psi.Tree.IExpression expression, JetBrains.ReSharper.Psi.IExpressionType expressionType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.IExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public JetBrains.ReSharper.Psi.IType ParameterType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' is of type \'{1}\'. A default parameter value of a reference type other than " +
        "string can only be initialized with null")]
    public class OptionalParameterInvalidReferenceValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' is of type \'{1}\'. A default parameter value of a reference type other than " +
            "string can only be initialized with null";
        public OptionalParameterInvalidReferenceValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Default parameter value for \'{0}\' must be a compile-time constant")]
    public class OptionalParameterInvalidStringValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Default parameter value for \'{0}\' must be a compile-time constant";
        public OptionalParameterInvalidStringValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Default parameter value for \'{0}\' must be a compile-time constant")]
    public class OptionalParameterInvalidValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Default parameter value for \'{0}\' must be a compile-time constant";
        public OptionalParameterInvalidValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A \'ref\' or \'out\' parameter cannot have a default value")]
    public class OptionalParameterRefOutError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A \'ref\' or \'out\' parameter cannot have a default value";
        public OptionalParameterRefOutError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("OptionalParameterRefOut", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="A \'ref\' or \'out\' parameter cannot have a default value")]
    public class OptionalParameterRefOutWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "OptionalParameterRefOut";
        protected const string MESSAGE = "A \'ref\' or \'out\' parameter cannot have a default value";
        public OptionalParameterRefOutWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A partial method cannot have out parameters")]
    public class OutParameterInPartialMethodError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A partial method cannot have out parameters";
        public OutParameterInPartialMethodError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter cannot have both \'params\' and \'out\' modifiers")]
    public class OutParamsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter cannot have both \'params\' and \'out\' modifiers";
        public OutParamsError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' argument is not classified as a variable")]
    public class OutRefArgumentIsNotVariableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' argument is not classified as a variable";
        public OutRefArgumentIsNotVariableError(string kind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public string Kind { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0420", "CSHARP", CompilerIds=new string[] {
            "CS0420"}, CompilerIdsWithDescription="CS0420:Reference to a volatile field will not be treated as volatile", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'{0}\' argument is volatile field, reference to it will not be treated as volatile" +
        "")]
    public class OutRefArgumentIsVolatileFieldWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0420";
        protected const string MESSAGE = "\'{0}\' argument is volatile field, reference to it will not be treated as volatile" +
            "";
        public OutRefArgumentIsVolatileFieldWarning(string kind, JetBrains.ReSharper.Psi.IField field, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IField Field { get; }
        public string Kind { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Overflow in constant value computation")]
    public class OverflowConstantValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Overflow in constant value computation";
        public OverflowConstantValueError(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be readonly")]
    public class OverridableMemberCannotBeReadonlyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be readonly";
        public OverridableMemberCannotBeReadonlyError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} cannot be volatile")]
    public class OverridableMemberCannotBeVolatileError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} cannot be volatile";
        public OverridableMemberCannotBeVolatileError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Cannot override inherited {0} \'{1}\' because it is sealed")]
    public class OverrideFromSealedMemberError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot override inherited {0} \'{1}\' because it is sealed";
        public OverrideFromSealedMemberError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IOverridableMember overridenMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember OverridenMember { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Keyword \'override\' is missing")]
    public class OverrideKeywordIsMissingError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Keyword \'override\' is missing";
        public OverrideKeywordIsMissingError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IOverridableMember overridenMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember OverridenMember { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Override {0} cannot be marked as new")]
    public class OverrideMemberCannotBeNewError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Override {0} cannot be marked as new";
        public OverrideMemberCannotBeNewError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Override {0} cannot be marked as virtual")]
    public class OverrideMemberCannotBeVirtualError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Override {0} cannot be marked as virtual";
        public OverrideMemberCannotBeVirtualError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Override {0} \'{1}\' cannot change access rights")]
    public class OverrideMemberChangeAccessRightsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Override {0} \'{1}\' cannot change access rights";
        public OverrideMemberChangeAccessRightsError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Constraints for override method are inherited from the base method, so they canno" +
        "t be specified directly")]
    public class OverridenMethodCannotHasTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Constraints for override method are inherited from the base method, so they canno" +
            "t be specified directly";
        public OverridenMethodCannotHasTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause constraint) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause Constraint { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0672", "CSHARP", CompilerIds=new string[] {
            "CS0672"}, CompilerIdsWithDescription="CS0672:Member overrides obsolete member", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0} \'{1}\' overrides obsolete {2} \'{3}\'. Add the Obsolete attribute to \'{4}\'.")]
    public class OverrideObsoleteMemberWithoutObsoleteAttributeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0672";
        protected const string MESSAGE = "{0} \'{1}\' overrides obsolete {2} \'{3}\'. Add the Obsolete attribute to \'{4}\'.";
        public OverrideObsoleteMemberWithoutObsoleteAttributeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IClassMemberDeclaration declaration, JetBrains.ReSharper.Psi.IOverridableMember member, JetBrains.ReSharper.Psi.IOverridableMember overridenMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IOverridableMember OverridenMember { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0659", "CSHARP", CompilerIds=new string[] {
            "CS0659"}, CompilerIdsWithDescription="CS0659:Class overrides Object.Equals(object o) but not Object.GetHashCode()", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'{0}\' overrides Object.Equals(object o) but does not override Object.GetHashCode(" +
        ")")]
    public class OverridesEqualsWithoutGetHashCodeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0659";
        protected const string MESSAGE = "\'{0}\' overrides Object.Equals(object o) but does not override Object.GetHashCode(" +
            ")";
        public OverridesEqualsWithoutGetHashCodeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement containingType) { }
        public JetBrains.ReSharper.Psi.ITypeElement ContainingType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ParameterHidesMember", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Parameter \'{0}\' hides {1} \'{2}\'")]
    public class ParameterHidesMemberWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ParameterHidesMember";
        protected const string MESSAGE = "Parameter \'{0}\' hides {1} \'{2}\'";
        public ParameterHidesMemberWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.ITypeMember hiddenMember) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember HiddenMember { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Struct cannot contain explicit parameterless constructor")]
    public class ParameterlessConstructorInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Struct cannot contain explicit parameterless constructor";
        public ParameterlessConstructorInStructError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1573", "CSHARP", CompilerIds=new string[] {
            "CS1573"}, CompilerIdsWithDescription="CS1573:Parameter has no matching param tag in the XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Parameter \'{0}\' has no matching param tag in the XML comment for {1} (but other p" +
        "arameters do)")]
    public class ParameterNotDocumentedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1573";
        protected const string MESSAGE = "Parameter \'{0}\' has no matching param tag in the XML comment for {1} (but other p" +
            "arameters do)";
        public ParameterNotDocumentedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration declaration, JetBrains.ReSharper.Psi.IParametersOwner owner) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IParametersOwner Owner { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static constructor must be parameterless")]
    public class ParametersInStaticConstructorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static constructor must be parameterless";
        public ParametersInStaticConstructorError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAssignment", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The value passed to the method is never used because it is overwritten in the met" +
        "hod body before being read")]
    public class ParameterValueIsOverridenWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAssignment";
        protected const string MESSAGE = "The value passed to the method is never used because it is overwritten in the met" +
            "hod body before being read";
        public ParameterValueIsOverridenWarning(JetBrains.ReSharper.Psi.Tree.IParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter type with caller info must be implicitly convertible to \'{0}\'")]
    public class ParameterWithCallerInfoHasWrongTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter type with caller info must be implicitly convertible to \'{0}\'";
        public ParameterWithCallerInfoHasWrongTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.IType type) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType Type { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter with caller info must have default value")]
    public class ParameterWithCallerInfoMustHaveDefaultValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter with caller info must have default value";
        public ParameterWithCallerInfoMustHaveDefaultValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter with \'params\' modifier must have an array type")]
    public class ParamsButNotArrayError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter with \'params\' modifier must have an array type";
        public ParamsButNotArrayError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'params\' parameter must be a single dimensional array")]
    public class ParamsMultiDimArrayError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'params\' parameter must be a single dimensional array";
        public ParamsMultiDimArrayError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A \'params\' parameter must be the last parameter in a formal parameter list")]
    public class ParamsMustBeLastError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A \'params\' parameter must be the last parameter in a formal parameter list";
        public ParamsMustBeLastError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Operator cannot have \'params\' parameter")]
    public class ParamsParameterInOperatorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Operator cannot have \'params\' parameter";
        public ParamsParameterInOperatorError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A params parameter must be the last parameter in a formal parameter list")]
    public class ParamsParameterNotLastError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A params parameter must be the last parameter in a formal parameter list";
        public ParamsParameterNotLastError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot specify a default value for a parameter array")]
    public class ParamsWithDefaultValueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot specify a default value for a parameter array";
        public ParamsWithDefaultValueError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Partially opened type is not permitted in \'typeof\' expression")]
    public class PartiallyOpenedTypeInTypeofExpressionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Partially opened type is not permitted in \'typeof\' expression";
        public PartiallyOpenedTypeInTypeofExpressionError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeofExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeofExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A partial method must be declared within a partial class or partial struct")]
    public class PartialMethodInNonPartialTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A partial method must be declared within a partial class or partial struct";
        public PartialMethodInNonPartialTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PartialMethodParameterNameMismatch", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Parameter name differs in partial method declaration")]
    public class PartialMethodParameterNameMismatchWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PartialMethodParameterNameMismatch";
        protected const string MESSAGE = "Parameter name differs in partial method declaration";
        public PartialMethodParameterNameMismatchWarning(JetBrains.ReSharper.Psi.Tree.IParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Partial methods must have a void return type")]
    public class PartialMethodReturnShouldBeVoidError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Partial methods must have a void return type";
        public PartialMethodReturnShouldBeVoidError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Both partial method declarations must be static or neither may be static")]
    public class PartialMethodStaticMismatch2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Both partial method declarations must be static or neither may be static";
        public PartialMethodStaticMismatch2Error(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Both partial method declarations must be static or neither may be static")]
    public class PartialMethodStaticMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Both partial method declarations must be static or neither may be static";
        public PartialMethodStaticMismatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Both partial method declarations must be unsafe or neither may be unsafe")]
    public class PartialMethodUnsafeMismatch2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Both partial method declarations must be unsafe or neither may be unsafe";
        public PartialMethodUnsafeMismatch2Error(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Both partial method declarations must be unsafe or neither may be unsafe")]
    public class PartialMethodUnsafeMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Both partial method declarations must be unsafe or neither may be unsafe";
        public PartialMethodUnsafeMismatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="No defining declaration found for implementing declaration of partial method \'{0}" +
        "\'")]
    public class PartialMethodWithoutDefiningDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "No defining declaration found for implementing declaration of partial method \'{0}" +
            "\'";
        public PartialMethodWithoutDefiningDeclarationError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.IMethod element) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IMethod Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PartialMethodWithSinglePart", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Partial method without implementing declaration")]
    public class PartialMethodWithSinglePartWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PartialMethodWithSinglePart";
        protected const string MESSAGE = "Partial method without implementing declaration";
        public PartialMethodWithSinglePartWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'partial\' token should immediately precede \'class\', \'struct\' of \'interface\'")]
    public class PartialModifierMustBeLastError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'partial\' token should immediately precede \'class\', \'struct\' of \'interface\'";
        public PartialModifierMustBeLastError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PartialTypeWithSinglePart", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Partial {0} with single part")]
    public class PartialTypeWithSinglePartWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PartialTypeWithSinglePart";
        protected const string MESSAGE = "Partial {0} with single part";
        public PartialTypeWithSinglePartWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    public class static PerformanceHighlightingGroupIds
    {
        public const string PerformanceHints = "PerformanceHints";
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'->\' operator must be applied to a pointer")]
    public class PointerAccessToNotPointerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'->\' operator must be applied to a pointer";
        public PointerAccessToNotPointerTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerAccessExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerAccessExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'*\' operator must be applied to a pointer")]
    public class PointerIndirectionOfNotPointerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'*\' operator must be applied to a pointer";
        public PointerIndirectionOfNotPointerTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerIndirectionExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerIndirectionExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Pointers may only be used in an unsafe context")]
    public class PointerInSafeContext2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Pointers may only be used in an unsafe context";
        public PointerInSafeContext2Error(JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo argumentInfo) { }
        public JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo ArgumentInfo { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Pointers may only be used in an unsafe context")]
    public class PointerInSafeContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Pointers may only be used in an unsafe context";
        public PointerInSafeContextError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type \'{0}\' cannot be used as a type argument")]
    public class PointerInTypeArgumentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type \'{0}\' cannot be used as a type argument";
        public PointerInTypeArgumentError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange argumentRange) { }
        public JetBrains.DocumentModel.DocumentRange ArgumentRange { get; }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare pointer to non-unmanaged type \'{0}\'")]
    public class PointerToNonUnmanagedTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare pointer to non-unmanaged type \'{0}\'";
        public PointerToNonUnmanagedTypeError(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Psi.IExpressionType elementType) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ElementType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PolymorphicFieldLikeEventInvocation", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Invocation of polymorphic field-like event")]
    public class PolymorphicFieldLikeEventInvocationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PolymorphicFieldLikeEventInvocation";
        protected const string MESSAGE = "Invocation of polymorphic field-like event";
        public PolymorphicFieldLikeEventInvocationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Overridable {0} cannot be static")]
    public class PolymorphicMemberCannotBeStaticError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Overridable {0} cannot be static";
        public PolymorphicMemberCannotBeStaticError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleAssignmentToReadonlyField", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Assignment to a property of a readonly field can be useless. Field type is not kn" +
        "own to be reference type.")]
    public class PossibleAssignmentToReadonlyFieldWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleAssignmentToReadonlyField";
        protected const string MESSAGE = "Assignment to a property of a readonly field can be useless. Field type is not kn" +
            "own to be reference type.";
        public PossibleAssignmentToReadonlyFieldWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleIntendedRethrow", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Exception rethrow possibly intended")]
    public class PossibleIntendedRethrowWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleIntendedRethrow";
        protected const string MESSAGE = "Exception rethrow possibly intended";
        public PossibleIntendedRethrowWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleInterfaceMemberAmbiguity", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible ambiguity while accessing by this interface:{0}")]
    public class PossibleInterfaceMemberAmbiguityWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleInterfaceMemberAmbiguity";
        protected const string MESSAGE = "Possible ambiguity while accessing by this interface:{0}";
        public PossibleInterfaceMemberAmbiguityWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration declaration, JetBrains.ReSharper.Psi.TypeMemberInstance[] members) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance[] Members { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleInvalidCastException", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible \'System.InvalidCastException\'")]
    public class PossibleInvalidCastExceptionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleInvalidCastException";
        protected const string MESSAGE = "Possible \'System.InvalidCastException\'";
        public PossibleInvalidCastExceptionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleInvalidOperationException", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible \'System.InvalidOperationException\'")]
    public class PossibleInvalidOperationExceptionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleInvalidOperationException";
        protected const string MESSAGE = "Possible \'System.InvalidOperationException\'";
        public PossibleInvalidOperationExceptionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rangeExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RangeExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleLossOfFraction", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible loss of fraction")]
    public class PossibleLossOfFractionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleLossOfFraction";
        protected const string MESSAGE = "Possible loss of fraction";
        public PossibleLossOfFractionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMultiplicativeExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMultiplicativeExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleMultipleEnumeration", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible multiple enumeration of IEnumerable")]
    public class PossibleMultipleEnumerationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleMultipleEnumeration";
        protected const string MESSAGE = "Possible multiple enumeration of IEnumerable";
        public PossibleMultipleEnumerationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression usage, System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression> allUsages) { }
        public System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression> AllUsages { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Usage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleMultipleWriteAccessInDoubleCheckLocking", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible incorrect implementation of Double-Check Locking. Possible multiple writ" +
        "e access to checked field")]
    public class PossibleMultipleWriteAccessInDoubleCheckLockingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleMultipleWriteAccessInDoubleCheckLocking";
        protected const string MESSAGE = "Possible incorrect implementation of Double-Check Locking. Possible multiple writ" +
            "e access to checked field";
        public PossibleMultipleWriteAccessInDoubleCheckLockingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression ReferenceExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleNullReferenceException", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible \'System.NullReferenceException\'")]
    public class PossibleNullReferenceExceptionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleNullReferenceException";
        protected const string MESSAGE = "Possible \'System.NullReferenceException\'";
        public PossibleNullReferenceExceptionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression rangeExpression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression RangeExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossibleUnintendedReferenceComparison", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible unintended reference comparison; to get a value comparison, use \'Equals\'" +
        " method")]
    public class PossibleUnintendedReferenceComparisonUseEqualsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossibleUnintendedReferenceComparison";
        protected const string MESSAGE = "Possible unintended reference comparison; to get a value comparison, use \'Equals\'" +
            " method";
        public PossibleUnintendedReferenceComparisonUseEqualsWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0252", "CSHARP", CompilerIds=new string[] {
            "CS0252",
            "CS0253"}, CompilerIdsWithDescription="CS0252,CS0253:Possible unintended reference comparison", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible unintended reference comparison; to get a value comparison, cast the {0}" +
        " hand side to type \'{1}\'")]
    public class PossibleUnintendedReferenceComparisonWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0252";
        protected const string MESSAGE = "Possible unintended reference comparison; to get a value comparison, cast the {0}" +
            " hand side to type \'{1}\'";
        public PossibleUnintendedReferenceComparisonWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression expression, string side, JetBrains.ReSharper.Psi.IType valueType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string Side { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType ValueType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PossiblyMistakenUseOfParamsMethod", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Method with \'params\' is invoked. Have you intended to call more specific method \'" +
        "{0}\'?")]
    public class PossiblyMistakenUseOfParamsMethodWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PossiblyMistakenUseOfParamsMethod";
        protected const string MESSAGE = "Method with \'params\' is invoked. Have you intended to call more specific method \'" +
            "{0}\'?";
        public PossiblyMistakenUseOfParamsMethodWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.IMethod specificMethod, JetBrains.DocumentModel.DocumentRange expandedArgumentsRange) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.DocumentModel.DocumentRange ExpandedArgumentsRange { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IMethod SpecificMethod { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A previous catch clause already catches all exceptions of this or of a super type" +
        " (\'{0}\')")]
    public class PreviousCatchClauseHandlesThisTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A previous catch clause already catches all exceptions of this or of a super type" +
            " (\'{0}\')";
        public PreviousCatchClauseHandlesThisTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause clause, JetBrains.ReSharper.Psi.IDeclaredType exceptionType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause Clause { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType ExceptionType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PrivateFieldCanBeConvertedToLocalVariable", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The field is always assigned before being used and can be converted to local vari" +
        "able")]
    public class PrivateFieldCanBeConvertedToLocalVariableWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PrivateFieldCanBeConvertedToLocalVariable";
        protected const string MESSAGE = "The field is always assigned before being used and can be converted to local vari" +
            "able";
        public PrivateFieldCanBeConvertedToLocalVariableWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration FieldDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Private {0} cannot be polymorphic")]
    public class PrivateMemberCannotBePolymorhicError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Private {0} cannot be polymorphic";
        public PrivateMemberCannotBePolymorhicError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' cannot implement {2} from interface \'{3}\'. Type should be \'{4}\'.")]
    public class PropertyNotImplementAnotherReturnTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' cannot implement {2} from interface \'{3}\'. Type should be \'{4}\'.";
        public PropertyNotImplementAnotherReturnTypeError(JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredType iface, JetBrains.ReSharper.Psi.IType returnType, JetBrains.ReSharper.Psi.TypeMemberInstance interfaceMember) { }
        public JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType Iface { get; }
        public JetBrains.ReSharper.Psi.TypeMemberInstance InterfaceMember { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ReturnType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PublicConstructorInAbstractClass", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Convert constructor to protected")]
    public class PublicConstructorInAbstractClassWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PublicConstructorInAbstractClass";
        protected const string MESSAGE = "Convert constructor to protected";
        public PublicConstructorInAbstractClassWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration constructorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration ConstructorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1591", "CSHARP", CompilerIds=new string[] {
            "CS1591"}, CompilerIdsWithDescription="CS1591:Missing XML comment for publicly visible type or member", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Missing XML comment for publicly visible type or member \'{0}\'")]
    public class PublicOrProtectedMemberNotDocumentedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1591";
        protected const string MESSAGE = "Missing XML comment for publicly visible type or member \'{0}\'";
        public PublicOrProtectedMemberNotDocumentedWarning(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("PureAttributeOnVoidMethod", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Annotating \'void\' method by [Pure] is meaningless")]
    public class PureAttributeOnVoidMethodWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "PureAttributeOnVoidMethod";
        protected const string MESSAGE = "Annotating \'void\' method by [Pure] is meaningless";
        public PureAttributeOnVoidMethodWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type arguments for method \'{0}\' cannot be inferred from the query.")]
    public class QueryTypeInferenceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type arguments for method \'{0}\' cannot be inferred from the query.";
        public QueryTypeInferenceError(JetBrains.ReSharper.Psi.Resolve.IReference Reference, JetBrains.ReSharper.Psi.IMethod method) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IMethod Method { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type arguments cannot be inferred from the query. \\nCandidates are:{0}")]
    public class QueryTypeInferenceMultipleCandidatesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type arguments cannot be inferred from the query. \nCandidates are:{0}";
        public QueryTypeInferenceMultipleCandidatesError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IMethod[] methods) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IMethod[] Methods { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ReadAccessInDoubleCheckLocking", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Possible incorrect implementation of Double-Check Locking. Read access to checked" +
        " field")]
    public class ReadAccessInDoubleCheckLockingWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ReadAccessInDoubleCheckLocking";
        protected const string MESSAGE = "Possible incorrect implementation of Double-Check Locking. Read access to checked" +
            " field";
        public ReadAccessInDoubleCheckLockingWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression ReferenceExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The {0} \'{1}\' has no getter")]
    public class ReadAccessToPropertyWithoutGetterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The {0} \'{1}\' has no getter";
        public ReadAccessToPropertyWithoutGetterError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IProperty property) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty Property { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Readonly {0} cannot be used as an assignment target")]
    public class ReadonlyAssignmentTargetError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Readonly {0} cannot be used as an assignment target";
        public ReadonlyAssignmentTargetError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression destination, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Destination { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A readonly field cannot be assigned to (except in a constructor or a variable ini" +
        "tializer)")]
    public class ReadonlyFieldInMemberInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A readonly field cannot be assigned to (except in a constructor or a variable ini" +
            "tializer)";
        public ReadonlyFieldInMemberInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IField field) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IField Field { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAnonymousTypePropertyName", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant explicit property name")]
    public class RedundantAnonymousTypePropertyNameWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAnonymousTypePropertyName";
        protected const string MESSAGE = "Redundant explicit property name";
        public RedundantAnonymousTypePropertyNameWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantArgumentDefaultValue", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="The parameter {0} has the same default value")]
    public class RedundantArgumentDefaultValueWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantArgumentDefaultValue";
        protected const string MESSAGE = "The parameter {0} has the same default value";
        public RedundantArgumentDefaultValueWarning(JetBrains.ReSharper.Psi.IParameter parameter, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IParameter Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantArgumentNameForLiteralExpression", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant argument name specification")]
    public class RedundantArgumentNameForLiteralExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantArgumentNameForLiteralExpression";
        protected const string MESSAGE = "Redundant argument name specification";
        public RedundantArgumentNameForLiteralExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantArgumentName", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant argument name specification")]
    public class RedundantArgumentNameWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantArgumentName";
        protected const string MESSAGE = "Redundant argument name specification";
        public RedundantArgumentNameWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantArrayCreationExpression", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant array creation expression")]
    public class RedundantArrayCreationExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantArrayCreationExpression";
        protected const string MESSAGE = "Redundant array creation expression";
        public RedundantArrayCreationExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression arrayCreationExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression ArrayCreationExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCast", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Type cast is redundant")]
    public class RedundantAsCastWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCast";
        protected const string MESSAGE = "Type cast is redundant";
        public RedundantAsCastWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAsExpression node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAsExpression Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAttributeParentheses", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Parentheses are redundant if attribute has no arguments")]
    public class RedundantAttributeParenthesesWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAttributeParentheses";
        protected const string MESSAGE = "Parentheses are redundant if attribute has no arguments";
        public RedundantAttributeParenthesesWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantBaseConstructorCall", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant base constructor call")]
    public class RedundantBaseConstructorCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantBaseConstructorCall";
        protected const string MESSAGE = "Redundant base constructor call";
        public RedundantBaseConstructorCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer constructorInitializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer ConstructorInitializer { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantBaseQualifier", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Qualifier \'base.\' is redundant")]
    public class RedundantBaseQualifierWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantBaseQualifier";
        protected const string MESSAGE = "Qualifier \'base.\' is redundant";
        public RedundantBaseQualifierWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantBoolCompare", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Comparison with {0} is redundant")]
    public class RedundantBooleanComparisonWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantBoolCompare";
        protected const string MESSAGE = "Comparison with {0} is redundant";
        public RedundantBooleanComparisonWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression expression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression literal) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression Expression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Literal { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCaseLabel", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, OverloadResolvePriority=10, ToolTipFormatString="Redundant case label")]
    public class RedundantCaseLabelWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCaseLabel";
        protected const string MESSAGE = "Redundant case label";
        public RedundantCaseLabelWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement label) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement Label { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCast", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Type cast is redundant")]
    public class RedundantCastWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCast";
        protected const string MESSAGE = "Type cast is redundant";
        public RedundantCastWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCatchClause", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Catch clause is redundant")]
    public class RedundantCatchClauseWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCatchClause";
        protected const string MESSAGE = "Catch clause is redundant";
        public RedundantCatchClauseWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause clause) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause Clause { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCheckBeforeAssignment", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Redundant check before assignment")]
    public class RedundantCheckBeforeAssignmentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCheckBeforeAssignment";
        protected const string MESSAGE = "Redundant check before assignment";
        public RedundantCheckBeforeAssignmentWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement IfStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCollectionInitializerElementBraces", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant braces")]
    public class RedundantCollectionInitializerElementBracesWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCollectionInitializerElementBraces";
        protected const string MESSAGE = "Redundant braces";
        public RedundantCollectionInitializerElementBracesWarning(JetBrains.ReSharper.Psi.Tree.ITokenNode brace) { }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Brace { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantCommaInArrayInitializer", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant comma in array initializer")]
    public class RedundantCommaInArrayInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantCommaInArrayInitializer";
        protected const string MESSAGE = "Redundant comma in array initializer";
        public RedundantCommaInArrayInitializerWarning(JetBrains.ReSharper.Psi.Tree.ITokenNode commaToken) { }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode CommaToken { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantComparisonWithNull", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant comparison with \'null\'")]
    public class RedundantComparisonWithNullWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantComparisonWithNull";
        protected const string MESSAGE = "Redundant comparison with \'null\'";
        public RedundantComparisonWithNullWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantOverload.Global", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Redundant constructor declaration")]
    public class RedundantConstructorGlobalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantConstructorWarningBase
    {
        public const string HIGHLIGHTING_ID = "RedundantOverload.Global";
        public RedundantConstructorGlobalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration declaration, JetBrains.ReSharper.Psi.IConstructor overloadConstructor) { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantOverload.Local", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Redundant constructor declaration")]
    public class RedundantConstructorLocalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantConstructorWarningBase
    {
        public const string HIGHLIGHTING_ID = "RedundantOverload.Local";
        public RedundantConstructorLocalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration declaration, JetBrains.ReSharper.Psi.IConstructor overloadConstructor) { }
    }
    public abstract class RedundantConstructorWarningBase : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Redundant constructor declaration";
        public RedundantConstructorWarningBase(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration declaration, JetBrains.ReSharper.Psi.IConstructor overloadConstructor) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IConstructor OverloadConstructor { get; }
        public string ToolTip { get; }
        public static JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantConstructorWarningBase Create(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration declaration, JetBrains.ReSharper.Psi.IConstructor overloadConstructor, bool isGlobal) { }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantDefaultFieldInitializer", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Initializing field by default value is redundant")]
    public class RedundantDefaultFieldInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantDefaultFieldInitializer";
        protected const string MESSAGE = "Initializing field by default value is redundant";
        public RedundantDefaultFieldInitializerWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration FieldDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantDelegateCreation", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant explicit delegate creation")]
    public class RedundantDelegateCreationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantDelegateCreation";
        protected const string MESSAGE = "Redundant explicit delegate creation";
        public RedundantDelegateCreationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantEmptyDefaultSwitchBranch", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant empty default switch branch")]
    public class RedundantEmptyDefaultSwitchBranchWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantEmptyDefaultSwitchBranch";
        protected const string MESSAGE = "Redundant empty default switch branch";
        public RedundantEmptyDefaultSwitchBranchWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement defaultStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement breakStatement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement BreakStatement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement DefaultStatement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantEmptyFinallyBlock", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant empty finally block")]
    public class RedundantEmptyFinallyBlockWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantEmptyFinallyBlock";
        protected const string MESSAGE = "Redundant empty finally block";
        public RedundantEmptyFinallyBlockWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantEmptyObjectCreationArgumentList", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty argument list is redundant")]
    public class RedundantEmptyObjectCreationArgumentListWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantEmptyObjectCreationArgumentList";
        protected const string MESSAGE = "Empty argument list is redundant";
        public RedundantEmptyObjectCreationArgumentListWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantEmptyObjectOrCollectionInitializer", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Empty object or collection initializer list is redundant")]
    public class RedundantEmptyObjectOrCollectionInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantEmptyObjectOrCollectionInitializer";
        protected const string MESSAGE = "Empty object or collection initializer list is redundant";
        public RedundantEmptyObjectOrCollectionInitializerWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICreationExpressionInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICreationExpressionInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantEnumerableCastCall", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'IEnumerable.Cast<T>\' call")]
    public class RedundantEnumerableCastCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantEnumerableCastCall";
        protected const string MESSAGE = "Redundant \'IEnumerable.Cast<T>\' call";
        public RedundantEnumerableCastCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IMethod method) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IMethod Method { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantEnumerableCastCall", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Redundant \'IEnumerable.OfType<T>\' call. Consider comparing with \'null\' instead")]
    public class RedundantEnumerableOfTypeCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantEnumerableCastCall";
        protected const string MESSAGE = "Redundant \'IEnumerable.OfType<T>\' call. Consider comparing with \'null\' instead";
        public RedundantEnumerableOfTypeCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression, JetBrains.ReSharper.Psi.IMethod method) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public JetBrains.ReSharper.Psi.IMethod Method { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantExplicitArrayCreation", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant explicit array type specification")]
    public class RedundantExplicitArrayCreationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantExplicitArrayCreation";
        protected const string MESSAGE = "Redundant explicit array type specification";
        public RedundantExplicitArrayCreationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression arrayCreationExpression) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression ArrayCreationExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantExplicitArraySize", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant explicit array size specification")]
    public class RedundantExplicitArraySizeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantExplicitArraySize";
        protected const string MESSAGE = "Redundant explicit array size specification";
        public RedundantExplicitArraySizeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression sizeExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression SizeExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantExplicitNullableCreation", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant explicit nullable type creation")]
    public class RedundantExplicitNullableCreationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantExplicitNullableCreation";
        protected const string MESSAGE = "Redundant explicit nullable type creation";
        public RedundantExplicitNullableCreationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantIfElseBlock", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'else\' block")]
    public class RedundantIfElseBlockWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantIfElseBlock";
        protected const string MESSAGE = "Redundant \'else\' block";
        public RedundantIfElseBlockWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantIfElseBlock", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'else\' keyword")]
    public class RedundantIfElseKeywordWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantIfElseBlock";
        protected const string MESSAGE = "Redundant \'else\' keyword";
        public RedundantIfElseKeywordWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantJumpStatement", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant control flow jump statement")]
    public class RedundantJumpStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantJumpStatement";
        protected const string MESSAGE = "Redundant control flow jump statement";
        public RedundantJumpStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantLambdaParameterType", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant lambda parameter explicit type specification")]
    public class RedundantLambdaParameterTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantLambdaParameterType";
        protected const string MESSAGE = "Redundant lambda parameter explicit type specification";
        public RedundantLambdaParameterTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantLambdaSignatureParentheses", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant lambda signature parentheses")]
    public class RedundantLambdaSignatureParenthesesWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantLambdaSignatureParentheses";
        protected const string MESSAGE = "Redundant lambda signature parentheses";
        public RedundantLambdaSignatureParenthesesWarning(JetBrains.ReSharper.Psi.Tree.ITreeNode parantheses) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Parantheses { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantLogicalConditionalExpressionOperand", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant operand in logical conditional expression")]
    public class RedundantLogicalConditionalExpressionOperandWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantLogicalConditionalExpressionOperand";
        protected const string MESSAGE = "Redundant operand in logical conditional expression";
        public RedundantLogicalConditionalExpressionOperandWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryExpression conditionalExpression, JetBrains.ReSharper.Psi.Tree.IExpression operand) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryExpression ConditionalExpression { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.IExpression Operand { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0109", "CSHARP", AttributeId="ReSharper Dead Code", CompilerIds=new string[] {
            "CS0109"}, CompilerIdsWithDescription="CS0109:Keyword \'new\' is redundant", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="The keyword \'new\' is redundant because {0} \'{1}\' hides nothing")]
    public class RedundantNewModifierWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0109";
        protected const string MESSAGE = "The keyword \'new\' is redundant because {0} \'{1}\' hides nothing";
        public RedundantNewModifierWarning(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantOverload.Global", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Redundant method overload")]
    public class RedundantOverloadGlobalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantOverloadWarningBase
    {
        public const string HIGHLIGHTING_ID = "RedundantOverload.Global";
        public RedundantOverloadGlobalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.IMethod overloadMethod) { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantOverload.Local", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Redundant method overload")]
    public class RedundantOverloadLocalWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantOverloadWarningBase
    {
        public const string HIGHLIGHTING_ID = "RedundantOverload.Local";
        public RedundantOverloadLocalWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.IMethod overloadMethod) { }
    }
    public abstract class RedundantOverloadWarningBase : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Redundant method overload";
        public RedundantOverloadWarningBase(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.IMethod overloadMethod) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IMethod OverloadMethod { get; }
        public string ToolTip { get; }
        public static JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantOverloadWarningBase Create(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, JetBrains.ReSharper.Psi.IMethod overloadMethod, bool isGlobal) { }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantOverridenMember", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant {0} override")]
    public class RedundantOverridenMemberWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantOverridenMember";
        protected const string MESSAGE = "Redundant {0} override";
        public RedundantOverridenMemberWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantParams", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'params\' modifier is always ignored on overrides")]
    public class RedundantParamsWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantParams";
        protected const string MESSAGE = "\'params\' modifier is always ignored on overrides";
        public RedundantParamsWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantNameQualifier", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Qualifier is redundant")]
    public class RedundantQualifierWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantNameQualifier";
        protected const string MESSAGE = "Qualifier is redundant";
        public RedundantQualifierWarning(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantStringFormatCall", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'String.Format()\' call")]
    public class RedundantStringFormatCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantStringFormatCall";
        protected const string MESSAGE = "Redundant \'String.Format()\' call";
        public RedundantStringFormatCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantStringToCharArrayCall", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'String.ToCharArray()\' call")]
    public class RedundantStringToCharArrayCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantStringToCharArrayCall";
        protected const string MESSAGE = "Redundant \'String.ToCharArray()\' call";
        public RedundantStringToCharArrayCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantTernaryExpression", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant conditional ternary expression usage")]
    public class RedundantTernaryExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantTernaryExpression";
        protected const string MESSAGE = "Redundant conditional ternary expression usage";
        public RedundantTernaryExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression ternaryExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression TernaryExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantThisQualifier", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Qualifier \'this.\' is redundant")]
    public class RedundantThisQualifierWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantThisQualifier";
        protected const string MESSAGE = "Qualifier \'this.\' is redundant";
        public RedundantThisQualifierWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantToStringCallForValueType", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'Object.ToString()\' call for value type")]
    public class RedundantToStringCallForValueTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantToStringCallForValueType";
        protected const string MESSAGE = "Redundant \'Object.ToString()\' call for value type";
        public RedundantToStringCallForValueTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantToStringCall", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Redundant \'Object.ToString()\' call")]
    public class RedundantToStringCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantToStringCall";
        protected const string MESSAGE = "Redundant \'Object.ToString()\' call";
        public RedundantToStringCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantTypeArgumentsOfMethod", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Type argument specification is redundant")]
    public class RedundantTypeArgumentsOfMethodWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantTypeArgumentsOfMethod";
        protected const string MESSAGE = "Type argument specification is redundant";
        public RedundantTypeArgumentsOfMethodWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList TypeArgumentList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantUnsafeContext", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'unsafe\' context is redundant")]
    public class RedundantUnsafeContextDeclarationWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantUnsafeContext";
        protected const string MESSAGE = "\'unsafe\' context is redundant";
        public RedundantUnsafeContextDeclarationWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersListOwner modifiersListOwner) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersListOwner ModifiersListOwner { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantUnsafeContext", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'unsafe\' statement is redundant")]
    public class RedundantUnsafeStatementWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantUnsafeContext";
        protected const string MESSAGE = "\'unsafe\' statement is redundant";
        public RedundantUnsafeStatementWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeUnsafeStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeUnsafeStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A const of reference type other than string can only be initialized with null")]
    public class ReferenceConstantInitializerIsNotNullError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A const of reference type other than string can only be initialized with null";
        public ReferenceConstantInitializerIsNotNullError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ReferenceEqualsWithValueType", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'Object.ReferenceEquals\' is always false because it is called with value type")]
    public class ReferenceEqualsWithValueTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ReferenceEqualsWithValueType";
        protected const string MESSAGE = "\'Object.ReferenceEquals\' is always false because it is called with value type";
        public ReferenceEqualsWithValueTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The params parameter cannot be declared as ref or out")]
    public class RefOrOutForParamsParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The params parameter cannot be declared as ref or out";
        public RefOrOutForParamsParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'ref\' and \'out\' are not permitted on iterator parameters")]
    public class RefOrOutIteratorParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'ref\' and \'out\' are not permitted on iterator parameters";
        public RefOrOutIteratorParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Async methods cannot have \'ref\' or \'out\' parameters")]
    public class RefOrOutParameterInAnonmousAsyncError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Async methods cannot have \'ref\' or \'out\' parameters";
        public RefOrOutParameterInAnonmousAsyncError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Async methods cannot have \'ref\' or \'out\' parameters")]
    public class RefOrOutParameterInAsyncError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Async methods cannot have \'ref\' or \'out\' parameters";
        public RefOrOutParameterInAsyncError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The \'{0}\' argument type doesn\'t match parameter type")]
    public class RefOutArgumentTypeMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The \'{0}\' argument type doesn\'t match parameter type";
        public RefOutArgumentTypeMismatchError(JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo argument, string kind, JetBrains.ReSharper.Psi.IType parameterType) { }
        public JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo Argument { get; }
        public string ErrorStripeToolTip { get; }
        public string Kind { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType ParameterType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Operator cannot have \'ref\' or \'out\' parameter")]
    public class RefOutParameterInOperatorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Operator cannot have \'ref\' or \'out\' parameter";
        public RefOutParameterInOperatorError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameterDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter cannot have both \'params\' and \'ref\' modifiers")]
    public class RefParamsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter cannot have both \'params\' and \'ref\' modifiers";
        public RefParamsError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ReplaceWithStringIsNullOrEmpty", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Replace with \'{0}String.IsNullOrEmpty\'")]
    public class ReplaceWithStringIsNullOrEmptyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ReplaceWithStringIsNullOrEmpty";
        protected const string MESSAGE = "Replace with \'{0}String.IsNullOrEmpty\'";
        public ReplaceWithStringIsNullOrEmptyWarning(JetBrains.DocumentModel.IRangeMarker rangeMarker, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression operand, bool isNegative) { }
        public string ErrorStripeToolTip { get; }
        public bool IsNegative { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Operand { get; }
        public JetBrains.DocumentModel.IRangeMarker RangeMarker { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RequiredBaseTypesConflict", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class RequiredBaseTypesConflictWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RequiredBaseTypesConflict";
        protected const string MESSAGE = "{0}";
        public RequiredBaseTypesConflictWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute declaration, System.Collections.Generic.ICollection<JetBrains.Util.JetTuple<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType>> errorInfo) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Declaration { get; }
        public System.Collections.Generic.ICollection<JetBrains.Util.JetTuple<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType>> ErrorInfo { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RequiredBaseTypesDirectConflict", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class RequiredBaseTypesDirectConflictWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RequiredBaseTypesDirectConflict";
        protected const string MESSAGE = "{0}";
        public RequiredBaseTypesDirectConflictWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute declaration, System.Collections.Generic.ICollection<JetBrains.Util.Pair<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType>> errorInfo) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Declaration { get; }
        public System.Collections.Generic.ICollection<JetBrains.Util.Pair<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType>> ErrorInfo { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RequiredBaseTypesIsNotInherited", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class RequiredBaseTypesIsNotInheritedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RequiredBaseTypesIsNotInherited";
        protected const string MESSAGE = "{0}";
        public RequiredBaseTypesIsNotInheritedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration, JetBrains.Util.OneToSetMap<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType> requiredBaseTypes) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.Util.OneToSetMap<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.IDeclaredType> RequiredBaseTypes { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Iterator cannot contain \'return\' statement")]
    public class ReturnStatementInIteratorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Iterator cannot contain \'return\' statement";
        public ReturnStatementInIteratorError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Return type of async method is \'void\'")]
    public class ReturnTypeIsVoidAsyncError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Return type of async method is \'void\'";
        public ReturnTypeIsVoidAsyncError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement ReturnStatement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Return type is \'void\'")]
    public class ReturnTypeIsVoidError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Return type is \'void\'";
        public ReturnTypeIsVoidError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement ReturnStatement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The return type of increment/decrement operator must be of containing type")]
    public class ReturnTypeOfIncDecOperatorMustBeContainingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The return type of increment/decrement operator must be of containing type";
        public ReturnTypeOfIncDecOperatorMustBeContainingTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The return type of operator True or False must be bool")]
    public class ReturnTypeOfTrueFalseOperatorMustBeBoolError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The return type of operator True or False must be bool";
        public ReturnTypeOfTrueFalseOperatorMustBeBoolError(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Return value is missing")]
    public class ReturnValueMissedAsyncError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Return value is missing";
        public ReturnValueMissedAsyncError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement ReturnStatement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Return value is missing")]
    public class ReturnValueMissedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Return value is missing";
        public ReturnValueMissedError(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement ReturnStatement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ReturnValueOfPureMethodIsNotUsed", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Return value of pure method is not used")]
    public class ReturnValueOfPureMethodIsNotUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ReturnValueOfPureMethodIsNotUsed";
        protected const string MESSAGE = "Return value of pure method is not used";
        public ReturnValueOfPureMethodIsNotUsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.Resolve.IReference invocationReference) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference InvocationReference { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Member with the same name is already declared")]
    public class SameMemberDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Member with the same name is already declared";
        public SameMemberDeclarationError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A partial method may not have multiple defining declarations")]
    public class SameSignatureDefiningPartialMethodDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A partial method may not have multiple defining declarations";
        public SameSignatureDefiningPartialMethodDeclarationError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A partial method may not have multiple implementing declarations")]
    public class SameSignatureImplementingPartialMethodDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A partial method may not have multiple implementing declarations";
        public SameSignatureImplementingPartialMethodDeclarationError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Member with the same signature is already declared")]
    public class SameSignatureMemberDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Member with the same signature is already declared";
        public SameSignatureMemberDeclarationError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' is specified several times in type parameter constraint")]
    public class SameTypeInTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' is specified several times in type parameter constraint";
        public SameTypeInTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IDeclaredType declaredType) { }
        public JetBrains.ReSharper.Psi.IDeclaredType DeclaredType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use sealed class \'{0}\' as type parameter constraint")]
    public class SealedClassInTypeParameterConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use sealed class \'{0}\' as type parameter constraint";
        public SealedClassInTypeParameterConstraintError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IClass classConstraint) { }
        public JetBrains.ReSharper.Psi.IClass ClassConstraint { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SealedMemberInSealedClass", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="\'sealed\' modifier is redundant because {0} \'{1}\' is sealed")]
    public class SealedMemberInSealedClassWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SealedMemberInSealedClass";
        protected const string MESSAGE = "\'sealed\' modifier is redundant because {0} \'{1}\' is sealed";
        public SealedMemberInSealedClassWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Second parameter of shift operator should be \'int\'")]
    public class SecondParameterOfShiftOperatorMustBeIntError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Second parameter of shift operator should be \'int\'";
        public SecondParameterOfShiftOperatorMustBeIntError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration, JetBrains.ReSharper.Psi.Tree.IParameterDeclaration parameterDeclaration, JetBrains.ReSharper.Psi.ITypeElement containingType) { }
        public JetBrains.ReSharper.Psi.ITypeElement ContainingType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.IParameterDeclaration ParameterDeclaration { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Right operand of shift expression should be convertible to \'int\'")]
    public class ShiftRightOpIsNotIntError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Right operand of shift expression should be convertible to \'int\'";
        public ShiftRightOpIsNotIntError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method, delegate or event is expected")]
    public class ShouldBeInvocableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method, delegate or event is expected";
        public ShouldBeInvocableError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SimilarAnonymousTypeNearby", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Similar anonymous type detected nearby. Are they the same?")]
    public class SimilarAnonymousTypeNearbyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SimilarAnonymousTypeNearby";
        protected const string MESSAGE = "Similar anonymous type detected nearby. Are they the same?";
        public SimilarAnonymousTypeNearbyWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectCreationExpression expression, System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectCreationExpression> similarExpressions) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectCreationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectCreationExpression> SimilarExpressions { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SimplifyConditionalTernaryExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Simplify conditional ternary expression")]
    public class SimplifyConditionalTernaryExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SimplifyConditionalTernaryExpression";
        protected const string MESSAGE = "Simplify conditional ternary expression";
        public SimplifyConditionalTernaryExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression ternaryExpression, System.Nullable<bool> thenLiteralValue, System.Nullable<bool> elseLiteralValue) { }
        public System.Nullable<bool> ElseLiteralValue { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression TernaryExpression { get; }
        public System.Nullable<bool> ThenLiteralValue { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SimplifyLinqExpression", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Simplify LINQ expression")]
    public class SimplifyLinqExpressionWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SimplifyLinqExpression";
        protected const string MESSAGE = "Simplify LINQ expression";
        public SimplifyLinqExpressionWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatchResult matchResult, JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralSearchPattern pattern) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatchResult MatchResult { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralSearchPattern Pattern { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot take the size of a variable of a managed type \'{0}\'")]
    public class SizeOfManagedTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot take the size of a variable of a managed type \'{0}\'";
        public SizeOfManagedTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeSizeOfExpression expression, JetBrains.ReSharper.Psi.IType operandType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeSizeOfExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType OperandType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SpecifyACultureInStringConversionExplicitly", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Specify a culture in string conversion explicitly")]
    public class SpecifyACultureInStringConversionExplicitlyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SpecifyACultureInStringConversionExplicitly";
        protected const string MESSAGE = "Specify a culture in string conversion explicitly";
        public SpecifyACultureInStringConversionExplicitlyWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SpecifyStringComparison", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Specify string comparison explicitly")]
    public class SpecifyStringComparisonWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SpecifyStringComparison";
        protected const string MESSAGE = "Specify string comparison explicitly";
        public SpecifyStringComparisonWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression arg1, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression arg2, bool negate, System.StringComparison stringComparison) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Arg1 { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Arg2 { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public bool Negate { get; }
        public System.StringComparison StringComparison { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare a pointer to a managed type \'{0}\'")]
    public class StackAllocManagedTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare a pointer to a managed type \'{0}\'";
        public StackAllocManagedTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeStackAllocInitializer expression, JetBrains.ReSharper.Psi.IType operandType) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeStackAllocInitializer Expression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IType OperandType { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static class \'{0}\' cannot have \'abstract\' modifier")]
    public class StaticClassCannotBeAbstractError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static class \'{0}\' cannot have \'abstract\' modifier";
        public StaticClassCannotBeAbstractError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration declaration, JetBrains.ReSharper.Psi.IClass element) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IClass Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static class \'{0}\' cannot have \'sealed\' modifier")]
    public class StaticClassCannotBeSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static class \'{0}\' cannot have \'sealed\' modifier";
        public StaticClassCannotBeSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration declaration, JetBrains.ReSharper.Psi.IClass element) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration Declaration { get; }
        public JetBrains.ReSharper.Psi.IClass Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\': static types cannot be used as type arguments")]
    public class StaticClassInTypeArgumentError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\': static types cannot be used as type arguments";
        public StaticClassInTypeArgumentError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange argumentRange) { }
        public JetBrains.DocumentModel.DocumentRange ArgumentRange { get; }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static class \'{0}\' cannot have protected or protected-internal members")]
    public class StaticClassMemberCannotBeProtectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static class \'{0}\' cannot have protected or protected-internal members";
        public StaticClassMemberCannotBeProtectedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration memberDeclaration, JetBrains.ReSharper.Psi.IClass element) { }
        public JetBrains.ReSharper.Psi.IClass Element { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration MemberDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot access static {0} \'{1}\' in non-static context")]
    public class StaticElementInNonStaticContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot access static {0} \'{1}\' in non-static context";
        public StaticElementInNonStaticContextError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("StaticFieldInGenericType", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Static field in generic type")]
    public class StaticFieldInGenericTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "StaticFieldInGenericType";
        protected const string MESSAGE = "Static field in generic type";
        public StaticFieldInGenericTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration FieldDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("StaticFieldInitializersReferesToFieldBelow", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Static field initializer refers to static field below or in other part")]
    public class StaticFieldInitializersReferesToFieldBelowWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "StaticFieldInitializersReferesToFieldBelow";
        protected const string MESSAGE = "Static field initializer refers to static field below or in other part";
        public StaticFieldInitializersReferesToFieldBelowWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Static field or property \'{0}\' cannot be assigned in an object initializer")]
    public class StaticFieldOrPropertyInMemberInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Static field or property \'{0}\' cannot be assigned in an object initializer";
        public StaticFieldOrPropertyInMemberInitializerError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Non-static struct member cannot have initializer")]
    public class StructFieldInitializerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Non-static struct member cannot have initializer";
        public StructFieldInitializerError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration field, JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer initializer) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Field { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantExtendsListEntry", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Base interface \'{0}\' is redundant because {1} {2} \'{3}\'")]
    public class SuperInterfaceIsSuperOfOtherWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantExtendsListEntry";
        protected const string MESSAGE = "Base interface \'{0}\' is redundant because {1} {2} \'{3}\'";
        public SuperInterfaceIsSuperOfOtherWarning(JetBrains.ReSharper.Psi.ITypeElement typeElement, JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IDeclaredType declaredType, JetBrains.ReSharper.Psi.IDeclaredType otherInterface) { }
        public JetBrains.ReSharper.Psi.IDeclaredType DeclaredType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredType OtherInterface { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantExtendsListEntry", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Base type \'{0}\' is already specified in other parts")]
    public class SuperTypeDeclaredInOtherPartWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantExtendsListEntry";
        protected const string MESSAGE = "Base type \'{0}\' is already specified in other parts";
        public SuperTypeDeclaredInOtherPartWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IDeclaredType declaredType) { }
        public JetBrains.ReSharper.Psi.IDeclaredType DeclaredType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0465", "CSHARP", CompilerIds=new string[] {
            "CS0465"}, CompilerIdsWithDescription="CS0465:Introducing a \'Finalize\' method can interfere with destructor invocation", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Introducing a \'Finalize\' method can interfere with destructor invocation. Did you" +
        " intend to declare a destructor?")]
    public class SuspiciousFinalizeMethodWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0465";
        protected const string MESSAGE = "Introducing a \'Finalize\' method can interfere with destructor invocation. Did you" +
            " intend to declare a destructor?";
        public SuspiciousFinalizeMethodWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1584", "CSHARP", AttributeId="ReSharper Underlined Error Highlighting", CompilerIds=new string[] {
            "CS1584"}, CompilerIdsWithDescription="CS1584:Syntax error in XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Syntax error")]
    public class SyntaxErrorInDocCommentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1584";
        protected const string MESSAGE = "Syntax error";
        public SyntaxErrorInDocCommentWarning(JetBrains.DocumentModel.DocumentRange error) { }
        public JetBrains.DocumentModel.DocumentRange Error { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("TailRecursiveCall", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Tail recursive call may be replaced with loop")]
    public class TailRecursiveCallWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "TailRecursiveCall";
        protected const string MESSAGE = "Tail recursive call may be replaced with loop";
        public TailRecursiveCallWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocation, JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration, System.Collections.Generic.IList<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression> tailCalls) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression Invocation { get; }
        public int NavigationOffsetPatch { get; }
        public System.Collections.Generic.IList<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression> TailCalls { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'this\' parameter declaration could be on static methods only")]
    public class ThisParameterNotOnMethodError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'this\' parameter declaration could be on static methods only";
        public ThisParameterNotOnMethodError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ThreadStaticAtInstanceField", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="[ThreadStatic] doesn\'t work with instance fields")]
    public class ThreadStaticAtInstanceFieldWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ThreadStaticAtInstanceField";
        protected const string MESSAGE = "[ThreadStatic] doesn\'t work with instance fields";
        public ThreadStaticAtInstanceFieldWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute attribute, JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Attribute { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration FieldDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ThreadStaticFieldHasInitializer", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Thread static field has initializer")]
    public class ThreadStaticFieldHasInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ThreadStaticFieldHasInitializer";
        protected const string MESSAGE = "Thread static field has initializer";
        public ThreadStaticFieldHasInitializerWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration FieldDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A throw statement with no arguments is not allowed inside of a finally clause nes" +
        "ted inside of the innermost catch clause")]
    public class ThrowInsideFinallyAndCatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A throw statement with no arguments is not allowed inside of a finally clause nes" +
            "ted inside of the innermost catch clause";
        public ThrowInsideFinallyAndCatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="A throw statement with no arguments is not allowed outside of a catch clause")]
    public class ThrowWithoutCatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "A throw statement with no arguments is not allowed outside of a catch clause";
        public ThrowWithoutCatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("TooWideLocalVariableScope", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0} \'{1}\' can be declared in inner scope")]
    public class TooWideLocalVariableScopeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "TooWideLocalVariableScope";
        protected const string MESSAGE = "{0} \'{1}\' can be declared in inner scope";
        public TooWideLocalVariableScopeWarning(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("TryStatementsCanBeMerged", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="try-catch and try-finally statements can be merged")]
    public class TryStatementsCanBeMergedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "TryStatementsCanBeMerged";
        protected const string MESSAGE = "try-catch and try-finally statements can be merged";
        public TryStatementsCanBeMergedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement tryStatement, JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement childTryStatement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement ChildTryStatement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement TryStatement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type \'{0}\' must have a public parameterless constructor in order to use it as" +
        " parameter \'{1}\' in the generic {2} \'{3}\'")]
    public class TypeArgumentHasNoDefaultConstructorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type \'{0}\' must have a public parameterless constructor in order to use it as" +
            " parameter \'{1}\' in the generic {2} \'{3}\'";
        public TypeArgumentHasNoDefaultConstructorError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange errorRange, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public JetBrains.DocumentModel.DocumentRange ErrorRange { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type \'{0}\' must be convertible to \'{1}\' in order to use it as parameter \'{2}\'" +
        " in the generic {3} \'{4}\'")]
    public class TypeArgumentIsNotConvertibleToConstraintError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type \'{0}\' must be convertible to \'{1}\' in order to use it as parameter \'{2}\'" +
            " in the generic {3} \'{4}\'";
        public TypeArgumentIsNotConvertibleToConstraintError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange errorRange, JetBrains.ReSharper.Psi.IType constraintType, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public JetBrains.ReSharper.Psi.IType ConstraintType { get; }
        public JetBrains.DocumentModel.DocumentRange ErrorRange { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type \'{0}\' must be a reference type in order to use it as parameter \'{1}\'")]
    public class TypeArgumentIsNotReferenceTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type \'{0}\' must be a reference type in order to use it as parameter \'{1}\'";
        public TypeArgumentIsNotReferenceTypeError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange errorRange, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public JetBrains.DocumentModel.DocumentRange ErrorRange { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type \'{0}\' must be a non-nullable value type in order to use it as parameter " +
        "\'{1}\'")]
    public class TypeArgumentIsNotValueTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type \'{0}\' must be a non-nullable value type in order to use it as parameter " +
            "\'{1}\'";
        public TypeArgumentIsNotValueTypeError(JetBrains.ReSharper.Psi.IType argumentType, JetBrains.DocumentModel.DocumentRange errorRange, JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public JetBrains.ReSharper.Psi.IType ArgumentType { get; }
        public JetBrains.DocumentModel.DocumentRange ErrorRange { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type \'{0}\' does not extend \'System.Exception\'")]
    public class TypeDoesNotExtendExceptionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type \'{0}\' does not extend \'System.Exception\'";
        public TypeDoesNotExtendExceptionError(JetBrains.ReSharper.Psi.IExpressionType variableType, JetBrains.ReSharper.Psi.Tree.ITreeNode problemNode) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode ProblemNode { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType VariableType { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type name expected, but {0} name found")]
    public class TypeExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type name expected, but {0} name found";
        public TypeExpectedError(JetBrains.ReSharper.Psi.IDeclaredElement element, JetBrains.ReSharper.Psi.Tree.ITreeNode problemNode, JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode ProblemNode { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\': type name expected")]
    public class TypeInExtendsListExprectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\': type name expected";
        public TypeInExtendsListExprectedError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.IDeclaredElement declaredElement) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type arguments for method \'{0}\' cannot be inferred from the usage. Try specif" +
        "ying the type arguments explicitly.")]
    public class TypeInferenceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type arguments for method \'{0}\' cannot be inferred from the usage. Try specif" +
            "ying the type arguments explicitly.";
        public TypeInferenceError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IMethod method) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IMethod Method { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The type arguments cannot be inferred from the usage. Try specifying the type arg" +
        "uments explicitly.\\nCandidates are:{0}")]
    public class TypeInferenceMultipleCandidatesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The type arguments cannot be inferred from the usage. Try specifying the type arg" +
            "uments explicitly.\nCandidates are:{0}";
        public TypeInferenceMultipleCandidatesError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IMethod[] methods) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IMethod[] Methods { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type \'{0}\' is not awaitable")]
    public class TypeIsNotAwaitableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type \'{0}\' is not awaitable";
        public TypeIsNotAwaitableError(JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression awaitExpression, JetBrains.ReSharper.Psi.IExpressionType expressionType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression AwaitExpression { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IExpressionType ExpressionType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type \'{0}\' is not enumerable")]
    public class TypeIsNotEnumerableError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type \'{0}\' is not enumerable";
        public TypeIsNotEnumerableError(JetBrains.ReSharper.Psi.IExpressionType collectionType, JetBrains.ReSharper.Psi.Tree.ITreeNode problemNode) { }
        public JetBrains.ReSharper.Psi.IExpressionType CollectionType { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode ProblemNode { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type or namespace name expected, but {0} name found")]
    public class TypeOrNamespaceExpectedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type or namespace name expected, but {0} name found";
        public TypeOrNamespaceExpectedError(JetBrains.ReSharper.Psi.IDeclaredElement element, JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type or namespace name expected")]
    public class TypeOrNamespaceExpectedNoCandidateError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type or namespace name expected";
        public TypeOrNamespaceExpectedNoCandidateError(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("TypeParameterCanBeVariant", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="The type parameter {0} could be declared as {1}")]
    public class TypeParameterCanBeVariantWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "TypeParameterCanBeVariant";
        protected const string MESSAGE = "The type parameter {0} could be declared as {1}";
        public TypeParameterCanBeVariantWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration, JetBrains.ReSharper.Psi.ITypeParameter typeParameter, JetBrains.ReSharper.Psi.TypeParameterVariance suggestedVariance) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.TypeParameterVariance SuggestedVariance { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' has the same name as the containing {1}")]
    public class TypeParameterHasSameNameAsOwnerError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' has the same name as the containing {1}";
        public TypeParameterHasSameNameAsOwnerError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration typeParameterDeclaration, JetBrains.ReSharper.Psi.IDeclaredElement owner) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Owner { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration TypeParameterDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0693", "CSHARP", CompilerIds=new string[] {
            "CS0693"}, CompilerIdsWithDescription="CS0693:Type parameter hides outer type", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Type parameter \'{0}\' hides {1} \'{2}\'")]
    public class TypeParameterHidesClassWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0693";
        protected const string MESSAGE = "Type parameter \'{0}\' hides {1} \'{2}\'";
        public TypeParameterHidesClassWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration typeParameterDeclaration, JetBrains.ReSharper.Psi.ITypeElement outerType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeElement OuterType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration TypeParameterDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0693", "CSHARP", CompilerIds=new string[] {
            "CS0693"}, CompilerIdsWithDescription="CS0693:Type parameter has the same name as a type parameter from the outer type", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Type parameter \'{0}\' has the same name as the type parameter from outer {1} \'{2}\'" +
        "")]
    public class TypeParameterHidesTypeParameterWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0693";
        protected const string MESSAGE = "Type parameter \'{0}\' has the same name as the type parameter from outer {1} \'{2}\'" +
            "";
        public TypeParameterHidesTypeParameterWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration typeParameterDeclaration, JetBrains.ReSharper.Psi.ITypeParameter outerType) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter OuterType { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration TypeParameterDeclaration { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1712", "CSHARP", CompilerIds=new string[] {
            "CS1712"}, CompilerIdsWithDescription="CS1712:Type parameter has no matching typeparam tag in the XML comment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Type parameter \'{0}\' has no matching typeparam tag in the XML comment on \'{1}\' (b" +
        "ut other type parameters do)")]
    public class TypeParameterNotDocumentedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1712";
        protected const string MESSAGE = "Type parameter \'{0}\' has no matching typeparam tag in the XML comment on \'{1}\' (b" +
            "ut other type parameters do)";
        public TypeParameterNotDocumentedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration declaration, JetBrains.ReSharper.Psi.ITypeParametersOwner owner) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeParametersOwner Owner { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString="Incorrect number of type parameters in reference to {0} \'{1}\'")]
    public class TypeParametersNumberMismatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Incorrect number of type parameters in reference to {0} \'{1}\'";
        public TypeParametersNumberMismatchError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement candidate, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Candidate { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList TypeArgumentList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Incorrect number of type parameters. Candidates are:{0}")]
    public class TypeParametersNumberMismatchMultipleCandidatesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Incorrect number of type parameters. Candidates are:{0}";
        public TypeParametersNumberMismatchMultipleCandidatesError(JetBrains.ReSharper.Psi.Resolve.IReference reference, string candidates, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public string Candidates { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList TypeArgumentList { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1589", "CSHARP", CompilerIds=new string[] {
            "CS1589"}, CompilerIdsWithDescription="CS1589:Unable to include XML fragment", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Unable to include XML fragment: {0}")]
    public class UnableToIncludeXMLFragmentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1589";
        protected const string MESSAGE = "Unable to include XML fragment: {0}";
        public UnableToIncludeXMLFragmentWarning(JetBrains.ReSharper.Psi.Xml.Tree.IXmlTreeNode xmlTag, string reason) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string Reason { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.Xml.Tree.IXmlTreeNode XmlTag { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Parameter of unary operator must be of containing type")]
    public class UnaryOperatorParameterMustBeContainingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Parameter of unary operator must be of containing type";
        public UnaryOperatorParameterMustBeContainingTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration declaration, JetBrains.ReSharper.Psi.Tree.IParameterDeclaration parameter) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.IParameterDeclaration Parameter { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} name is not valid at this point")]
    public class UnexpectedElementTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} name is not valid at this point";
        public UnexpectedElementTypeError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement Element { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot define operator with name \'{0}\'")]
    public class UnknownOperatorNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot define operator with name \'{0}\'";
        public UnknownOperatorNameError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Unmatched region")]
    public class UnmatchedRegionPPDirectiveError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Unmatched region";
        public UnmatchedRegionPPDirectiveError(JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorDirective directiveNode) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorDirective DirectiveNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Attribute arguments must precede property assignment")]
    public class UnnamedAttributeArgumentMustPrecedeNamedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Attribute arguments must precede property assignment";
        public UnnamedAttributeArgumentMustPrecedeNamedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument argument) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument Argument { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS0162", "CSHARP", AttributeId="ReSharper Dead Code", CompilerIds=new string[] {
            "CS0162"}, CompilerIdsWithDescription="CS0162:Code is unreachable", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Code is unreachable")]
    public class UnreachableCodeCompilerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS0162";
        protected const string MESSAGE = "Code is unreachable";
        public UnreachableCodeCompilerWarning(JetBrains.ReSharper.Psi.ITreeRange treeRange) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITreeRange TreeRange { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("UnreachableCode", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Code is unreachable")]
    public class UnreachableCodeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "UnreachableCode";
        protected const string MESSAGE = "Code is unreachable";
        public UnreachableCodeWarning(JetBrains.ReSharper.Psi.ITreeRange treeRange) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITreeRange TreeRange { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'{0}\' is not a recognized attribute location")]
    public class UnrecognizedAttributeTargetError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'{0}\' is not a recognized attribute location";
        public UnrecognizedAttributeTargetError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpIdentifier target) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpIdentifier Target { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Module \'{0}\' should be referenced")]
    public class UnreferencedModuleError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Module \'{0}\' should be referenced";
        public UnreferencedModuleError(JetBrains.ReSharper.Psi.Tree.ITreeNode accessElement, string module) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode AccessElement { get; }
        public string ErrorStripeToolTip { get; }
        public string Module { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Unresolved jump")]
    public class UnresolvedJumpError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Unresolved jump";
        public UnresolvedJumpError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement jumpStatement) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement JumpStatement { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot use unsafe construct in safe context")]
    public class UnsafeConstructInSafeContextError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot use unsafe construct in safe context";
        public UnsafeConstructInSafeContextError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'unsafe\' statement is not allowed at this point")]
    public class UnsafeStatementNotAllowedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'unsafe\' statement is not allowed at this point";
        public UnsafeStatementNotAllowedError(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeUnsafeStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeUnsafeStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("UnsupportedRequiredBaseType", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="BaseTypeRequired attribute supports only classes and interfaces")]
    public class UnsupportedRequiredBaseTypeWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "UnsupportedRequiredBaseType";
        protected const string MESSAGE = "BaseTypeRequired attribute supports only classes and interfaces";
        public UnsupportedRequiredBaseTypeWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("UnusedAnonymousMethodSignature", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Specifying signature is not necessary because none of its parameters are used in " +
        "the body")]
    public class UnusedAnonymousMethodSignatureWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "UnusedAnonymousMethodSignature";
        protected const string MESSAGE = "Specifying signature is not necessary because none of its parameters are used in " +
            "the body";
        public UnusedAnonymousMethodSignatureWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodSignature signature) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodSignature Signature { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantUsingDirective", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Using directive is not required by the code and can be safely removed")]
    public class UnusedUsingDirectiveWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantUsingDirective";
        protected const string MESSAGE = "Using directive is not required by the code and can be safely removed";
        public UnusedUsingDirectiveWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective directive) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective Directive { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1911", "CSHARP", CompilerIds=new string[] {
            "CS1911"}, CompilerIdsWithDescription="CS1911:Access to a member through \'base\' keyword from anonymous method, lambda ex" +
        "pression, query expression or iterator results in unverifiable code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Access to \'{0}\' through \'base\' keyword from anonymous method, lambda expression, " +
        "query expression or iterator results in unverifiable code")]
    public class UnverifiableBaseExpressionUsageWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1911";
        protected const string MESSAGE = "Access to \'{0}\' through \'base\' keyword from anonymous method, lambda expression, " +
            "query expression or iterator results in unverifiable code";
        public UnverifiableBaseExpressionUsageWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IBaseExpression baseExpression, JetBrains.ReSharper.Psi.ITypeMember baseMember) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IBaseExpression BaseExpression { get; }
        public JetBrains.ReSharper.Psi.ITypeMember BaseMember { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("UseObjectOrCollectionInitializer", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use collection initializer")]
    public class UseCollectionInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "UseObjectOrCollectionInitializer";
        protected const string MESSAGE = "Use collection initializer";
        public UseCollectionInitializerWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression ObjectCreationExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="One or more types required to compile a dynamic expression cannot be found. Are y" +
        "ou missing references to Microsoft.CSharp.dll and System.Core.dll?")]
    public class UseDynamicWithoutSupportTypesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "One or more types required to compile a dynamic expression cannot be found. Are y" +
            "ou missing references to Microsoft.CSharp.dll and System.Core.dll?";
        public UseDynamicWithoutSupportTypesError(JetBrains.ReSharper.Psi.Tree.ITreeNode accessElement) { }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode AccessElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("UseIndexedProperty", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use indexed property")]
    public class UseIndexedPropertyWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "UseIndexedProperty";
        protected const string MESSAGE = "Use indexed property";
        public UseIndexedPropertyWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.IProperty property) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression InvocationExpression { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty Property { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=10, ToolTipFormatString=" Cannot use {0} \'{1}\' before it is declared")]
    public class UseLocalVariableBeforeDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = " Cannot use {0} \'{1}\' before it is declared";
        public UseLocalVariableBeforeDeclarationError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IDeclaredElement declaredElement) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement DeclaredElement { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("UseObjectOrCollectionInitializer", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use object initializer")]
    public class UseObjectInitializerWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "UseObjectOrCollectionInitializer";
        protected const string MESSAGE = "Use object initializer";
        public UseObjectInitializerWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression ObjectCreationExpression { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="User-defined operators cannot return void")]
    public class UserDefinedOperatorCannotBeVoidError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "User-defined operators cannot return void";
        public UserDefinedOperatorCannotBeVoidError(JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SuggestUseVarKeywordEverywhere", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use implicitly typed local variable declaration")]
    public class UseVarKeywordEverywhereWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SuggestUseVarKeywordEverywhere";
        protected const string MESSAGE = "Use implicitly typed local variable declaration";
        public UseVarKeywordEverywhereWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("SuggestUseVarKeywordEvident", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Use implicitly typed local variable declaration")]
    public class UseVarKeywordEvidentWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "SuggestUseVarKeywordEvident";
        protected const string MESSAGE = "Use implicitly typed local variable declaration";
        public UseVarKeywordEvidentWarning(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Namespace \'{0}\' contains no declarations")]
    public class UsingEmptyNamespaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Namespace \'{0}\' contains no declarations";
        public UsingEmptyNamespaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingNamespaceDirective directive, JetBrains.ReSharper.Psi.INamespace ns) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IUsingNamespaceDirective Directive { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.INamespace Ns { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("ValueParameterNotUsed", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="\'value\' parameter is not used")]
    public class ValueParameterNotUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "ValueParameterNotUsed";
        protected const string MESSAGE = "\'value\' parameter is not used";
        public ValueParameterNotUsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration accessorDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration AccessorDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type parameter \'{0}\' has the \'struct\' constraint so \'{1}\' cannot be used as a con" +
        "straint for \'{2}\'")]
    public class ValueTypeParameterInTypeParameterConstrantListError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type parameter \'{0}\' has the \'struct\' constraint so \'{1}\' cannot be used as a con" +
            "straint for \'{2}\'";
        public ValueTypeParameterInTypeParameterConstrantListError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.ITypeParameter origin, JetBrains.ReSharper.Psi.ITypeParameter parameter) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter Origin { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter Parameter { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsageNode { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAssignment", "CSHARP", AttributeId="ReSharper Dead Code", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.DEADCODE, ToolTipFormatString="Value assigned is not used in any execution path")]
    public class VariableConstantInitializerNotUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAssignment";
        protected const string MESSAGE = "Value assigned is not used in any execution path";
        public VariableConstantInitializerNotUsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer initializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("RedundantAssignment", "CSHARP", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="Value assigned is not used in any execution path")]
    public class VariableInitializerNotUsedWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "RedundantAssignment";
        protected const string MESSAGE = "Value assigned is not used in any execution path";
        public VariableInitializerNotUsedWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer initializer) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer Initializer { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare a variable of static type \'{0}\'")]
    public class VariableTypeCannotBeStaticClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare a variable of static type \'{0}\'";
        public VariableTypeCannotBeStaticClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsage, JetBrains.ReSharper.Psi.IType type) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType Type { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} type cannot be \'void\'")]
    public class VariableTypeCannotBeVoidError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} type cannot be \'void\'";
        public VariableTypeCannotBeVoidError(JetBrains.ReSharper.Psi.Tree.ITreeNode typeUsage, JetBrains.ReSharper.Psi.IDeclaredElement variable) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode TypeUsage { get; }
        public JetBrains.ReSharper.Psi.IDeclaredElement Variable { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Variant type parameters could be declared in interfaces or delegates only")]
    public class VarianceDeclarationNotInInterfaceOrDelegateError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Variant type parameters could be declared in interfaces or delegates only";
        public VarianceDeclarationNotInInterfaceOrDelegateError(JetBrains.ReSharper.Psi.Tree.ITokenNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITokenNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0}")]
    public class VarianceSafetyFailedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0}";
        public VarianceSafetyFailedError(string rule, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName, JetBrains.ReSharper.Psi.ITypeParameter typeParameter, JetBrains.ReSharper.Psi.TypeParameterVariance necessaryVariance) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.TypeParameterVariance NecessaryVariance { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName ReferenceName { get; }
        public string Rule { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeParameter TypeParameter { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Virtual {0} cannot be private")]
    public class VirtualMemberCannotBePrivateError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Virtual {0} cannot be private";
        public VirtualMemberCannotBePrivateError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember member) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare new virtual {0} \'{1}\' in sealed {2} \'{3}")]
    public class VirtualMemberInSealedClassError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare new virtual {0} \'{1}\' in sealed {2} \'{3}";
        public VirtualMemberInSealedClassError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember typeMember, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Cannot declare virtual {0} \'{1}\' in struct \'{2}")]
    public class VirtualMemberInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Cannot declare virtual {0} \'{1}\' in struct \'{2}";
        public VirtualMemberInStructError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration, JetBrains.ReSharper.Psi.ITypeMember typeMember, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public JetBrains.ReSharper.Psi.ITypeMember TypeMember { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::CS1030", "CSHARP", CompilerIds=new string[] {
            "CS1030"}, CompilerIdsWithDescription="CS1030:\'#warning\' directive", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.WARNING, ToolTipFormatString="{0}")]
    public class WarningPPDirectiveWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::CS1030";
        protected const string MESSAGE = "{0}";
        public WarningPPDirectiveWarning(JetBrains.ReSharper.Psi.CSharp.Tree.IWarningDirective directiveNode, string warningMessage) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IWarningDirective DirectiveNode { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public string WarningMessage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT parameters of array type cannot be both annotated with \'ReadOnlyArrayAttrib" +
        "ute\' and \'WriteOnlyArrayAttribute\' atributes")]
    public class WinRTArrayParameterBothDirectionsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT parameters of array type cannot be both annotated with \'ReadOnlyArrayAttrib" +
            "ute\' and \'WriteOnlyArrayAttribute\' atributes";
        public WinRTArrayParameterBothDirectionsError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT parameters of array type must be annotated with either \'ReadOnlyArrayAttrib" +
        "ute\' or \'WriteOnlyArrayAttribute\' attribute")]
    public class WinRTArrayParameterNoDirectionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT parameters of array type must be annotated with either \'ReadOnlyArrayAttrib" +
            "ute\' or \'WriteOnlyArrayAttribute\' attribute";
        public WinRTArrayParameterNoDirectionError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT out parameters of array type cannot be annotated with \'ReadOnlyArrayAttribu" +
        "te\' since the contents of output arrays are writable")]
    public class WinRTArrayParameterOutReadOnlyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT out parameters of array type cannot be annotated with \'ReadOnlyArrayAttribu" +
            "te\' since the contents of output arrays are writable";
        public WinRTArrayParameterOutReadOnlyError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Custom async operations are not supported, use AsyncInfoFactory instead")]
    public class WinRTAsyncInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Custom async operations are not supported, use AsyncInfoFactory instead";
        public WinRTAsyncInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.IInterface baseInterfaceType, JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration currentTypeDeclaration) { }
        public JetBrains.ReSharper.Psi.IInterface BaseInterfaceType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration CurrentTypeDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} name \'{1}\' and {2} name \'{3}\' cannot differ in case only")]
    public class WinRTCaseSensitiveNames2Error : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} name \'{1}\' and {2} name \'{3}\' cannot differ in case only";
        public WinRTCaseSensitiveNames2Error(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.IDeclaredElement conflictedElement) { }
        public JetBrains.ReSharper.Psi.IDeclaredElement ConflictedElement { get; }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type names \'{0}\' and \'{1}\' cannot differ in case only")]
    public class WinRTCaseSensitiveNamesError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type names \'{0}\' and \'{1}\' cannot differ in case only";
        public WinRTCaseSensitiveNamesError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration, JetBrains.ReSharper.Psi.ITypeElement typeElement) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.ITypeElement TypeElement { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type declaration has the same name as interface \'{0}\' generated for type \'{1}\'")]
    public class WinRTConflictWithGeneratedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type declaration has the same name as interface \'{0}\' generated for type \'{1}\'";
        public WinRTConflictWithGeneratedError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration, string name) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public string Name { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT do not supports \'out\' parameters on constructors")]
    public class WinRTConstructorOutParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT do not supports \'out\' parameters on constructors";
        public WinRTConstructorOutParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT types cannot have multiple constructors with same number of arguments")]
    public class WinRTConstructorOverloadsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT types cannot have multiple constructors with same number of arguments";
        public WinRTConstructorOverloadsError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The parameterized constructor has a parameter named \'value\' which is the same as " +
        "the default return value name. Consider using another name for the parameter")]
    public class WinRTConstructorReturnValueNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The parameterized constructor has a parameter named \'value\' which is the same as " +
            "the default return value name. Consider using another name for the parameter";
        public WinRTConstructorReturnValueNameError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT enumeration type should be backed by values of type int or uint")]
    public class WinRTEnumUnderlyingTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT enumeration type should be backed by values of type int or uint";
        public WinRTEnumUnderlyingTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT type cannot contain externally visible constants. Constants can only appear" +
        " on WinRT enumerations")]
    public class WinRTExternalConstantError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT type cannot contain externally visible constants. Constants can only appear" +
            " on WinRT enumerations";
        public WinRTExternalConstantError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT class cannot contain externally visible fields")]
    public class WinRTExternalFieldError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT class cannot contain externally visible fields";
        public WinRTExternalFieldError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Field in WinRT struct cannot have initializer")]
    public class WinRTFieldInitializerInStructError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Field in WinRT struct cannot have initializer";
        public WinRTFieldInitializerInStructError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT does not support indexers")]
    public class WinRTIndexerDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT does not support indexers";
        public WinRTIndexerDeclarationError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implementation inheritance is not allowed in WinRT")]
    public class WinRTInheritanceIsNotAllowedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implementation inheritance is not allowed in WinRT";
        public WinRTInheritanceIsNotAllowedError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration currentClassDeclaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration CurrentClassDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Implementing internal interface is not allowed in WinRT")]
    public class WinRTInternalInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Implementing internal interface is not allowed in WinRT";
        public WinRTInternalInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.IInterface baseInterfaceType, JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration currentTypeDeclaration) { }
        public JetBrains.ReSharper.Psi.IInterface BaseInterfaceType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration CurrentTypeDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT field cannot be of type \'{0}\'. Each field in a WinRT structure can only be " +
        "UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Boolean, Str" +
        "ing, Enum, Char, or itself a structure")]
    public class WinRTInvalidFieldTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT field cannot be of type \'{0}\'. Each field in a WinRT structure can only be " +
            "UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Boolean, Str" +
            "ing, Enum, Char, or itself a structure";
        public WinRTInvalidFieldTypeError(JetBrains.ReSharper.Psi.Tree.ITreeNode node, JetBrains.ReSharper.Psi.IType type) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType Type { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method has as invalid return value name")]
    public class WinRTInvalidReturnValueNameError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method has as invalid return value name";
        public WinRTInvalidReturnValueNameError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Namespace with public types should start with common prefix \'{0}\'")]
    public class WinRTInvalidRootNamespaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Namespace with public types should start with common prefix \'{0}\'";
        public WinRTInvalidRootNamespaceError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration declaration, JetBrains.ReSharper.Psi.INamespace rootNamespace) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.INamespace RootNamespace { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Type \'{0}\' is not a valid WinRT type")]
    public class WinRTInvalidTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Type \'{0}\' is not a valid WinRT type";
        public WinRTInvalidTypeError(JetBrains.ReSharper.Psi.Tree.ITreeNode node, JetBrains.ReSharper.Psi.IType type) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.IType Type { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT {0} cannot be virtual")]
    public class WinRTMemberIsVirtualError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT {0} cannot be virtual";
        public WinRTMemberIsVirtualError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="{0} \'{1}\' implements more than one interface member. Please make sure this member" +
        " only implements one interface member")]
    public class WinRTMemberMultipleImplementsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "{0} \'{1}\' implements more than one interface member. Please make sure this member" +
            " only implements one interface member";
        public WinRTMemberMultipleImplementsError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT method cannot be generic")]
    public class WinRTMethodIsGenericError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT method cannot be generic";
        public WinRTMethodIsGenericError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT override method should be sealed")]
    public class WinRTMethodShouldBeSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT override method should be sealed";
        public WinRTMethodShouldBeSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Multiple {0} with the same number of parameters cannot be marked with \'DefaultOve" +
        "rloadAttribute\'")]
    public class WinRTMultipleDefaultFunctionsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Multiple {0} with the same number of parameters cannot be marked with \'DefaultOve" +
            "rloadAttribute\'";
        public WinRTMultipleDefaultFunctionsError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Arrays in WinRT public API should be single-dimensional")]
    public class WinRTMultiRankArraysError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Arrays in WinRT public API should be single-dimensional";
        public WinRTMultiRankArraysError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Arrays cannot be nested in WinRT public API")]
    public class WinRTNestedArraysError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Arrays cannot be nested in WinRT public API";
        public WinRTNestedArraysError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT type cannot be nested")]
    public class WinRTNestedTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT type cannot be nested";
        public WinRTNestedTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT types can only implement other WinRT interfaces")]
    public class WinRTNonWinRTInterfaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT types can only implement other WinRT interfaces";
        public WinRTNonWinRTInterfaceError(JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage typeUsage, JetBrains.ReSharper.Psi.IInterface baseInterfaceType, JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration currentTypeDeclaration) { }
        public JetBrains.ReSharper.Psi.IInterface BaseInterfaceType { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration CurrentTypeDeclaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IDeclaredTypeUsage TypeUsage { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT does not support operator overloads")]
    public class WinRTOperatorDeclarationError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT does not support operator overloads";
        public WinRTOperatorDeclarationError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT method cannot have optional parameters")]
    public class WinRTOptionalParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT method cannot have optional parameters";
        public WinRTOptionalParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT method cannot have parameter arrays")]
    public class WinRTParameterArrayError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT method cannot have parameter arrays";
        public WinRTParameterArrayError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Pointer types are not allowed in WinRT public API")]
    public class WinRTPointerTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Pointer types are not allowed in WinRT public API";
        public WinRTPointerTypeError(JetBrains.ReSharper.Psi.Tree.ITreeNode node) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.Tree.ITreeNode Node { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT does not support setter-only properties")]
    public class WinRTPropertyHasNoGetterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT does not support setter-only properties";
        public WinRTPropertyHasNoGetterError(JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT constructor cannot be protected")]
    public class WinRTProtectedConstructorError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT constructor cannot be protected";
        public WinRTProtectedConstructorError(JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT static {0} cannot be protected")]
    public class WinRTProtectedMemberIsStaticError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT static {0} cannot be protected";
        public WinRTProtectedMemberIsStaticError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT signatures cannot have \'ref\' parameters")]
    public class WinRTRefParameterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT signatures cannot have \'ref\' parameters";
        public WinRTRefParameterError(JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IRegularParameterDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method has the return value named \'{0}\' which is the same as a parameter name. Wi" +
        "nRT method parameters and return value must have unique names, use \'ReturnValueN" +
        "ameAttribute\' to specify different return value name")]
    public class WinRTReturnValueNameCollideError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method has the return value named \'{0}\' which is the same as a parameter name. Wi" +
            "nRT method parameters and return value must have unique names, use \'ReturnValueN" +
            "ameAttribute\' to specify different return value name";
        public WinRTReturnValueNameCollideError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, string returnValueName) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ReturnValueName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Method has return value name that differs from implemented interface method retur" +
        "n value name \'{0}\'. Please make sure that the names are identical")]
    public class WinRTReturnValueNameDiffersError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Method has return value name that differs from implemented interface method retur" +
            "n value name \'{0}\'. Please make sure that the names are identical";
        public WinRTReturnValueNameDiffersError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, string returnValueName) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ReturnValueName { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="All public types should belong to namespaces with a common prefix")]
    public class WinRTRootNamespaceDoesntExistsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "All public types should belong to namespaces with a common prefix";
        public WinRTRootNamespaceDoesntExistsError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.ConfigurableSeverityHighlightingAttribute("CSharpWarnings::WME006", "CSHARP", CompilerIds=new string[] {
            "WME006"}, CompilerIdsWithDescription="WME006:Namespace should be default namespace of this project", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Namespace \'{0}\' should be the default namespace of this project")]
    public class WinRTRootNamespaceShouldBeDefaultWarning : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        public const string HIGHLIGHTING_ID = "CSharpWarnings::WME006";
        protected const string MESSAGE = "Namespace \'{0}\' should be the default namespace of this project";
        public WinRTRootNamespaceShouldBeDefaultWarning(JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration declaration, JetBrains.ReSharper.Psi.INamespace rootNamespace) { }
        public JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.INamespace RootNamespace { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Overloads with the same number of parameters are not allowed. Please mark one of " +
        "them with \'DefaultOverloadAttribute\'")]
    public class WinRTSameOverloadsError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Overloads with the same number of parameters are not allowed. Please mark one of " +
            "them with \'DefaultOverloadAttribute\'";
        public WinRTSameOverloadsError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT type should be sealed")]
    public class WinRTShouldBeSealedError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT type should be sealed";
        public WinRTShouldBeSealedError(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT type cannot contain both static and instance {0} with name \'{1}\'")]
    public class WinRTStaticInstanceNamesUniqueError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT type cannot contain both static and instance {0} with name \'{1}\'";
        public WinRTStaticInstanceNamesUniqueError(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.Tree.IDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT struct may only contain public fields")]
    public class WinRTStructureContainsNotPublicFieldError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT struct may only contain public fields";
        public WinRTStructureContainsNotPublicFieldError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT struct should contain at least one public field")]
    public class WinRTStructureIsEmptyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT struct should contain at least one public field";
        public WinRTStructureIsEmptyError(JetBrains.ReSharper.Psi.CSharp.Tree.IStructDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IStructDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="WinRT type cannot be generic")]
    public class WinRTTypeIsGenericError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "WinRT type cannot be generic";
        public WinRTTypeIsGenericError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="All public types should belong to namespaces with a common prefix")]
    public class WinRTTypeWithoutNamespaceError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "All public types should belong to namespaces with a common prefix";
        public WinRTTypeWithoutNamespaceError(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The {0} \'{1}\' has no setter")]
    public class WriteAccessToPropertyWithoutSetterError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The {0} \'{1}\' has no setter";
        public WriteAccessToPropertyWithoutSetterError(JetBrains.ReSharper.Psi.Resolve.IReference reference, JetBrains.ReSharper.Psi.IProperty property) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.IProperty Property { get; }
        public JetBrains.ReSharper.Psi.Resolve.IReference Reference { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, OverloadResolvePriority=-10, ToolTipFormatString="The return type of an async method must be void, Task or Task<T>")]
    public class WrongReturnTypeOfAsyncAnonymousFunctionError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The return type of an async method must be void, Task or Task<T>";
        public WrongReturnTypeOfAsyncAnonymousFunctionError(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression expression) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression Expression { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="The return type of an async method must be void, Task or Task<T>")]
    public class WrongReturnTypeOfAsyncMethodError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "The return type of an async method must be void, Task or Task<T>";
        public WrongReturnTypeOfAsyncMethodError(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration MethodDeclaration { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="Field of type \'{0}\' cannot be volatile")]
    public class WrongVolatileFieldTypeError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "Field of type \'{0}\' cannot be volatile";
        public WrongVolatileFieldTypeError(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration declaration, JetBrains.ReSharper.Psi.IField field, JetBrains.ReSharper.Psi.IType fieldType) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration Declaration { get; }
        public string ErrorStripeToolTip { get; }
        public JetBrains.ReSharper.Psi.IField Field { get; }
        public JetBrains.ReSharper.Psi.IType FieldType { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'yield return\' statement cannot appear in try/catch block")]
    public class YieldReturnStatementInTryCatchError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'yield return\' statement cannot appear in try/catch block";
        public YieldReturnStatementInTryCatchError(JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR, ToolTipFormatString="\'yield\' statement cannot appear in \'finally\' block")]
    public class YieldStatementInFinallyError : JetBrains.ReSharper.Daemon.CSharp.Errors.CSharpHighlightingBase, JetBrains.ReSharper.Daemon.IHighlighting, JetBrains.ReSharper.Daemon.Impl.IHighlightingWithRange
    {
        protected const string MESSAGE = "\'yield\' statement cannot appear in \'finally\' block";
        public YieldStatementInFinallyError(JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement statement) { }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement Statement { get; }
        public string ToolTip { get; }
        public override bool IsValid() { }
    }
}
namespace JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis
{
    
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.NonIntegerArrayCreationParameterError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.NegativeArrayCreationParameterError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ImplicitlyTypedArrayShouldHaveInitializerError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.CannotInferImplicitlyTypedArrayTypeError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ImplicitlyTypedArrayCannotHaveSizeExpressionError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantExplicitArrayCreationWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantExplicitArraySizeWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantArrayCreationExpressionWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.InvalidArrayInitializerError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectArrayElementTypeError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ArrayInitializerExpectedError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ArrayInitializerSizeMismatchError)})]
    public class ArrayCreationProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        public static System.Nullable<>[] CheckArrayInitializer(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer initializer, System.Nullable<>[] size, JetBrains.ReSharper.Psi.IType elementType) { }
        public void Run(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantCommaInArrayInitializerWarning)})]
    public class ArrayInitializerProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer arrayInitializer, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectAssignmentTargetError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AssignmentToSameVariableWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectAnonymousMethodSignatureError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AssignNullToTypeParameterWithoutClassConstraintError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectAssignmentTypeError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectCompoundAssignmentTypeError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.DynamicShiftRightOpIsNotIntWarning)})]
    public class AssignmentExpressionProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.WrongReturnTypeOfAsyncAnonymousFunctionError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AsyncMethodWithoutAwaitWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RefOrOutParameterInAsyncError)})]
    public class AsyncDelegateProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.WrongReturnTypeOfAsyncAnonymousFunctionError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AsyncMethodWithoutAwaitWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RefOrOutParameterInAsyncError)})]
    public class AsyncLambdaProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AsyncMethodInvocationWithoutAwaitWarning)})]
    public class AsyncMethodInvocationProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement expressionStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.WrongReturnTypeOfAsyncMethodError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AsyncMethodWithoutBodyError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AsyncMethodWithoutAwaitWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RefOrOutParameterInAsyncError)})]
    public class AsyncMethodProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    public class static AsyncMethodProblemAnalyzerUtil
    {
        public static bool HasAwaitExpressions([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.Tree.ITreeNode body) { }
        public static bool IsCorrectAsyncReturnType(JetBrains.ReSharper.Psi.IType type) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AsyncModifierIsNotValidOnThisItemError)})]
    public class AsyncModifierUsageProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AwaitIdentifierInAsyncMethodError)})]
    public class AwaitDeclarationProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AwaitExpressionNotUnderAsyncMethodError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AwaitExpressionUnderInvalidConstructError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AwaitExpressionUnderLinqError)})]
    public class AwaitExpressionProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.BaseMethodCallWithDefaultParameterWarning)})]
    public class BaseMethodCallWithDefaultParameterAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    public class static CallerInfoAttributesProblemAnalyzer { }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.MethodSupportsCancellationWarning)})]
    public class CancellationTokenProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration>
    {
        public static System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeOwner> CollectAvailableCancellationTokens([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.IMethod method, [JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.IDeclaredType cancellationToken) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.TypeExpectedError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.InvalidCastError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantCastWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectAnonymousMethodSignatureError),
            typeof(JetBrains.ReSharper.Daemon.UsageChecking.SuspiciousCastWarning)})]
    public class CastExpressionProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression>
    {
        public static System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Daemon.IHighlighting> CalculateHighlightings(JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression castExpression) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression castExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.CanBeReplacedWithTryCastAndCheckForNullWarning)})]
    public class CheckedCastProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.CompareOfFloatsByEqualityOperatorWarning)})]
    public class CompareOfFloatsByEqualityOperatorAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression>
    {
        public static bool IsNaN(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression equalityExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public enum IssueType
        {
            SOMETHING_OP_CONSTANT = 0,
            CONSTANT_OP_SOMETHING = 1,
            SOMETHING_OP_SOMETHING = 2,
        }
        public enum SuspiciousConstant
        {
            NONE = 0,
            NOT_A_NUMBER = 1,
            POSITIVE_INFINITY = 2,
            NEGATIVE_INFINITY = 3,
            ZERO = 4,
        }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAndExpression),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalOrExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReplaceWithStringIsNullOrEmptyWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantLogicalConditionalExpressionOperandWarning)})]
    public class ConditionalExpressionAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        public ConditionalExpressionAnalyzer(JetBrains.ReSharper.Psi.Services.StructuralSearch.StructuralSearchEngine ssrEngine, JetBrains.DocumentManagers.DocumentManager documentManager) { }
        public void Run(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.CoVariantArrayConversionWarning)})]
    public class CoVariantArrayConversionAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.DelegateSubtractionWarning)})]
    public class DelegateSubtraction2ProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAdditiveExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.DelegateSubtractionWarning)})]
    public class DelegateSubtractionProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IAdditiveExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IAdditiveExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReadAccessInDoubleCheckLockingWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.PossibleMultipleWriteAccessInDoubleCheckLockingWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.NonVolatileFieldInDoubleCheckLockingWarning)})]
    public class DoubleCheckLockingProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement>
    {
        public DoubleCheckLockingProblemAnalyzer(JetBrains.ProjectModel.ISolution solution, JetBrains.ReSharper.Psi.Services.StructuralSearch.StructuralSearchEngine structuralSearchEngine) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.EmptyForStatementWarning)})]
    public class EmptyLoopAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement forStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.UsageChecking.SuspiciousCastWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantEnumerableCastCallWarning)})]
    public class EnumerableConversionInvocationProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        public static JetBrains.ReSharper.Psi.Resolve.ExtensionMethods.ExtensionInstance<JetBrains.ReSharper.Psi.IMethod> GetInvokedConversionMethod(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression, out JetBrains.ReSharper.Psi.IType sourceType, out JetBrains.ReSharper.Psi.IType targetType) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.EnumerableSumInExplicitUncheckedContextWarning)})]
    public class EnumerableSumInExplicitUncheckedContextProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.EqualExpressionComparisonWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.BaseObjectEqualsIsObjectEqualsWarning),
            typeof(JetBrains.ReSharper.Daemon.UsageChecking.SuspiciousComparisonWarning)})]
    public class EqualsMethodAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        public static JetBrains.ReSharper.Psi.IMethod GetEqualsInvocationArguments(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, out JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression arg0, out JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression arg1) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.GCSuppressFinalizeForTypeWithoutDestructorWarning)})]
    public class GCSuppressFinalizeInvocationAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.OperatorIsCanBeUsedWarning)})]
    public class GetTypeEqualsTypeOfProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression>
    {
        public GetTypeEqualsTypeOfProblemAnalyzer(JetBrains.ProjectModel.ISolution solution, JetBrains.ReSharper.Psi.Services.StructuralSearch.StructuralSearchEngine structuralSearchEngine) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement)})]
    public class IfStatementPatternAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement>
    {
        public IfStatementPatternAnalyzer(JetBrains.ReSharper.Psi.Services.StructuralSearch.StructuralSearchEngine ssrEngine, JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.IfStatementPatternAnalyzer.IInvertIfComponent invertIfComponent) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public interface IInvertIfComponent
        {
            bool CanInvertIf([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowGraf graf);
            bool CanReduceNesting([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement, [JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowGraf graf);
        }
        public class SwitchSection
        {
            public readonly JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement Action;
            public readonly System.Collections.Generic.List<JetBrains.ReSharper.Psi.Tree.IExpression> Labels;
            public SwitchSection(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement action) { }
        }
        public class SwitchSectionsCollector
        {
            public SwitchSectionsCollector(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement ifStatement) { }
            public System.Collections.Generic.IList<JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.IfStatementPatternAnalyzer.SwitchSection> Cases { get; }
            public bool HasDefaultSection { get; }
            public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression SwitchVariableAccess { get; }
        }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration),
            typeof(JetBrains.ReSharper.Psi.Tree.IParameterDeclaration),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration),
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AnnotationRedundanceInHierarchyWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AnnotationConflictInHierarchyWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.AnnotationRedundanceAtValueTypeWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.MultipleNullableAttributesUsageWarning)})]
    public class IncorrectNullableAttributeUsageAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        public IncorrectNullableAttributeUsageAnalyzer(JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsCache codeAnnotationsCache) { }
        public void Run(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectIteratorReturnTypeError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RefOrOutIteratorParameterError)})]
    public class IteratorProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration functionDeclaration, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpLiteralExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.LongLiteralEndingLowerLWarning)})]
    public class LongLiteralEndingLowerLProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpLiteralExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpLiteralExpression literalExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.MultipleMainMethodsError)})]
    public class MainMethodProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.MethodOverloadWithOptionalParameterWarning)})]
    public class MethodOverloadWithOptionalParametersProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration typeDeclaration, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.InvalidNullCoalescingOperandsError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.InvalidNullCoalescingLeftOperandError)})]
    public class NullCoalescingExpressionAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.PossiblyMistakenUseOfParamsMethodWarning)})]
    public class PossiblyMistakenUseOfParamsMethodAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.PureAttributeOnVoidMethodWarning)})]
    public class PureAnnotationProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration>
    {
        public PureAnnotationProblemAnalyzer(JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsCache codeAnnotationsCache) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReturnValueOfPureMethodIsNotUsedWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ImpureMethodCallOnReadonlyValueFieldWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IteratorMethodResultIsIgnoredWarning)})]
    public class PureMethodCallProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        public PureMethodCallProblemAnalyzer(JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsCache codeAnnotationsCache) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantEmptyDefaultSwitchBranchWarning)})]
    public class RedundantBlockInSwitchStatementAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement switchStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ConditionIsAlwaysTrueOrFalseWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReferenceEqualsWithValueTypeWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.EqualExpressionComparisonWarning),
            typeof(JetBrains.ReSharper.Daemon.UsageChecking.SuspiciousComparisonWarning)})]
    public class ReferenceEqualsMethodAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.NonReadonlyFieldInGetHashCodeWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.BaseObjectGetHashCodeCallInGetHashCodeWarning)})]
    public class ReferenceInGetHashCodeProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReturnStatementInIteratorError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReturnTypeIsVoidError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ReturnValueMissedError),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.IncorrectReturnTypeError)})]
    public class ReturnStatementAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement returnStatementParam, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.SimplifyLinqExpressionWarning)})]
    public class SimplifyLinqExpressionAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression>
    {
        public SimplifyLinqExpressionAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.SimplifyLinqExpressionAnalyzer.PatternsAndMatchers patternsAndMatchers) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        [JetBrains.ReSharper.Psi.PsiSharedComponentAttribute()]
        public class PatternsAndMatchers
        {
            public PatternsAndMatchers(JetBrains.ReSharper.Psi.Services.StructuralSearch.StructuralSearchEngine ssrEngine, JetBrains.ReSharper.Psi.ILanguageManager languageManager) { }
            public System.Collections.Generic.IEnumerable<JetBrains.Util.Pair<JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralSearchPattern, JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatcher>> Items { get; }
        }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.SpecifyStringComparisonWarning)})]
    public class SpecifyStringComparisonAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression>
    {
        public SpecifyStringComparisonAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.Analysis.SpecifyStringComparisonAnalyzer.Matchers matchers) { }
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        [JetBrains.ReSharper.Psi.PsiSharedComponentAttribute()]
        public class Matchers
        {
            public Matchers(JetBrains.ReSharper.Psi.Services.StructuralSearch.StructuralSearchEngine ssrEngine, JetBrains.ReSharper.Psi.ILanguageManager languageManager) { }
            public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatcher StringEmpty { get; }
            public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatcher ToLower { get; }
            public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatcher ToLowerInvariant { get; }
            public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatcher ToUpper { get; }
            public JetBrains.ReSharper.Psi.Services.StructuralSearch.IStructuralMatcher ToUpperInvariant { get; }
            public bool EnsureCreatedIfAvailable() { }
        }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.StaticFieldInGenericTypeWarning)})]
    public class StaticFieldsInGenericTypeProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.RedundantTernaryExpressionWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.SimplifyConditionalTernaryExpressionWarning)})]
    public class TernaryExpressionWithBooleanLiteralInBranchAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression ternaryExpression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ThreadStaticAtInstanceFieldWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ThreadStaticFieldHasInitializerWarning)})]
    public class ThreadStaticProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration fieldDeclaration, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.TryStatementsCanBeMergedWarning)})]
    public class TryStatementProblemAnalyzer : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement>
    {
        protected override void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement tryStatement, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    public class XmlDocEntitiesAnalysis : JetBrains.ReSharper.Daemon.Xml.Stages.XmlAnalysis
    {
        public override void ProcessBeforeInterior(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer highlightings) { }
    }
}
namespace JetBrains.ReSharper.Daemon.CSharp.Stages
{
    
    public sealed class AnonymousMethodProblemAnalyzer
    {
        public AnonymousMethodProblemAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public void Check(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression anonymousMethodExpression) { }
        public void Check(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression lambdaExpression) { }
        public static bool IsExplicitTypesUsedForResolve(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression lambdaExpression) { }
        public static bool IsSignatureUsedForResolve(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression anonymousMethodExpressionParam) { }
        public static bool ShouldHighlightAnonymousMethodConversionProblem(JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionType anonymousFunctionType, JetBrains.ReSharper.Psi.IType targetType, JetBrains.ReSharper.Psi.CSharp.Impl.ICSharpTypeConversionRule typeConversionRule) { }
        public static bool ShouldHighlightAnonymousMethodConversionProblem(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression anonymousFunctionExpression, JetBrains.ReSharper.Psi.IType targetType) { }
    }
    public abstract class ClassInheritanceProblemsAnalyzer
    {
        protected ClassInheritanceProblemsAnalyzer(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration typeDeclarationParam) { }
        public JetBrains.Util.OneToListMap<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.ITypeMember> ImplementationOfInterfaces { get; }
        protected abstract void AddHighlighting(JetBrains.DocumentModel.DocumentRange range, JetBrains.ReSharper.Daemon.IHighlighting highlighting);
        protected virtual void AddQuasiImplementationAndPlusAccessors(JetBrains.ReSharper.Psi.IOverridableMember member, JetBrains.ReSharper.Psi.IOverridableMember interfaceMember, JetBrains.ReSharper.Psi.ITypeElement inType) { }
        public static bool CanHide(JetBrains.ReSharper.Daemon.CSharp.Stages.ClassInheritanceProblemsAnalyzer.MemberItem inheritor, JetBrains.ReSharper.Daemon.CSharp.Stages.ClassInheritanceProblemsAnalyzer.MemberItem parent) { }
        public static bool CanHide(JetBrains.ReSharper.Psi.ITypeMember inheritor, JetBrains.ReSharper.Daemon.CSharp.Stages.ClassInheritanceProblemsAnalyzer.MemberItem parent) { }
        protected abstract JetBrains.ReSharper.Daemon.InheritanceMarkOnGutter CreateInheritanceMarkOnGutter(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration);
        public System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.OverridableMemberInstance> GetInterfaceMembers() { }
        public System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.OverridableMemberInstance> GetPolymorphicMembers() { }
        public void Run() { }
        public class MemberItem
        {
            public MemberItem(JetBrains.ReSharper.Psi.ITypeMember member) { }
            public MemberItem(JetBrains.ReSharper.Psi.ITypeMember member, JetBrains.ReSharper.Psi.Resolve.ISubstitution substitution) { }
            public JetBrains.ReSharper.Psi.IDeclaredType ContainingType { get; }
            public JetBrains.ReSharper.Psi.ITypeMember Member { get; }
            public JetBrains.ReSharper.Psi.TypeMemberInstance MemberInstance { get; }
            public JetBrains.ReSharper.Psi.InvocableSignature Signature { get; }
            public JetBrains.ReSharper.Psi.Resolve.ISubstitution Substitution { get; }
            public override bool Equals(object obj) { }
            public override int GetHashCode() { }
        }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression)})]
    public class ControlFlowAnonymousMethodProblemAnalyzer : JetBrains.ReSharper.Daemon.CSharp.Stages.ControlFlowProblemAnalyzerBase, JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        public void Run(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration)})]
    public class ControlFlowFunctionProblemAnalyzer : JetBrains.ReSharper.Daemon.CSharp.Stages.ControlFlowProblemAnalyzerBase, JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        public void Run(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression)})]
    public class ControlFlowLambdaExpressionProblemAnalyzer : JetBrains.ReSharper.Daemon.CSharp.Stages.ControlFlowProblemAnalyzerBase, JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        public void Run(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    public class ControlFlowProblemAnalyzerBase
    {
        public static readonly JetBrains.Util.Key<JetBrains.ReSharper.Psi.ControlFlow.CSharp.CumulativeCSharpControlFlowAnalysisResult> KEY_CONTROL_FLOW_RESULT;
        protected void ReportIssues(JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowGraf graf, JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowAnalysisResult controlFlowAnalysisResult, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settingsStore) { }
        protected void ReportValueAnalysisIssues(JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowAnalysisResult controlFlowAnalysisResult, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Daemon.IDaemonProcess process) { }
        protected void ShareAnalysisResult(JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowAnalysisResult controlFlowAnalysisResult) { }
        protected void StaticAnalysis(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, [JetBrains.Annotations.CanBeNullAttribute()] JetBrains.ReSharper.Psi.CSharp.Tree.IBlock bodyBlock, JetBrains.ReSharper.Psi.ControlFlow.CSharp.ICSharpControlFlowGraf graf, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ConvertToAutoPropertyWarning),
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.ConvertToAutoPropertyWithPrivateSetterWarning)})]
    public class ConvertToAutoPropertyAnalyzer : JetBrains.ReSharper.Daemon.CSharp.Stages.ConvertToAutoPropertyAnalyzerBase, JetBrains.ReSharper.Daemon.Stages.Dispatcher.IElementProblemAnalyzer
    {
        protected override System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.Tree.ITreeNode> GetBackingFieldUsages(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.ReSharper.Psi.IField backingField) { }
    }
    public abstract class ConvertToAutoPropertyAnalyzerBase
    {
        protected bool CanConvertNonIntrusive(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration propertyDeclaration, out JetBrains.ReSharper.Psi.IField backingField) { }
        protected bool CanConvertSafe(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration propertyDeclaration, out JetBrains.ReSharper.Psi.IField backingField) { }
        protected abstract System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.Tree.ITreeNode> GetBackingFieldUsages(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.ReSharper.Psi.IField backingField);
    }
    [JetBrains.ReSharper.Psi.LanguageAttribute(typeof(JetBrains.ReSharper.Psi.CSharp.CSharpLanguage))]
    public class CSharpCompilerWarningPreprocessor : JetBrains.ReSharper.Daemon.Stages.ICompilerWarningPreProcessor
    {
        public bool PreProcess(System.Collections.Generic.IList<string> compilerIds, JetBrains.ReSharper.Psi.Tree.IFile file, out System.Nullable<> severity, out string attributeId) { }
    }
    public abstract class CSharpDaemonStageBase : JetBrains.ReSharper.Daemon.IDaemonStage
    {
        protected abstract JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file);
        public System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Daemon.IDaemonStageProcess> CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind) { }
        protected virtual bool IsSupported(JetBrains.ReSharper.Psi.IPsiSourceFile sourceFile) { }
        public virtual JetBrains.ReSharper.Daemon.ErrorStripeRequest NeedsErrorStripe(JetBrains.ReSharper.Psi.IPsiSourceFile sourceFile, JetBrains.Application.Settings.IContextBoundSettingsStore settings) { }
    }
    public abstract class CSharpDaemonStageProcessBase : JetBrains.ReSharper.Psi.CSharp.Tree.TreeNodeVisitor<JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer>, JetBrains.ReSharper.Daemon.IDaemonStageProcess, JetBrains.ReSharper.Psi.IRecursiveElementProcessor<JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer>
    {
        protected CSharpDaemonStageProcessBase(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
        public JetBrains.ReSharper.Daemon.IDaemonProcess DaemonProcess { get; }
        public JetBrains.DocumentModel.IDocument Document { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile File { get; }
        [JetBrains.Annotations.NotNullAttribute()]
        public JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpFileStructure FileStructure { get; }
        public bool IsCSharp30 { get; }
        public bool IsCSharp40 { get; }
        public JetBrains.ReSharper.Psi.Modules.IPsiModule PsiModule { get; }
        public JetBrains.ReSharper.Psi.CSharp.Impl.ICSharpTypeConversionRule TypeConversionRule { get; }
        public abstract void Execute(System.Action<JetBrains.ReSharper.Daemon.DaemonStageResult> committer);
        protected void HighlightInFile(System.Action<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer> fileHighlighter, System.Action<JetBrains.ReSharper.Daemon.DaemonStageResult> commiter, JetBrains.Application.Settings.IContextBoundSettingsStore settingsStore) { }
        public virtual bool InteriorShouldBeProcessed(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer context) { }
        public bool IsProcessingFinished(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer context) { }
        public virtual void ProcessAfterInterior(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public virtual void ProcessBeforeInterior(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    public class static CSharpDaemonUtil
    {
        public static bool CheckResolveEquivalence(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, [JetBrains.Annotations.InstantHandleAttribute()] System.Action<JetBrains.ReSharper.Psi.Tree.ITreeNode> mutator, [JetBrains.Annotations.InstantHandleAttribute()] System.Func<JetBrains.ReSharper.Psi.Tree.ITreeNode, bool> customCheck) { }
        public static JetBrains.ReSharper.Psi.IParametersOwner GetIncorrectArgumentsNumberInvocable(JetBrains.ReSharper.Psi.IDeclaredElement element) { }
        public static bool IsClosureVariable(JetBrains.ReSharper.Psi.IDeclaredElement element, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression accessExpression) { }
        public static bool IsMethodInvokedOf(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public static bool IsUnderAnonymousMethod(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public static bool IsUnderExpressionTree(JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public static JetBrains.ReSharper.Psi.Resolve.ExtensionMethods.ExtensionInstance<JetBrains.ReSharper.Psi.IDeclaredElement> Resolve(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public static bool ResolveSemanticEquivalence(JetBrains.ReSharper.Psi.DeclaredElementInstance i1, JetBrains.ReSharper.Psi.DeclaredElementInstance i2) { }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesAfter=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.LanguageSpecificDaemonStage)}, StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStage)})]
    public class CSharpErrorStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        public CSharpErrorStage(JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerRegistrar elementProblemAnalyzerRegistrar, JetBrains.ReSharper.Daemon.CSharp.Stages.DetectUnreferencedModuleFactory detectUnreferencedModuleFactory) { }
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
    }
    public class CSharpFileStructure : JetBrains.ReSharper.Daemon.Stages.FileStructureWithRegionsBase
    {
        public CSharpFileStructure(System.Predicate<JetBrains.DocumentModel.DocumentRange> isRangeInvalidated, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file, JetBrains.Application.Settings.IContextBoundSettingsStore settingsStore) { }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IStartRegion this[JetBrains.ReSharper.Psi.CSharp.Tree.IEndRegion node] { get; }
        public JetBrains.ReSharper.Psi.CSharp.Tree.IEndRegion this[JetBrains.ReSharper.Psi.CSharp.Tree.IStartRegion node] { get; }
        public System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration> MembersToRehighlight { get; }
    }
    [JetBrains.ReSharper.Daemon.Stages.FileStructureExplorerAttribute()]
    public class CSharpFileStructureExplorer : JetBrains.ReSharper.Daemon.Stages.IFileStructureExplorer
    {
        public JetBrains.ReSharper.Daemon.Stages.IFileStructure Run(System.Predicate<JetBrains.DocumentModel.DocumentRange> isRangeInvalidated, JetBrains.ReSharper.Psi.IPsiSourceFile psiSourceFile, JetBrains.Application.Settings.IContextBoundSettingsStore settingsStore, JetBrains.ReSharper.Psi.Tree.IFile file1) { }
    }
    public class static CSharpHighlightingConsumerExtension
    {
        public static void AddHighlighting(this JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Daemon.IHighlighting error, JetBrains.DocumentModel.DocumentRange range) { }
        public static void AddHighlighting(this JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Daemon.IHighlighting error) { }
    }
    public class CSharpIdentifierHighlighter
    {
        public CSharpIdentifierHighlighter([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.Tree.ITreeNode root) { }
        public void Highlight(JetBrains.ReSharper.Psi.Tree.ITreeNode element, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.DaemonTooltipProviderAttribute(typeof(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpIdentifierTooltipProvider))]
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.INFO, "IdentifierHighlightings", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.NONE, ShowToolTipInStatusBar=false)]
    public sealed class CSharpIdentifierHighlighting : JetBrains.ReSharper.Daemon.ICustomAttributeIdHighlighting, JetBrains.ReSharper.Daemon.IHighlighting
    {
        public CSharpIdentifierHighlighting(string attributeId) { }
        public string AttributeId { get; }
        public string ErrorStripeToolTip { get; }
        public int NavigationOffsetPatch { get; }
        public string ToolTip { get; }
        public bool IsValid() { }
    }
    public abstract class CSharpIncrementalDaemonStageProcessBase : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase
    {
        protected CSharpIncrementalDaemonStageProcessBase(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settingsStore, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
        public override void Execute(System.Action<JetBrains.ReSharper.Daemon.DaemonStageResult> committer) { }
    }
    [JetBrains.ReSharper.Daemon.StaticSeverityHighlightingAttribute(JetBrains.ReSharper.Daemon.Severity.ERROR, "CSharpErrors", OverlapResolve=JetBrains.ReSharper.Daemon.OverlapResolveKind.ERROR)]
    public class CSharpSyntaxError : JetBrains.ReSharper.Daemon.Impl.SyntaxErrorBase
    {
        public CSharpSyntaxError(string toolTip) { }
    }
    [JetBrains.ProjectModel.ProjectFileTypeAttribute(typeof(JetBrains.ProjectModel.CSharpProjectFileType))]
    public class CSharpSyntaxHighlighting : JetBrains.ReSharper.Daemon.SyntaxHighlighting
    {
        public CSharpSyntaxHighlighting(JetBrains.ProjectModel.CSharpProjectFileType projectFileType, JetBrains.ProjectModel.SolutionsManager solutionsManager, JetBrains.TextControl.DefaultTextControlSchemeManager defaultTextControlSchemeManager) { }
        public override JetBrains.Util.TextRange GetAttributesForOffset(JetBrains.TextControl.ITextControl textControl, int offset, out JetBrains.TextControl.DocumentMarkup.HighlighterAttributes attributes) { }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpErrorStage)})]
    public class CSharpUnusedUsingDirectiveAnalysisStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        public CSharpUnusedUsingDirectiveAnalysisStage(JetBrains.ReSharper.Psi.ExtensionsAPI.FileDependency fileDependency) { }
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
        protected override bool IsSupported(JetBrains.ReSharper.Psi.IPsiSourceFile sourceFile) { }
    }
    public class DetectUnreferencedModule
    {
        public DetectUnreferencedModule(JetBrains.ReSharper.Daemon.IDaemonProcess daemonProcess) { }
        protected virtual bool IsDLRSupportVisible(JetBrains.ReSharper.Psi.Tree.IExpression expression) { }
        public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.Tree.ITreeNode referenceElement, JetBrains.ReSharper.Psi.IType type) { }
        public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression expression) { }
        public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName) { }
    }
    [JetBrains.ProjectModel.SolutionComponentAttribute()]
    public class DetectUnreferencedModuleFactory
    {
        public virtual JetBrains.ReSharper.Daemon.CSharp.Stages.DetectUnreferencedModule CreateDetectUnreferencedModule(JetBrains.ReSharper.Daemon.IDaemonProcess daemonProcess) { }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesAfter=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStage)}, StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Stages.SmartResolverStage)})]
    public class IdentifierHighlightingStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        public IdentifierHighlightingStage(JetBrains.ReSharper.Daemon.Stages.Resolve.ResolveHighlighterRegistrar resolveHighlighterRegistrar) { }
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
    }
    public class static InconsistentAccessibilityAnalyzer
    {
        public static bool CheckAccessibilityConsistent(JetBrains.ReSharper.Psi.ITypeElement testType, JetBrains.ReSharper.Psi.ITypeMember contextMember, [JetBrains.Annotations.CanBeNullAttribute()] JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process) { }
        public static void CheckMemberTypeAccessibility(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.ITypeMember typeMember, JetBrains.ReSharper.Psi.IType memberType, JetBrains.ReSharper.Psi.Tree.ITreeNode typeNode) { }
        public static void CheckParametersAccessibility(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.ITypeMember member, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration declarationWithParameters) { }
        public static void CheckReturnTypeAccessibility(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.ITypeMember typeMember, JetBrains.ReSharper.Psi.IType returnType, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode) { }
        public static void CheckTypeArgumentsAccessibility(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName, JetBrains.ReSharper.Psi.ITypeMember typeMember) { }
        public static void CheckTypeParameterConstraintAccessibility(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration typeDeclaration) { }
        public static void CheckTypeParameterConstraintAccessibility(JetBrains.ReSharper.Daemon.UsageChecking.CollectUsagesStageProcess process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration methodDeclaration) { }
    }
    public class InterfaceInheritanceProblemAnalyzer
    {
        public InterfaceInheritanceProblemAnalyzer(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration interfaceDeclaration) { }
    }
    public sealed class InvocationProblemAnalyzer
    {
        public InvocationProblemAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression expression, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public sealed class RedundantStringFormatAnalyzer
        {
            public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.DeclaredElementInstance<JetBrains.ReSharper.Psi.IMethod> method) { }
        }
        public sealed class RedundantToStringAnalyzer
        {
            public static bool IsRedundant(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression toStringExpression) { }
            public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression invocationExpression, JetBrains.ReSharper.Psi.DeclaredElementInstance<JetBrains.ReSharper.Psi.IMethod> method) { }
        }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.LanguageSpecificDaemonStage)})]
    public class NewLanguageConstructStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
    }
    public class static ObjectCreationProblemAnalyzer
    {
        public static void AnalyzeAnonymousTypeSimilarity(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IBlock body) { }
        public static void CheckAnonymousObjectCreationExpression(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectCreationExpression anonymousObjectCreationExpression) { }
        public static void CheckCollectionInitializer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionInitializer initializer) { }
        public static void CheckObjectCreationExpression(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression) { }
        public static void CheckObjectInitializer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IObjectInitializer initializer) { }
        public static bool IsDelegateCreationRedundant(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression expression) { }
        public class SuggestInitializerUseChecker
        {
            public SuggestInitializerUseChecker(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression, JetBrains.ReSharper.Psi.ITypeConversionRule typeConversionRule) { }
            public ConversionItem[] ConversionItems { get; }
            public static System.Nullable<JetBrains.Util.Pair<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement>> GetAssignmentDestination(JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression objectCreationExpression) { }
            public static bool IsValidObjectInitializerMember(JetBrains.ReSharper.Psi.IDeclaredElement element) { }
            public System.Nullable<JetBrains.ReSharper.Daemon.CSharp.Stages.ObjectCreationProblemAnalyzer.SuggestInitializerUseChecker.SuggestionType> Run() { }
            public class ConversionItem
            {
                public ConversionItem[] Children;
                public JetBrains.ReSharper.Psi.ITypeMember InitializerMember;
                public JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement OriginalStatement;
                public JetBrains.ReSharper.Daemon.CSharp.Stages.ObjectCreationProblemAnalyzer.SuggestInitializerUseChecker.SuggestionType Suggestion;
            }
            public enum SuggestionType
            {
                USE_OBJECT_INITIALIZER = 0,
                USE_COLLECTION_INITIALIZER = 1,
                NESTED_OBJECT_INITIALIZER = 2,
            }
        }
    }
    public sealed class RedundantCastAnalyzer
    {
        public RedundantCastAnalyzer(JetBrains.ReSharper.Psi.CSharp.Impl.ICSharpTypeConversionRule typeConversionRule) { }
        public bool TypeDownCastIsRedundant(JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression castExpression) { }
        public bool TypeUpCastIsRedundant(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression castExpression) { }
    }
    public class SmartResolverProcess : JetBrains.ReSharper.Daemon.IDaemonStageProcess
    {
        public SmartResolverProcess(JetBrains.ReSharper.Daemon.IDaemonProcess daemonProcess, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
        public JetBrains.ReSharper.Daemon.IDaemonProcess DaemonProcess { get; }
        public void Execute(System.Action<JetBrains.ReSharper.Daemon.DaemonStageResult> committer) { }
        public System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.ITypeElement> GetTypesHiddenByTypeParameter(JetBrains.ReSharper.Psi.ITypeParameter typeParameter) { }
        public JetBrains.ReSharper.Psi.Resolve.IResolveResult GetUnqualifiedResolve(JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public bool IsUsingDirectiveUsed(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective directive) { }
        public bool IsVarTypeVisibleInScope(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope scope) { }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.Stages.GlobalFileStructureCollectorStage)})]
    public class SmartResolverStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
        public override JetBrains.ReSharper.Daemon.ErrorStripeRequest NeedsErrorStripe(JetBrains.ReSharper.Psi.IPsiSourceFile sourceFile, JetBrains.Application.Settings.IContextBoundSettingsStore settings) { }
    }
    public class static SwitchStatementProblemAnalyzer
    {
        public static void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchLabelStatement switchLabelStatement) { }
        public static void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement switchStatement) { }
    }
    public sealed class TypeArgumentProblemAnalyzer
    {
        public TypeArgumentProblemAnalyzer(JetBrains.ReSharper.Psi.Modules.IPsiModule module, JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext resolveContext) { }
        public void CheckImplicitInvocation(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
        public static bool IsTypeArgumentListRedundant(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList typeArgumentList) { }
        public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerAccessExpression pointerAccessExpression) { }
        public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression referenceExpression) { }
        public void Run(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName referenceName) { }
    }
    public class TypeElementProblemAnalyzer
    {
        public TypeElementProblemAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public void CheckCircularInterfaceDependency(JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration interfaceDeclarationParam) { }
        public void CheckCyclicStructLayout(JetBrains.ReSharper.Psi.CSharp.Tree.IStructDeclaration structDeclaration) { }
        public void CheckDuplicateAccessors(JetBrains.ReSharper.Psi.Tree.TreeNodeEnumerable<JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration> accessorDeclarations) { }
        public void CheckDuplicateDeclaredElements(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration) { }
        public void CheckEnumBaseList(JetBrains.ReSharper.Psi.CSharp.Tree.IEnumDeclaration enumDeclarationParam) { }
        public void CheckExtendsListProblems(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration derivedDeclaration, [JetBrains.Annotations.NotNullAttribute()] JetBrains.Util.OneToListMap<JetBrains.ReSharper.Psi.IDeclaredType, JetBrains.ReSharper.Psi.ITypeMember> interfaceImplementationMembers) { }
        public void CheckInterfaceUnification(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration) { }
        public void CheckPartialTypeProblems(JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration declaration) { }
        public void CheckRecursiveConstructorCall(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration typeDeclaration) { }
        public void CheckStaticClassProblems(JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration classDeclaration, JetBrains.ReSharper.Psi.IClass @class) { }
        public void CheckTypeModifiers(JetBrains.ReSharper.Psi.CSharp.Tree.IProperTypeDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList modifiersListNode) { }
        public bool ClassIsNeverInstantiated(JetBrains.ReSharper.Psi.IClass @class) { }
        public void VisitMemberOwnerDeclaration(JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration memberOwnerDeclaration) { }
    }
    public class TypeParameterProblemAnalyzer
    {
        public TypeParameterProblemAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public static bool AreCompatible(System.Collections.Generic.IList<JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause> clauses1, System.Collections.Generic.IList<JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause> clauses2) { }
        public static bool AreConstraintsEqual(JetBrains.ReSharper.Psi.ITypeParameter parameter1, JetBrains.ReSharper.Psi.Resolve.ISubstitution substitution1, JetBrains.ReSharper.Psi.ITypeParameter parameter2, JetBrains.ReSharper.Psi.Resolve.ISubstitution substitution2) { }
        public static bool IsValid(System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause> clauses) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration declaration) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration declaration) { }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.LanguageSpecificDaemonStage)})]
    public class UnsafeContextCheckingStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
    }
    public sealed class VariableDeclarationProblemAnalyzer
    {
        public VariableDeclarationProblemAnalyzer(JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageProcessBase process, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
        public void Check(JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer initializer) { }
        public void Check(JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.DeclaredElementInstance variable, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public void CheckConstantInitializer(JetBrains.ReSharper.Psi.IType constantType, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.Tree.IDeclaration declaration, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression initializer) { }
        public static JetBrains.ReSharper.Daemon.CSharp.Stages.VariableDeclarationProblemAnalyzer.ImplicitDeclarationProblem CheckImplicitDeclarationProblem(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration) { }
        public void CheckInitialization(JetBrains.ReSharper.Psi.DeclaredElementInstance variable, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, [JetBrains.Annotations.InstantHandleAttribute()] System.Func<JetBrains.DocumentModel.DocumentRange> rangeCreator) { }
        public void CheckVariableType(JetBrains.ReSharper.Psi.IType type, JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage typeUsageNode, JetBrains.ReSharper.Psi.IDeclaredElement variable) { }
        public static bool IsAssignNullToTypeParameterWithoutConstraints(JetBrains.ReSharper.Psi.IType destination, JetBrains.ReSharper.Psi.Tree.IExpression sourceExpression) { }
        public static bool IsDefaultInitializer(JetBrains.ReSharper.Psi.IType variableType, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public static bool IsTypeEvident(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration declaration) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.ILocalConstantDeclaration declaration) { }
        public void Run(JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration declaration) { }
        public enum ImplicitDeclarationProblem
        {
            OK = 0,
            MULTIPLE_DECLARATION = 1,
            NO_INITIALIZER = 2,
            NOT_EXPRESSION_INITIALIZER = 3,
            SHOULD_HAVE_TYPE = 4,
        }
    }
    [JetBrains.ReSharper.Daemon.DaemonStageAttribute(StagesBefore=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.LanguageSpecificDaemonStage)})]
    public class WinRTStage : JetBrains.ReSharper.Daemon.CSharp.Stages.CSharpDaemonStageBase
    {
        protected override JetBrains.ReSharper.Daemon.IDaemonStageProcess CreateProcess(JetBrains.ReSharper.Daemon.IDaemonProcess process, JetBrains.Application.Settings.IContextBoundSettingsStore settings, JetBrains.ReSharper.Daemon.DaemonProcessKind processKind, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile file) { }
    }
}
namespace JetBrains.ReSharper.Daemon.CSharp.Stages.Performance
{
    
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.BoxingOccuranceHighlighting)})]
    public class BoxingOccuranceAnalyzer : JetBrains.ReSharper.Daemon.CSharp.Stages.Performance.PerformanceProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression>
    {
        public BoxingOccuranceAnalyzer(JetBrains.DataFlow.Lifetime lifetime, JetBrains.ProjectModel.ISolution solution, JetBrains.Application.Settings.ISettingsStore settingsStore) { }
        protected override void Execute(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    [JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerAttribute(new System.Type[] {
            typeof(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression)}, HighlightingTypes=new System.Type[] {
            typeof(JetBrains.ReSharper.Daemon.CSharp.Errors.CapturedIdentifierHighlighting)})]
    public class CapturedVariablesHighlighter : JetBrains.ReSharper.Daemon.CSharp.Stages.Performance.PerformanceProblemAnalyzer<JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression>
    {
        public CapturedVariablesHighlighter(JetBrains.DataFlow.Lifetime lifetime, JetBrains.ProjectModel.ISolution solution, JetBrains.Application.Settings.ISettingsStore settingsStore) { }
        protected override void Execute(JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
    public abstract class PerformanceProblemAnalyzer<T> : JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzer<T>
        where T : JetBrains.ReSharper.Psi.Tree.ITreeNode
    {
        protected PerformanceProblemAnalyzer(JetBrains.DataFlow.Lifetime lifetime, JetBrains.ProjectModel.ISolution solution, JetBrains.Application.Settings.ISettingsStore settingsStore) { }
        protected abstract void Execute(T element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer);
        protected override void Run(T element, JetBrains.ReSharper.Daemon.Stages.Dispatcher.ElementProblemAnalyzerData data, JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer) { }
    }
}
namespace JetBrains.ReSharper.Daemon.CSharp.Stages.Resolve
{
    
    public class ResolveProblemHighlighter
    {
        public ResolveProblemHighlighter([JetBrains.Annotations.NotNullAttribute()] JetBrains.ReSharper.Psi.Tree.ITreeNode root, JetBrains.ReSharper.Daemon.Stages.Resolve.ResolveHighlighterRegistrar resolveHighlighterRegistrar) { }
        public void CheckForResolveProblems(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.Tree.ITreeNode element) { }
        public void CheckForResolveProblems(JetBrains.ReSharper.Daemon.Stages.IHighlightingConsumer consumer, JetBrains.ReSharper.Psi.Resolve.IReference reference) { }
    }
}
namespace JetBrains.ReSharper.Daemon.CSharp.Stages.UsageChecking
{
    
    public class static CSharpTypeConstraintsUtil
    {
        public static System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.ILocalVariable> LocalsToCorrectType(JetBrains.ReSharper.Psi.IDeclaredElement element, JetBrains.ReSharper.Psi.IType newType, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression usage) { }
        public static System.Collections.Generic.ICollection<JetBrains.ReSharper.Daemon.UsageChecking.ITypeUsageConstraint> TypeConstraintsFromUsage(JetBrains.ReSharper.Psi.IDeclaredElement element, JetBrains.ReSharper.Psi.IType elementType, JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression expression) { }
    }
    public class CSharpUnusedDeclarationAnalyzer : JetBrains.ReSharper.Daemon.UsageChecking.CLRUnusedDeclarationAnalyzer
    {
        public CSharpUnusedDeclarationAnalyzer(JetBrains.ReSharper.Psi.ExtensionsAPI.FileDependency fileDependency, JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker usageChecker, JetBrains.ReSharper.Psi.PsiLanguageType language, System.Action<JetBrains.ReSharper.Daemon.IHighlighting> consumer, JetBrains.ReSharper.Daemon.UsageChecking.DeclarationInfoCache declarationInfoCache, System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Daemon.UsageChecking.IUsageInspectionsSupressor> supressors) { }
        protected override void ProcessField(JetBrains.ReSharper.Daemon.UsageChecking.IDeclarationInfo fieldDeclaration) { }
    }
}